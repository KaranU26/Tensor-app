
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserOnboarding
 * 
 */
export type UserOnboarding = $Result.DefaultSelection<Prisma.$UserOnboardingPayload>
/**
 * Model UserFollow
 * 
 */
export type UserFollow = $Result.DefaultSelection<Prisma.$UserFollowPayload>
/**
 * Model Stretch
 * 
 */
export type Stretch = $Result.DefaultSelection<Prisma.$StretchPayload>
/**
 * Model StretchingRoutine
 * 
 */
export type StretchingRoutine = $Result.DefaultSelection<Prisma.$StretchingRoutinePayload>
/**
 * Model RoutineStretch
 * 
 */
export type RoutineStretch = $Result.DefaultSelection<Prisma.$RoutineStretchPayload>
/**
 * Model StretchingSession
 * 
 */
export type StretchingSession = $Result.DefaultSelection<Prisma.$StretchingSessionPayload>
/**
 * Model SessionStretch
 * 
 */
export type SessionStretch = $Result.DefaultSelection<Prisma.$SessionStretchPayload>
/**
 * Model FlexibilityGoal
 * 
 */
export type FlexibilityGoal = $Result.DefaultSelection<Prisma.$FlexibilityGoalPayload>
/**
 * Model RomMeasurement
 * 
 */
export type RomMeasurement = $Result.DefaultSelection<Prisma.$RomMeasurementPayload>
/**
 * Model ProgressVideo
 * 
 */
export type ProgressVideo = $Result.DefaultSelection<Prisma.$ProgressVideoPayload>
/**
 * Model Exercise
 * 
 */
export type Exercise = $Result.DefaultSelection<Prisma.$ExercisePayload>
/**
 * Model StrengthWorkout
 * 
 */
export type StrengthWorkout = $Result.DefaultSelection<Prisma.$StrengthWorkoutPayload>
/**
 * Model WorkoutExercise
 * 
 */
export type WorkoutExercise = $Result.DefaultSelection<Prisma.$WorkoutExercisePayload>
/**
 * Model WorkoutSet
 * 
 */
export type WorkoutSet = $Result.DefaultSelection<Prisma.$WorkoutSetPayload>
/**
 * Model PersonalRecord
 * 
 */
export type PersonalRecord = $Result.DefaultSelection<Prisma.$PersonalRecordPayload>
/**
 * Model BodyMetric
 * 
 */
export type BodyMetric = $Result.DefaultSelection<Prisma.$BodyMetricPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model UserConsent
 * 
 */
export type UserConsent = $Result.DefaultSelection<Prisma.$UserConsentPayload>
/**
 * Model DataExportRequest
 * 
 */
export type DataExportRequest = $Result.DefaultSelection<Prisma.$DataExportRequestPayload>
/**
 * Model DeletionRequest
 * 
 */
export type DeletionRequest = $Result.DefaultSelection<Prisma.$DeletionRequestPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userOnboarding`: Exposes CRUD operations for the **UserOnboarding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserOnboardings
    * const userOnboardings = await prisma.userOnboarding.findMany()
    * ```
    */
  get userOnboarding(): Prisma.UserOnboardingDelegate<ExtArgs>;

  /**
   * `prisma.userFollow`: Exposes CRUD operations for the **UserFollow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFollows
    * const userFollows = await prisma.userFollow.findMany()
    * ```
    */
  get userFollow(): Prisma.UserFollowDelegate<ExtArgs>;

  /**
   * `prisma.stretch`: Exposes CRUD operations for the **Stretch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stretches
    * const stretches = await prisma.stretch.findMany()
    * ```
    */
  get stretch(): Prisma.StretchDelegate<ExtArgs>;

  /**
   * `prisma.stretchingRoutine`: Exposes CRUD operations for the **StretchingRoutine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StretchingRoutines
    * const stretchingRoutines = await prisma.stretchingRoutine.findMany()
    * ```
    */
  get stretchingRoutine(): Prisma.StretchingRoutineDelegate<ExtArgs>;

  /**
   * `prisma.routineStretch`: Exposes CRUD operations for the **RoutineStretch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoutineStretches
    * const routineStretches = await prisma.routineStretch.findMany()
    * ```
    */
  get routineStretch(): Prisma.RoutineStretchDelegate<ExtArgs>;

  /**
   * `prisma.stretchingSession`: Exposes CRUD operations for the **StretchingSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StretchingSessions
    * const stretchingSessions = await prisma.stretchingSession.findMany()
    * ```
    */
  get stretchingSession(): Prisma.StretchingSessionDelegate<ExtArgs>;

  /**
   * `prisma.sessionStretch`: Exposes CRUD operations for the **SessionStretch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionStretches
    * const sessionStretches = await prisma.sessionStretch.findMany()
    * ```
    */
  get sessionStretch(): Prisma.SessionStretchDelegate<ExtArgs>;

  /**
   * `prisma.flexibilityGoal`: Exposes CRUD operations for the **FlexibilityGoal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlexibilityGoals
    * const flexibilityGoals = await prisma.flexibilityGoal.findMany()
    * ```
    */
  get flexibilityGoal(): Prisma.FlexibilityGoalDelegate<ExtArgs>;

  /**
   * `prisma.romMeasurement`: Exposes CRUD operations for the **RomMeasurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RomMeasurements
    * const romMeasurements = await prisma.romMeasurement.findMany()
    * ```
    */
  get romMeasurement(): Prisma.RomMeasurementDelegate<ExtArgs>;

  /**
   * `prisma.progressVideo`: Exposes CRUD operations for the **ProgressVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgressVideos
    * const progressVideos = await prisma.progressVideo.findMany()
    * ```
    */
  get progressVideo(): Prisma.ProgressVideoDelegate<ExtArgs>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<ExtArgs>;

  /**
   * `prisma.strengthWorkout`: Exposes CRUD operations for the **StrengthWorkout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StrengthWorkouts
    * const strengthWorkouts = await prisma.strengthWorkout.findMany()
    * ```
    */
  get strengthWorkout(): Prisma.StrengthWorkoutDelegate<ExtArgs>;

  /**
   * `prisma.workoutExercise`: Exposes CRUD operations for the **WorkoutExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutExercises
    * const workoutExercises = await prisma.workoutExercise.findMany()
    * ```
    */
  get workoutExercise(): Prisma.WorkoutExerciseDelegate<ExtArgs>;

  /**
   * `prisma.workoutSet`: Exposes CRUD operations for the **WorkoutSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutSets
    * const workoutSets = await prisma.workoutSet.findMany()
    * ```
    */
  get workoutSet(): Prisma.WorkoutSetDelegate<ExtArgs>;

  /**
   * `prisma.personalRecord`: Exposes CRUD operations for the **PersonalRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalRecords
    * const personalRecords = await prisma.personalRecord.findMany()
    * ```
    */
  get personalRecord(): Prisma.PersonalRecordDelegate<ExtArgs>;

  /**
   * `prisma.bodyMetric`: Exposes CRUD operations for the **BodyMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BodyMetrics
    * const bodyMetrics = await prisma.bodyMetric.findMany()
    * ```
    */
  get bodyMetric(): Prisma.BodyMetricDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.userConsent`: Exposes CRUD operations for the **UserConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserConsents
    * const userConsents = await prisma.userConsent.findMany()
    * ```
    */
  get userConsent(): Prisma.UserConsentDelegate<ExtArgs>;

  /**
   * `prisma.dataExportRequest`: Exposes CRUD operations for the **DataExportRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataExportRequests
    * const dataExportRequests = await prisma.dataExportRequest.findMany()
    * ```
    */
  get dataExportRequest(): Prisma.DataExportRequestDelegate<ExtArgs>;

  /**
   * `prisma.deletionRequest`: Exposes CRUD operations for the **DeletionRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeletionRequests
    * const deletionRequests = await prisma.deletionRequest.findMany()
    * ```
    */
  get deletionRequest(): Prisma.DeletionRequestDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserOnboarding: 'UserOnboarding',
    UserFollow: 'UserFollow',
    Stretch: 'Stretch',
    StretchingRoutine: 'StretchingRoutine',
    RoutineStretch: 'RoutineStretch',
    StretchingSession: 'StretchingSession',
    SessionStretch: 'SessionStretch',
    FlexibilityGoal: 'FlexibilityGoal',
    RomMeasurement: 'RomMeasurement',
    ProgressVideo: 'ProgressVideo',
    Exercise: 'Exercise',
    StrengthWorkout: 'StrengthWorkout',
    WorkoutExercise: 'WorkoutExercise',
    WorkoutSet: 'WorkoutSet',
    PersonalRecord: 'PersonalRecord',
    BodyMetric: 'BodyMetric',
    Notification: 'Notification',
    NotificationPreference: 'NotificationPreference',
    Subscription: 'Subscription',
    UserConsent: 'UserConsent',
    DataExportRequest: 'DataExportRequest',
    DeletionRequest: 'DeletionRequest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "userOnboarding" | "userFollow" | "stretch" | "stretchingRoutine" | "routineStretch" | "stretchingSession" | "sessionStretch" | "flexibilityGoal" | "romMeasurement" | "progressVideo" | "exercise" | "strengthWorkout" | "workoutExercise" | "workoutSet" | "personalRecord" | "bodyMetric" | "notification" | "notificationPreference" | "subscription" | "userConsent" | "dataExportRequest" | "deletionRequest"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserOnboarding: {
        payload: Prisma.$UserOnboardingPayload<ExtArgs>
        fields: Prisma.UserOnboardingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserOnboardingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserOnboardingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>
          }
          findFirst: {
            args: Prisma.UserOnboardingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserOnboardingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>
          }
          findMany: {
            args: Prisma.UserOnboardingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>[]
          }
          create: {
            args: Prisma.UserOnboardingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>
          }
          createMany: {
            args: Prisma.UserOnboardingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserOnboardingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>[]
          }
          delete: {
            args: Prisma.UserOnboardingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>
          }
          update: {
            args: Prisma.UserOnboardingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>
          }
          deleteMany: {
            args: Prisma.UserOnboardingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserOnboardingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserOnboardingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOnboardingPayload>
          }
          aggregate: {
            args: Prisma.UserOnboardingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserOnboarding>
          }
          groupBy: {
            args: Prisma.UserOnboardingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserOnboardingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserOnboardingCountArgs<ExtArgs>
            result: $Utils.Optional<UserOnboardingCountAggregateOutputType> | number
          }
        }
      }
      UserFollow: {
        payload: Prisma.$UserFollowPayload<ExtArgs>
        fields: Prisma.UserFollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          findFirst: {
            args: Prisma.UserFollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          findMany: {
            args: Prisma.UserFollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>[]
          }
          create: {
            args: Prisma.UserFollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          createMany: {
            args: Prisma.UserFollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>[]
          }
          delete: {
            args: Prisma.UserFollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          update: {
            args: Prisma.UserFollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          deleteMany: {
            args: Prisma.UserFollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserFollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          aggregate: {
            args: Prisma.UserFollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFollow>
          }
          groupBy: {
            args: Prisma.UserFollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFollowCountArgs<ExtArgs>
            result: $Utils.Optional<UserFollowCountAggregateOutputType> | number
          }
        }
      }
      Stretch: {
        payload: Prisma.$StretchPayload<ExtArgs>
        fields: Prisma.StretchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StretchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StretchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchPayload>
          }
          findFirst: {
            args: Prisma.StretchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StretchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchPayload>
          }
          findMany: {
            args: Prisma.StretchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchPayload>[]
          }
          create: {
            args: Prisma.StretchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchPayload>
          }
          createMany: {
            args: Prisma.StretchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StretchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchPayload>[]
          }
          delete: {
            args: Prisma.StretchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchPayload>
          }
          update: {
            args: Prisma.StretchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchPayload>
          }
          deleteMany: {
            args: Prisma.StretchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StretchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StretchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchPayload>
          }
          aggregate: {
            args: Prisma.StretchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStretch>
          }
          groupBy: {
            args: Prisma.StretchGroupByArgs<ExtArgs>
            result: $Utils.Optional<StretchGroupByOutputType>[]
          }
          count: {
            args: Prisma.StretchCountArgs<ExtArgs>
            result: $Utils.Optional<StretchCountAggregateOutputType> | number
          }
        }
      }
      StretchingRoutine: {
        payload: Prisma.$StretchingRoutinePayload<ExtArgs>
        fields: Prisma.StretchingRoutineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StretchingRoutineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingRoutinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StretchingRoutineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingRoutinePayload>
          }
          findFirst: {
            args: Prisma.StretchingRoutineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingRoutinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StretchingRoutineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingRoutinePayload>
          }
          findMany: {
            args: Prisma.StretchingRoutineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingRoutinePayload>[]
          }
          create: {
            args: Prisma.StretchingRoutineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingRoutinePayload>
          }
          createMany: {
            args: Prisma.StretchingRoutineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StretchingRoutineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingRoutinePayload>[]
          }
          delete: {
            args: Prisma.StretchingRoutineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingRoutinePayload>
          }
          update: {
            args: Prisma.StretchingRoutineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingRoutinePayload>
          }
          deleteMany: {
            args: Prisma.StretchingRoutineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StretchingRoutineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StretchingRoutineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingRoutinePayload>
          }
          aggregate: {
            args: Prisma.StretchingRoutineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStretchingRoutine>
          }
          groupBy: {
            args: Prisma.StretchingRoutineGroupByArgs<ExtArgs>
            result: $Utils.Optional<StretchingRoutineGroupByOutputType>[]
          }
          count: {
            args: Prisma.StretchingRoutineCountArgs<ExtArgs>
            result: $Utils.Optional<StretchingRoutineCountAggregateOutputType> | number
          }
        }
      }
      RoutineStretch: {
        payload: Prisma.$RoutineStretchPayload<ExtArgs>
        fields: Prisma.RoutineStretchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoutineStretchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineStretchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoutineStretchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineStretchPayload>
          }
          findFirst: {
            args: Prisma.RoutineStretchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineStretchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoutineStretchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineStretchPayload>
          }
          findMany: {
            args: Prisma.RoutineStretchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineStretchPayload>[]
          }
          create: {
            args: Prisma.RoutineStretchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineStretchPayload>
          }
          createMany: {
            args: Prisma.RoutineStretchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoutineStretchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineStretchPayload>[]
          }
          delete: {
            args: Prisma.RoutineStretchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineStretchPayload>
          }
          update: {
            args: Prisma.RoutineStretchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineStretchPayload>
          }
          deleteMany: {
            args: Prisma.RoutineStretchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoutineStretchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoutineStretchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutineStretchPayload>
          }
          aggregate: {
            args: Prisma.RoutineStretchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoutineStretch>
          }
          groupBy: {
            args: Prisma.RoutineStretchGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoutineStretchGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoutineStretchCountArgs<ExtArgs>
            result: $Utils.Optional<RoutineStretchCountAggregateOutputType> | number
          }
        }
      }
      StretchingSession: {
        payload: Prisma.$StretchingSessionPayload<ExtArgs>
        fields: Prisma.StretchingSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StretchingSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StretchingSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingSessionPayload>
          }
          findFirst: {
            args: Prisma.StretchingSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StretchingSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingSessionPayload>
          }
          findMany: {
            args: Prisma.StretchingSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingSessionPayload>[]
          }
          create: {
            args: Prisma.StretchingSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingSessionPayload>
          }
          createMany: {
            args: Prisma.StretchingSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StretchingSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingSessionPayload>[]
          }
          delete: {
            args: Prisma.StretchingSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingSessionPayload>
          }
          update: {
            args: Prisma.StretchingSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingSessionPayload>
          }
          deleteMany: {
            args: Prisma.StretchingSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StretchingSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StretchingSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StretchingSessionPayload>
          }
          aggregate: {
            args: Prisma.StretchingSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStretchingSession>
          }
          groupBy: {
            args: Prisma.StretchingSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StretchingSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StretchingSessionCountArgs<ExtArgs>
            result: $Utils.Optional<StretchingSessionCountAggregateOutputType> | number
          }
        }
      }
      SessionStretch: {
        payload: Prisma.$SessionStretchPayload<ExtArgs>
        fields: Prisma.SessionStretchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionStretchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStretchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionStretchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStretchPayload>
          }
          findFirst: {
            args: Prisma.SessionStretchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStretchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionStretchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStretchPayload>
          }
          findMany: {
            args: Prisma.SessionStretchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStretchPayload>[]
          }
          create: {
            args: Prisma.SessionStretchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStretchPayload>
          }
          createMany: {
            args: Prisma.SessionStretchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionStretchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStretchPayload>[]
          }
          delete: {
            args: Prisma.SessionStretchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStretchPayload>
          }
          update: {
            args: Prisma.SessionStretchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStretchPayload>
          }
          deleteMany: {
            args: Prisma.SessionStretchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionStretchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionStretchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionStretchPayload>
          }
          aggregate: {
            args: Prisma.SessionStretchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionStretch>
          }
          groupBy: {
            args: Prisma.SessionStretchGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionStretchGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionStretchCountArgs<ExtArgs>
            result: $Utils.Optional<SessionStretchCountAggregateOutputType> | number
          }
        }
      }
      FlexibilityGoal: {
        payload: Prisma.$FlexibilityGoalPayload<ExtArgs>
        fields: Prisma.FlexibilityGoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlexibilityGoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlexibilityGoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlexibilityGoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlexibilityGoalPayload>
          }
          findFirst: {
            args: Prisma.FlexibilityGoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlexibilityGoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlexibilityGoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlexibilityGoalPayload>
          }
          findMany: {
            args: Prisma.FlexibilityGoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlexibilityGoalPayload>[]
          }
          create: {
            args: Prisma.FlexibilityGoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlexibilityGoalPayload>
          }
          createMany: {
            args: Prisma.FlexibilityGoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlexibilityGoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlexibilityGoalPayload>[]
          }
          delete: {
            args: Prisma.FlexibilityGoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlexibilityGoalPayload>
          }
          update: {
            args: Prisma.FlexibilityGoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlexibilityGoalPayload>
          }
          deleteMany: {
            args: Prisma.FlexibilityGoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlexibilityGoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlexibilityGoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlexibilityGoalPayload>
          }
          aggregate: {
            args: Prisma.FlexibilityGoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlexibilityGoal>
          }
          groupBy: {
            args: Prisma.FlexibilityGoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlexibilityGoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlexibilityGoalCountArgs<ExtArgs>
            result: $Utils.Optional<FlexibilityGoalCountAggregateOutputType> | number
          }
        }
      }
      RomMeasurement: {
        payload: Prisma.$RomMeasurementPayload<ExtArgs>
        fields: Prisma.RomMeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RomMeasurementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RomMeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RomMeasurementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RomMeasurementPayload>
          }
          findFirst: {
            args: Prisma.RomMeasurementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RomMeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RomMeasurementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RomMeasurementPayload>
          }
          findMany: {
            args: Prisma.RomMeasurementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RomMeasurementPayload>[]
          }
          create: {
            args: Prisma.RomMeasurementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RomMeasurementPayload>
          }
          createMany: {
            args: Prisma.RomMeasurementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RomMeasurementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RomMeasurementPayload>[]
          }
          delete: {
            args: Prisma.RomMeasurementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RomMeasurementPayload>
          }
          update: {
            args: Prisma.RomMeasurementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RomMeasurementPayload>
          }
          deleteMany: {
            args: Prisma.RomMeasurementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RomMeasurementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RomMeasurementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RomMeasurementPayload>
          }
          aggregate: {
            args: Prisma.RomMeasurementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRomMeasurement>
          }
          groupBy: {
            args: Prisma.RomMeasurementGroupByArgs<ExtArgs>
            result: $Utils.Optional<RomMeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.RomMeasurementCountArgs<ExtArgs>
            result: $Utils.Optional<RomMeasurementCountAggregateOutputType> | number
          }
        }
      }
      ProgressVideo: {
        payload: Prisma.$ProgressVideoPayload<ExtArgs>
        fields: Prisma.ProgressVideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgressVideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressVideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgressVideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressVideoPayload>
          }
          findFirst: {
            args: Prisma.ProgressVideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressVideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgressVideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressVideoPayload>
          }
          findMany: {
            args: Prisma.ProgressVideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressVideoPayload>[]
          }
          create: {
            args: Prisma.ProgressVideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressVideoPayload>
          }
          createMany: {
            args: Prisma.ProgressVideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgressVideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressVideoPayload>[]
          }
          delete: {
            args: Prisma.ProgressVideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressVideoPayload>
          }
          update: {
            args: Prisma.ProgressVideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressVideoPayload>
          }
          deleteMany: {
            args: Prisma.ProgressVideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgressVideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgressVideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressVideoPayload>
          }
          aggregate: {
            args: Prisma.ProgressVideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgressVideo>
          }
          groupBy: {
            args: Prisma.ProgressVideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgressVideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgressVideoCountArgs<ExtArgs>
            result: $Utils.Optional<ProgressVideoCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: Prisma.$ExercisePayload<ExtArgs>
        fields: Prisma.ExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      StrengthWorkout: {
        payload: Prisma.$StrengthWorkoutPayload<ExtArgs>
        fields: Prisma.StrengthWorkoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StrengthWorkoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthWorkoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StrengthWorkoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthWorkoutPayload>
          }
          findFirst: {
            args: Prisma.StrengthWorkoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthWorkoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StrengthWorkoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthWorkoutPayload>
          }
          findMany: {
            args: Prisma.StrengthWorkoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthWorkoutPayload>[]
          }
          create: {
            args: Prisma.StrengthWorkoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthWorkoutPayload>
          }
          createMany: {
            args: Prisma.StrengthWorkoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StrengthWorkoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthWorkoutPayload>[]
          }
          delete: {
            args: Prisma.StrengthWorkoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthWorkoutPayload>
          }
          update: {
            args: Prisma.StrengthWorkoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthWorkoutPayload>
          }
          deleteMany: {
            args: Prisma.StrengthWorkoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StrengthWorkoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StrengthWorkoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthWorkoutPayload>
          }
          aggregate: {
            args: Prisma.StrengthWorkoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrengthWorkout>
          }
          groupBy: {
            args: Prisma.StrengthWorkoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<StrengthWorkoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.StrengthWorkoutCountArgs<ExtArgs>
            result: $Utils.Optional<StrengthWorkoutCountAggregateOutputType> | number
          }
        }
      }
      WorkoutExercise: {
        payload: Prisma.$WorkoutExercisePayload<ExtArgs>
        fields: Prisma.WorkoutExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>
          }
          findFirst: {
            args: Prisma.WorkoutExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>
          }
          findMany: {
            args: Prisma.WorkoutExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>[]
          }
          create: {
            args: Prisma.WorkoutExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>
          }
          createMany: {
            args: Prisma.WorkoutExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>[]
          }
          delete: {
            args: Prisma.WorkoutExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>
          }
          update: {
            args: Prisma.WorkoutExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>
          }
          deleteMany: {
            args: Prisma.WorkoutExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkoutExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutExercisePayload>
          }
          aggregate: {
            args: Prisma.WorkoutExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkoutExercise>
          }
          groupBy: {
            args: Prisma.WorkoutExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutExerciseCountAggregateOutputType> | number
          }
        }
      }
      WorkoutSet: {
        payload: Prisma.$WorkoutSetPayload<ExtArgs>
        fields: Prisma.WorkoutSetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutSetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutSetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>
          }
          findFirst: {
            args: Prisma.WorkoutSetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutSetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>
          }
          findMany: {
            args: Prisma.WorkoutSetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>[]
          }
          create: {
            args: Prisma.WorkoutSetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>
          }
          createMany: {
            args: Prisma.WorkoutSetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutSetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>[]
          }
          delete: {
            args: Prisma.WorkoutSetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>
          }
          update: {
            args: Prisma.WorkoutSetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>
          }
          deleteMany: {
            args: Prisma.WorkoutSetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutSetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkoutSetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutSetPayload>
          }
          aggregate: {
            args: Prisma.WorkoutSetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkoutSet>
          }
          groupBy: {
            args: Prisma.WorkoutSetGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutSetGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutSetCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutSetCountAggregateOutputType> | number
          }
        }
      }
      PersonalRecord: {
        payload: Prisma.$PersonalRecordPayload<ExtArgs>
        fields: Prisma.PersonalRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>
          }
          findFirst: {
            args: Prisma.PersonalRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>
          }
          findMany: {
            args: Prisma.PersonalRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>[]
          }
          create: {
            args: Prisma.PersonalRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>
          }
          createMany: {
            args: Prisma.PersonalRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonalRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>[]
          }
          delete: {
            args: Prisma.PersonalRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>
          }
          update: {
            args: Prisma.PersonalRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>
          }
          deleteMany: {
            args: Prisma.PersonalRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonalRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalRecordPayload>
          }
          aggregate: {
            args: Prisma.PersonalRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalRecord>
          }
          groupBy: {
            args: Prisma.PersonalRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalRecordCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalRecordCountAggregateOutputType> | number
          }
        }
      }
      BodyMetric: {
        payload: Prisma.$BodyMetricPayload<ExtArgs>
        fields: Prisma.BodyMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BodyMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BodyMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyMetricPayload>
          }
          findFirst: {
            args: Prisma.BodyMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BodyMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyMetricPayload>
          }
          findMany: {
            args: Prisma.BodyMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyMetricPayload>[]
          }
          create: {
            args: Prisma.BodyMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyMetricPayload>
          }
          createMany: {
            args: Prisma.BodyMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BodyMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyMetricPayload>[]
          }
          delete: {
            args: Prisma.BodyMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyMetricPayload>
          }
          update: {
            args: Prisma.BodyMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyMetricPayload>
          }
          deleteMany: {
            args: Prisma.BodyMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BodyMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BodyMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyMetricPayload>
          }
          aggregate: {
            args: Prisma.BodyMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBodyMetric>
          }
          groupBy: {
            args: Prisma.BodyMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<BodyMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.BodyMetricCountArgs<ExtArgs>
            result: $Utils.Optional<BodyMetricCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      UserConsent: {
        payload: Prisma.$UserConsentPayload<ExtArgs>
        fields: Prisma.UserConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          findFirst: {
            args: Prisma.UserConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          findMany: {
            args: Prisma.UserConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          create: {
            args: Prisma.UserConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          createMany: {
            args: Prisma.UserConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          delete: {
            args: Prisma.UserConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          update: {
            args: Prisma.UserConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          deleteMany: {
            args: Prisma.UserConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          aggregate: {
            args: Prisma.UserConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserConsent>
          }
          groupBy: {
            args: Prisma.UserConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserConsentCountArgs<ExtArgs>
            result: $Utils.Optional<UserConsentCountAggregateOutputType> | number
          }
        }
      }
      DataExportRequest: {
        payload: Prisma.$DataExportRequestPayload<ExtArgs>
        fields: Prisma.DataExportRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataExportRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataExportRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>
          }
          findFirst: {
            args: Prisma.DataExportRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataExportRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>
          }
          findMany: {
            args: Prisma.DataExportRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>[]
          }
          create: {
            args: Prisma.DataExportRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>
          }
          createMany: {
            args: Prisma.DataExportRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataExportRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>[]
          }
          delete: {
            args: Prisma.DataExportRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>
          }
          update: {
            args: Prisma.DataExportRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>
          }
          deleteMany: {
            args: Prisma.DataExportRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataExportRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataExportRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataExportRequestPayload>
          }
          aggregate: {
            args: Prisma.DataExportRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataExportRequest>
          }
          groupBy: {
            args: Prisma.DataExportRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataExportRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataExportRequestCountArgs<ExtArgs>
            result: $Utils.Optional<DataExportRequestCountAggregateOutputType> | number
          }
        }
      }
      DeletionRequest: {
        payload: Prisma.$DeletionRequestPayload<ExtArgs>
        fields: Prisma.DeletionRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeletionRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletionRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeletionRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletionRequestPayload>
          }
          findFirst: {
            args: Prisma.DeletionRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletionRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeletionRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletionRequestPayload>
          }
          findMany: {
            args: Prisma.DeletionRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletionRequestPayload>[]
          }
          create: {
            args: Prisma.DeletionRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletionRequestPayload>
          }
          createMany: {
            args: Prisma.DeletionRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeletionRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletionRequestPayload>[]
          }
          delete: {
            args: Prisma.DeletionRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletionRequestPayload>
          }
          update: {
            args: Prisma.DeletionRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletionRequestPayload>
          }
          deleteMany: {
            args: Prisma.DeletionRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeletionRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeletionRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletionRequestPayload>
          }
          aggregate: {
            args: Prisma.DeletionRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeletionRequest>
          }
          groupBy: {
            args: Prisma.DeletionRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeletionRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeletionRequestCountArgs<ExtArgs>
            result: $Utils.Optional<DeletionRequestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    stretchingRoutines: number
    stretchingSessions: number
    flexibilityGoals: number
    bodyMetrics: number
    strengthWorkouts: number
    personalRecords: number
    notifications: number
    consents: number
    following: number
    followers: number
    progressVideos: number
    dataExportRequests: number
    deletionRequests: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stretchingRoutines?: boolean | UserCountOutputTypeCountStretchingRoutinesArgs
    stretchingSessions?: boolean | UserCountOutputTypeCountStretchingSessionsArgs
    flexibilityGoals?: boolean | UserCountOutputTypeCountFlexibilityGoalsArgs
    bodyMetrics?: boolean | UserCountOutputTypeCountBodyMetricsArgs
    strengthWorkouts?: boolean | UserCountOutputTypeCountStrengthWorkoutsArgs
    personalRecords?: boolean | UserCountOutputTypeCountPersonalRecordsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    consents?: boolean | UserCountOutputTypeCountConsentsArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    progressVideos?: boolean | UserCountOutputTypeCountProgressVideosArgs
    dataExportRequests?: boolean | UserCountOutputTypeCountDataExportRequestsArgs
    deletionRequests?: boolean | UserCountOutputTypeCountDeletionRequestsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStretchingRoutinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StretchingRoutineWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStretchingSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StretchingSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFlexibilityGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlexibilityGoalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBodyMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BodyMetricWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStrengthWorkoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrengthWorkoutWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPersonalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConsentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProgressVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressVideoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDataExportRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataExportRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeletionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeletionRequestWhereInput
  }


  /**
   * Count Type StretchCountOutputType
   */

  export type StretchCountOutputType = {
    routineStretches: number
    sessionStretches: number
  }

  export type StretchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routineStretches?: boolean | StretchCountOutputTypeCountRoutineStretchesArgs
    sessionStretches?: boolean | StretchCountOutputTypeCountSessionStretchesArgs
  }

  // Custom InputTypes
  /**
   * StretchCountOutputType without action
   */
  export type StretchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchCountOutputType
     */
    select?: StretchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StretchCountOutputType without action
   */
  export type StretchCountOutputTypeCountRoutineStretchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutineStretchWhereInput
  }

  /**
   * StretchCountOutputType without action
   */
  export type StretchCountOutputTypeCountSessionStretchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionStretchWhereInput
  }


  /**
   * Count Type StretchingRoutineCountOutputType
   */

  export type StretchingRoutineCountOutputType = {
    stretches: number
    sessions: number
  }

  export type StretchingRoutineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stretches?: boolean | StretchingRoutineCountOutputTypeCountStretchesArgs
    sessions?: boolean | StretchingRoutineCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * StretchingRoutineCountOutputType without action
   */
  export type StretchingRoutineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutineCountOutputType
     */
    select?: StretchingRoutineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StretchingRoutineCountOutputType without action
   */
  export type StretchingRoutineCountOutputTypeCountStretchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutineStretchWhereInput
  }

  /**
   * StretchingRoutineCountOutputType without action
   */
  export type StretchingRoutineCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StretchingSessionWhereInput
  }


  /**
   * Count Type StretchingSessionCountOutputType
   */

  export type StretchingSessionCountOutputType = {
    stretches: number
  }

  export type StretchingSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stretches?: boolean | StretchingSessionCountOutputTypeCountStretchesArgs
  }

  // Custom InputTypes
  /**
   * StretchingSessionCountOutputType without action
   */
  export type StretchingSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSessionCountOutputType
     */
    select?: StretchingSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StretchingSessionCountOutputType without action
   */
  export type StretchingSessionCountOutputTypeCountStretchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionStretchWhereInput
  }


  /**
   * Count Type FlexibilityGoalCountOutputType
   */

  export type FlexibilityGoalCountOutputType = {
    measurements: number
    progressVideos: number
  }

  export type FlexibilityGoalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    measurements?: boolean | FlexibilityGoalCountOutputTypeCountMeasurementsArgs
    progressVideos?: boolean | FlexibilityGoalCountOutputTypeCountProgressVideosArgs
  }

  // Custom InputTypes
  /**
   * FlexibilityGoalCountOutputType without action
   */
  export type FlexibilityGoalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoalCountOutputType
     */
    select?: FlexibilityGoalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlexibilityGoalCountOutputType without action
   */
  export type FlexibilityGoalCountOutputTypeCountMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RomMeasurementWhereInput
  }

  /**
   * FlexibilityGoalCountOutputType without action
   */
  export type FlexibilityGoalCountOutputTypeCountProgressVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressVideoWhereInput
  }


  /**
   * Count Type ExerciseCountOutputType
   */

  export type ExerciseCountOutputType = {
    workoutExercises: number
    personalRecords: number
  }

  export type ExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workoutExercises?: boolean | ExerciseCountOutputTypeCountWorkoutExercisesArgs
    personalRecords?: boolean | ExerciseCountOutputTypeCountPersonalRecordsArgs
  }

  // Custom InputTypes
  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseCountOutputType
     */
    select?: ExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountWorkoutExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutExerciseWhereInput
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountPersonalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalRecordWhereInput
  }


  /**
   * Count Type StrengthWorkoutCountOutputType
   */

  export type StrengthWorkoutCountOutputType = {
    exercises: number
  }

  export type StrengthWorkoutCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercises?: boolean | StrengthWorkoutCountOutputTypeCountExercisesArgs
  }

  // Custom InputTypes
  /**
   * StrengthWorkoutCountOutputType without action
   */
  export type StrengthWorkoutCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkoutCountOutputType
     */
    select?: StrengthWorkoutCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StrengthWorkoutCountOutputType without action
   */
  export type StrengthWorkoutCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutExerciseWhereInput
  }


  /**
   * Count Type WorkoutExerciseCountOutputType
   */

  export type WorkoutExerciseCountOutputType = {
    sets: number
  }

  export type WorkoutExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sets?: boolean | WorkoutExerciseCountOutputTypeCountSetsArgs
  }

  // Custom InputTypes
  /**
   * WorkoutExerciseCountOutputType without action
   */
  export type WorkoutExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExerciseCountOutputType
     */
    select?: WorkoutExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkoutExerciseCountOutputType without action
   */
  export type WorkoutExerciseCountOutputTypeCountSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutSetWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string | null
    passwordHash: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    onboarding?: boolean | User$onboardingArgs<ExtArgs>
    notificationPrefs?: boolean | User$notificationPrefsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    stretchingRoutines?: boolean | User$stretchingRoutinesArgs<ExtArgs>
    stretchingSessions?: boolean | User$stretchingSessionsArgs<ExtArgs>
    flexibilityGoals?: boolean | User$flexibilityGoalsArgs<ExtArgs>
    bodyMetrics?: boolean | User$bodyMetricsArgs<ExtArgs>
    strengthWorkouts?: boolean | User$strengthWorkoutsArgs<ExtArgs>
    personalRecords?: boolean | User$personalRecordsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    consents?: boolean | User$consentsArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    progressVideos?: boolean | User$progressVideosArgs<ExtArgs>
    dataExportRequests?: boolean | User$dataExportRequestsArgs<ExtArgs>
    deletionRequests?: boolean | User$deletionRequestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    onboarding?: boolean | User$onboardingArgs<ExtArgs>
    notificationPrefs?: boolean | User$notificationPrefsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    stretchingRoutines?: boolean | User$stretchingRoutinesArgs<ExtArgs>
    stretchingSessions?: boolean | User$stretchingSessionsArgs<ExtArgs>
    flexibilityGoals?: boolean | User$flexibilityGoalsArgs<ExtArgs>
    bodyMetrics?: boolean | User$bodyMetricsArgs<ExtArgs>
    strengthWorkouts?: boolean | User$strengthWorkoutsArgs<ExtArgs>
    personalRecords?: boolean | User$personalRecordsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    consents?: boolean | User$consentsArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    progressVideos?: boolean | User$progressVideosArgs<ExtArgs>
    dataExportRequests?: boolean | User$dataExportRequestsArgs<ExtArgs>
    deletionRequests?: boolean | User$deletionRequestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      onboarding: Prisma.$UserOnboardingPayload<ExtArgs> | null
      notificationPrefs: Prisma.$NotificationPreferencePayload<ExtArgs> | null
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      stretchingRoutines: Prisma.$StretchingRoutinePayload<ExtArgs>[]
      stretchingSessions: Prisma.$StretchingSessionPayload<ExtArgs>[]
      flexibilityGoals: Prisma.$FlexibilityGoalPayload<ExtArgs>[]
      bodyMetrics: Prisma.$BodyMetricPayload<ExtArgs>[]
      strengthWorkouts: Prisma.$StrengthWorkoutPayload<ExtArgs>[]
      personalRecords: Prisma.$PersonalRecordPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      consents: Prisma.$UserConsentPayload<ExtArgs>[]
      following: Prisma.$UserFollowPayload<ExtArgs>[]
      followers: Prisma.$UserFollowPayload<ExtArgs>[]
      progressVideos: Prisma.$ProgressVideoPayload<ExtArgs>[]
      dataExportRequests: Prisma.$DataExportRequestPayload<ExtArgs>[]
      deletionRequests: Prisma.$DeletionRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string | null
      passwordHash: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    onboarding<T extends User$onboardingArgs<ExtArgs> = {}>(args?: Subset<T, User$onboardingArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notificationPrefs<T extends User$notificationPrefsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPrefsArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    stretchingRoutines<T extends User$stretchingRoutinesArgs<ExtArgs> = {}>(args?: Subset<T, User$stretchingRoutinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "findMany"> | Null>
    stretchingSessions<T extends User$stretchingSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$stretchingSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "findMany"> | Null>
    flexibilityGoals<T extends User$flexibilityGoalsArgs<ExtArgs> = {}>(args?: Subset<T, User$flexibilityGoalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "findMany"> | Null>
    bodyMetrics<T extends User$bodyMetricsArgs<ExtArgs> = {}>(args?: Subset<T, User$bodyMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodyMetricPayload<ExtArgs>, T, "findMany"> | Null>
    strengthWorkouts<T extends User$strengthWorkoutsArgs<ExtArgs> = {}>(args?: Subset<T, User$strengthWorkoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrengthWorkoutPayload<ExtArgs>, T, "findMany"> | Null>
    personalRecords<T extends User$personalRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$personalRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    consents<T extends User$consentsArgs<ExtArgs> = {}>(args?: Subset<T, User$consentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findMany"> | Null>
    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findMany"> | Null>
    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findMany"> | Null>
    progressVideos<T extends User$progressVideosArgs<ExtArgs> = {}>(args?: Subset<T, User$progressVideosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressVideoPayload<ExtArgs>, T, "findMany"> | Null>
    dataExportRequests<T extends User$dataExportRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$dataExportRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "findMany"> | Null>
    deletionRequests<T extends User$deletionRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$deletionRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeletionRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.onboarding
   */
  export type User$onboardingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    where?: UserOnboardingWhereInput
  }

  /**
   * User.notificationPrefs
   */
  export type User$notificationPrefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * User.stretchingRoutines
   */
  export type User$stretchingRoutinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineInclude<ExtArgs> | null
    where?: StretchingRoutineWhereInput
    orderBy?: StretchingRoutineOrderByWithRelationInput | StretchingRoutineOrderByWithRelationInput[]
    cursor?: StretchingRoutineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StretchingRoutineScalarFieldEnum | StretchingRoutineScalarFieldEnum[]
  }

  /**
   * User.stretchingSessions
   */
  export type User$stretchingSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionInclude<ExtArgs> | null
    where?: StretchingSessionWhereInput
    orderBy?: StretchingSessionOrderByWithRelationInput | StretchingSessionOrderByWithRelationInput[]
    cursor?: StretchingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StretchingSessionScalarFieldEnum | StretchingSessionScalarFieldEnum[]
  }

  /**
   * User.flexibilityGoals
   */
  export type User$flexibilityGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalInclude<ExtArgs> | null
    where?: FlexibilityGoalWhereInput
    orderBy?: FlexibilityGoalOrderByWithRelationInput | FlexibilityGoalOrderByWithRelationInput[]
    cursor?: FlexibilityGoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlexibilityGoalScalarFieldEnum | FlexibilityGoalScalarFieldEnum[]
  }

  /**
   * User.bodyMetrics
   */
  export type User$bodyMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyMetric
     */
    select?: BodyMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyMetricInclude<ExtArgs> | null
    where?: BodyMetricWhereInput
    orderBy?: BodyMetricOrderByWithRelationInput | BodyMetricOrderByWithRelationInput[]
    cursor?: BodyMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BodyMetricScalarFieldEnum | BodyMetricScalarFieldEnum[]
  }

  /**
   * User.strengthWorkouts
   */
  export type User$strengthWorkoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkout
     */
    select?: StrengthWorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthWorkoutInclude<ExtArgs> | null
    where?: StrengthWorkoutWhereInput
    orderBy?: StrengthWorkoutOrderByWithRelationInput | StrengthWorkoutOrderByWithRelationInput[]
    cursor?: StrengthWorkoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StrengthWorkoutScalarFieldEnum | StrengthWorkoutScalarFieldEnum[]
  }

  /**
   * User.personalRecords
   */
  export type User$personalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    where?: PersonalRecordWhereInput
    orderBy?: PersonalRecordOrderByWithRelationInput | PersonalRecordOrderByWithRelationInput[]
    cursor?: PersonalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalRecordScalarFieldEnum | PersonalRecordScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.consents
   */
  export type User$consentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    where?: UserConsentWhereInput
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    cursor?: UserConsentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    where?: UserFollowWhereInput
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    cursor?: UserFollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    where?: UserFollowWhereInput
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    cursor?: UserFollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * User.progressVideos
   */
  export type User$progressVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoInclude<ExtArgs> | null
    where?: ProgressVideoWhereInput
    orderBy?: ProgressVideoOrderByWithRelationInput | ProgressVideoOrderByWithRelationInput[]
    cursor?: ProgressVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressVideoScalarFieldEnum | ProgressVideoScalarFieldEnum[]
  }

  /**
   * User.dataExportRequests
   */
  export type User$dataExportRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    where?: DataExportRequestWhereInput
    orderBy?: DataExportRequestOrderByWithRelationInput | DataExportRequestOrderByWithRelationInput[]
    cursor?: DataExportRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataExportRequestScalarFieldEnum | DataExportRequestScalarFieldEnum[]
  }

  /**
   * User.deletionRequests
   */
  export type User$deletionRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletionRequest
     */
    select?: DeletionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletionRequestInclude<ExtArgs> | null
    where?: DeletionRequestWhereInput
    orderBy?: DeletionRequestOrderByWithRelationInput | DeletionRequestOrderByWithRelationInput[]
    cursor?: DeletionRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeletionRequestScalarFieldEnum | DeletionRequestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserOnboarding
   */

  export type AggregateUserOnboarding = {
    _count: UserOnboardingCountAggregateOutputType | null
    _avg: UserOnboardingAvgAggregateOutputType | null
    _sum: UserOnboardingSumAggregateOutputType | null
    _min: UserOnboardingMinAggregateOutputType | null
    _max: UserOnboardingMaxAggregateOutputType | null
  }

  export type UserOnboardingAvgAggregateOutputType = {
    toeTouchScore: number | null
    shoulderReachScore: number | null
    hipFlexibilityScore: number | null
    overallFlexibilityScore: number | null
  }

  export type UserOnboardingSumAggregateOutputType = {
    toeTouchScore: number | null
    shoulderReachScore: number | null
    hipFlexibilityScore: number | null
    overallFlexibilityScore: number | null
  }

  export type UserOnboardingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    completedAt: Date | null
    skipped: boolean | null
    primaryGoal: string | null
    experienceLevel: string | null
    toeTouchScore: number | null
    shoulderReachScore: number | null
    hipFlexibilityScore: number | null
    overallFlexibilityScore: number | null
    flexibilityLevel: string | null
    workoutDays: string | null
    preferredWorkoutTime: string | null
    stretchingPreference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserOnboardingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    completedAt: Date | null
    skipped: boolean | null
    primaryGoal: string | null
    experienceLevel: string | null
    toeTouchScore: number | null
    shoulderReachScore: number | null
    hipFlexibilityScore: number | null
    overallFlexibilityScore: number | null
    flexibilityLevel: string | null
    workoutDays: string | null
    preferredWorkoutTime: string | null
    stretchingPreference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserOnboardingCountAggregateOutputType = {
    id: number
    userId: number
    completedAt: number
    skipped: number
    primaryGoal: number
    experienceLevel: number
    toeTouchScore: number
    shoulderReachScore: number
    hipFlexibilityScore: number
    overallFlexibilityScore: number
    flexibilityLevel: number
    workoutDays: number
    preferredWorkoutTime: number
    stretchingPreference: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserOnboardingAvgAggregateInputType = {
    toeTouchScore?: true
    shoulderReachScore?: true
    hipFlexibilityScore?: true
    overallFlexibilityScore?: true
  }

  export type UserOnboardingSumAggregateInputType = {
    toeTouchScore?: true
    shoulderReachScore?: true
    hipFlexibilityScore?: true
    overallFlexibilityScore?: true
  }

  export type UserOnboardingMinAggregateInputType = {
    id?: true
    userId?: true
    completedAt?: true
    skipped?: true
    primaryGoal?: true
    experienceLevel?: true
    toeTouchScore?: true
    shoulderReachScore?: true
    hipFlexibilityScore?: true
    overallFlexibilityScore?: true
    flexibilityLevel?: true
    workoutDays?: true
    preferredWorkoutTime?: true
    stretchingPreference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserOnboardingMaxAggregateInputType = {
    id?: true
    userId?: true
    completedAt?: true
    skipped?: true
    primaryGoal?: true
    experienceLevel?: true
    toeTouchScore?: true
    shoulderReachScore?: true
    hipFlexibilityScore?: true
    overallFlexibilityScore?: true
    flexibilityLevel?: true
    workoutDays?: true
    preferredWorkoutTime?: true
    stretchingPreference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserOnboardingCountAggregateInputType = {
    id?: true
    userId?: true
    completedAt?: true
    skipped?: true
    primaryGoal?: true
    experienceLevel?: true
    toeTouchScore?: true
    shoulderReachScore?: true
    hipFlexibilityScore?: true
    overallFlexibilityScore?: true
    flexibilityLevel?: true
    workoutDays?: true
    preferredWorkoutTime?: true
    stretchingPreference?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserOnboardingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOnboarding to aggregate.
     */
    where?: UserOnboardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOnboardings to fetch.
     */
    orderBy?: UserOnboardingOrderByWithRelationInput | UserOnboardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserOnboardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOnboardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOnboardings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserOnboardings
    **/
    _count?: true | UserOnboardingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserOnboardingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserOnboardingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOnboardingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOnboardingMaxAggregateInputType
  }

  export type GetUserOnboardingAggregateType<T extends UserOnboardingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOnboarding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOnboarding[P]>
      : GetScalarType<T[P], AggregateUserOnboarding[P]>
  }




  export type UserOnboardingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOnboardingWhereInput
    orderBy?: UserOnboardingOrderByWithAggregationInput | UserOnboardingOrderByWithAggregationInput[]
    by: UserOnboardingScalarFieldEnum[] | UserOnboardingScalarFieldEnum
    having?: UserOnboardingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOnboardingCountAggregateInputType | true
    _avg?: UserOnboardingAvgAggregateInputType
    _sum?: UserOnboardingSumAggregateInputType
    _min?: UserOnboardingMinAggregateInputType
    _max?: UserOnboardingMaxAggregateInputType
  }

  export type UserOnboardingGroupByOutputType = {
    id: string
    userId: string
    completedAt: Date | null
    skipped: boolean
    primaryGoal: string | null
    experienceLevel: string | null
    toeTouchScore: number | null
    shoulderReachScore: number | null
    hipFlexibilityScore: number | null
    overallFlexibilityScore: number | null
    flexibilityLevel: string | null
    workoutDays: string | null
    preferredWorkoutTime: string | null
    stretchingPreference: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserOnboardingCountAggregateOutputType | null
    _avg: UserOnboardingAvgAggregateOutputType | null
    _sum: UserOnboardingSumAggregateOutputType | null
    _min: UserOnboardingMinAggregateOutputType | null
    _max: UserOnboardingMaxAggregateOutputType | null
  }

  type GetUserOnboardingGroupByPayload<T extends UserOnboardingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOnboardingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOnboardingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOnboardingGroupByOutputType[P]>
            : GetScalarType<T[P], UserOnboardingGroupByOutputType[P]>
        }
      >
    >


  export type UserOnboardingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    completedAt?: boolean
    skipped?: boolean
    primaryGoal?: boolean
    experienceLevel?: boolean
    toeTouchScore?: boolean
    shoulderReachScore?: boolean
    hipFlexibilityScore?: boolean
    overallFlexibilityScore?: boolean
    flexibilityLevel?: boolean
    workoutDays?: boolean
    preferredWorkoutTime?: boolean
    stretchingPreference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOnboarding"]>

  export type UserOnboardingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    completedAt?: boolean
    skipped?: boolean
    primaryGoal?: boolean
    experienceLevel?: boolean
    toeTouchScore?: boolean
    shoulderReachScore?: boolean
    hipFlexibilityScore?: boolean
    overallFlexibilityScore?: boolean
    flexibilityLevel?: boolean
    workoutDays?: boolean
    preferredWorkoutTime?: boolean
    stretchingPreference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOnboarding"]>

  export type UserOnboardingSelectScalar = {
    id?: boolean
    userId?: boolean
    completedAt?: boolean
    skipped?: boolean
    primaryGoal?: boolean
    experienceLevel?: boolean
    toeTouchScore?: boolean
    shoulderReachScore?: boolean
    hipFlexibilityScore?: boolean
    overallFlexibilityScore?: boolean
    flexibilityLevel?: boolean
    workoutDays?: boolean
    preferredWorkoutTime?: boolean
    stretchingPreference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOnboardingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserOnboardingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserOnboardingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserOnboarding"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      completedAt: Date | null
      skipped: boolean
      primaryGoal: string | null
      experienceLevel: string | null
      toeTouchScore: number | null
      shoulderReachScore: number | null
      hipFlexibilityScore: number | null
      overallFlexibilityScore: number | null
      flexibilityLevel: string | null
      workoutDays: string | null
      preferredWorkoutTime: string | null
      stretchingPreference: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userOnboarding"]>
    composites: {}
  }

  type UserOnboardingGetPayload<S extends boolean | null | undefined | UserOnboardingDefaultArgs> = $Result.GetResult<Prisma.$UserOnboardingPayload, S>

  type UserOnboardingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserOnboardingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserOnboardingCountAggregateInputType | true
    }

  export interface UserOnboardingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserOnboarding'], meta: { name: 'UserOnboarding' } }
    /**
     * Find zero or one UserOnboarding that matches the filter.
     * @param {UserOnboardingFindUniqueArgs} args - Arguments to find a UserOnboarding
     * @example
     * // Get one UserOnboarding
     * const userOnboarding = await prisma.userOnboarding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserOnboardingFindUniqueArgs>(args: SelectSubset<T, UserOnboardingFindUniqueArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserOnboarding that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserOnboardingFindUniqueOrThrowArgs} args - Arguments to find a UserOnboarding
     * @example
     * // Get one UserOnboarding
     * const userOnboarding = await prisma.userOnboarding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserOnboardingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserOnboardingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserOnboarding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingFindFirstArgs} args - Arguments to find a UserOnboarding
     * @example
     * // Get one UserOnboarding
     * const userOnboarding = await prisma.userOnboarding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserOnboardingFindFirstArgs>(args?: SelectSubset<T, UserOnboardingFindFirstArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserOnboarding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingFindFirstOrThrowArgs} args - Arguments to find a UserOnboarding
     * @example
     * // Get one UserOnboarding
     * const userOnboarding = await prisma.userOnboarding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserOnboardingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserOnboardingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserOnboardings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOnboardings
     * const userOnboardings = await prisma.userOnboarding.findMany()
     * 
     * // Get first 10 UserOnboardings
     * const userOnboardings = await prisma.userOnboarding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userOnboardingWithIdOnly = await prisma.userOnboarding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserOnboardingFindManyArgs>(args?: SelectSubset<T, UserOnboardingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserOnboarding.
     * @param {UserOnboardingCreateArgs} args - Arguments to create a UserOnboarding.
     * @example
     * // Create one UserOnboarding
     * const UserOnboarding = await prisma.userOnboarding.create({
     *   data: {
     *     // ... data to create a UserOnboarding
     *   }
     * })
     * 
     */
    create<T extends UserOnboardingCreateArgs>(args: SelectSubset<T, UserOnboardingCreateArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserOnboardings.
     * @param {UserOnboardingCreateManyArgs} args - Arguments to create many UserOnboardings.
     * @example
     * // Create many UserOnboardings
     * const userOnboarding = await prisma.userOnboarding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserOnboardingCreateManyArgs>(args?: SelectSubset<T, UserOnboardingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserOnboardings and returns the data saved in the database.
     * @param {UserOnboardingCreateManyAndReturnArgs} args - Arguments to create many UserOnboardings.
     * @example
     * // Create many UserOnboardings
     * const userOnboarding = await prisma.userOnboarding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserOnboardings and only return the `id`
     * const userOnboardingWithIdOnly = await prisma.userOnboarding.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserOnboardingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserOnboardingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserOnboarding.
     * @param {UserOnboardingDeleteArgs} args - Arguments to delete one UserOnboarding.
     * @example
     * // Delete one UserOnboarding
     * const UserOnboarding = await prisma.userOnboarding.delete({
     *   where: {
     *     // ... filter to delete one UserOnboarding
     *   }
     * })
     * 
     */
    delete<T extends UserOnboardingDeleteArgs>(args: SelectSubset<T, UserOnboardingDeleteArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserOnboarding.
     * @param {UserOnboardingUpdateArgs} args - Arguments to update one UserOnboarding.
     * @example
     * // Update one UserOnboarding
     * const userOnboarding = await prisma.userOnboarding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserOnboardingUpdateArgs>(args: SelectSubset<T, UserOnboardingUpdateArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserOnboardings.
     * @param {UserOnboardingDeleteManyArgs} args - Arguments to filter UserOnboardings to delete.
     * @example
     * // Delete a few UserOnboardings
     * const { count } = await prisma.userOnboarding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserOnboardingDeleteManyArgs>(args?: SelectSubset<T, UserOnboardingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOnboardings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOnboardings
     * const userOnboarding = await prisma.userOnboarding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserOnboardingUpdateManyArgs>(args: SelectSubset<T, UserOnboardingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserOnboarding.
     * @param {UserOnboardingUpsertArgs} args - Arguments to update or create a UserOnboarding.
     * @example
     * // Update or create a UserOnboarding
     * const userOnboarding = await prisma.userOnboarding.upsert({
     *   create: {
     *     // ... data to create a UserOnboarding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOnboarding we want to update
     *   }
     * })
     */
    upsert<T extends UserOnboardingUpsertArgs>(args: SelectSubset<T, UserOnboardingUpsertArgs<ExtArgs>>): Prisma__UserOnboardingClient<$Result.GetResult<Prisma.$UserOnboardingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserOnboardings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingCountArgs} args - Arguments to filter UserOnboardings to count.
     * @example
     * // Count the number of UserOnboardings
     * const count = await prisma.userOnboarding.count({
     *   where: {
     *     // ... the filter for the UserOnboardings we want to count
     *   }
     * })
    **/
    count<T extends UserOnboardingCountArgs>(
      args?: Subset<T, UserOnboardingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOnboardingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOnboarding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOnboardingAggregateArgs>(args: Subset<T, UserOnboardingAggregateArgs>): Prisma.PrismaPromise<GetUserOnboardingAggregateType<T>>

    /**
     * Group by UserOnboarding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOnboardingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserOnboardingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserOnboardingGroupByArgs['orderBy'] }
        : { orderBy?: UserOnboardingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserOnboardingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOnboardingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserOnboarding model
   */
  readonly fields: UserOnboardingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserOnboarding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserOnboardingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserOnboarding model
   */ 
  interface UserOnboardingFieldRefs {
    readonly id: FieldRef<"UserOnboarding", 'String'>
    readonly userId: FieldRef<"UserOnboarding", 'String'>
    readonly completedAt: FieldRef<"UserOnboarding", 'DateTime'>
    readonly skipped: FieldRef<"UserOnboarding", 'Boolean'>
    readonly primaryGoal: FieldRef<"UserOnboarding", 'String'>
    readonly experienceLevel: FieldRef<"UserOnboarding", 'String'>
    readonly toeTouchScore: FieldRef<"UserOnboarding", 'Int'>
    readonly shoulderReachScore: FieldRef<"UserOnboarding", 'Int'>
    readonly hipFlexibilityScore: FieldRef<"UserOnboarding", 'Int'>
    readonly overallFlexibilityScore: FieldRef<"UserOnboarding", 'Int'>
    readonly flexibilityLevel: FieldRef<"UserOnboarding", 'String'>
    readonly workoutDays: FieldRef<"UserOnboarding", 'String'>
    readonly preferredWorkoutTime: FieldRef<"UserOnboarding", 'String'>
    readonly stretchingPreference: FieldRef<"UserOnboarding", 'String'>
    readonly createdAt: FieldRef<"UserOnboarding", 'DateTime'>
    readonly updatedAt: FieldRef<"UserOnboarding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserOnboarding findUnique
   */
  export type UserOnboardingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * Filter, which UserOnboarding to fetch.
     */
    where: UserOnboardingWhereUniqueInput
  }

  /**
   * UserOnboarding findUniqueOrThrow
   */
  export type UserOnboardingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * Filter, which UserOnboarding to fetch.
     */
    where: UserOnboardingWhereUniqueInput
  }

  /**
   * UserOnboarding findFirst
   */
  export type UserOnboardingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * Filter, which UserOnboarding to fetch.
     */
    where?: UserOnboardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOnboardings to fetch.
     */
    orderBy?: UserOnboardingOrderByWithRelationInput | UserOnboardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOnboardings.
     */
    cursor?: UserOnboardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOnboardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOnboardings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOnboardings.
     */
    distinct?: UserOnboardingScalarFieldEnum | UserOnboardingScalarFieldEnum[]
  }

  /**
   * UserOnboarding findFirstOrThrow
   */
  export type UserOnboardingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * Filter, which UserOnboarding to fetch.
     */
    where?: UserOnboardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOnboardings to fetch.
     */
    orderBy?: UserOnboardingOrderByWithRelationInput | UserOnboardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOnboardings.
     */
    cursor?: UserOnboardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOnboardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOnboardings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOnboardings.
     */
    distinct?: UserOnboardingScalarFieldEnum | UserOnboardingScalarFieldEnum[]
  }

  /**
   * UserOnboarding findMany
   */
  export type UserOnboardingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * Filter, which UserOnboardings to fetch.
     */
    where?: UserOnboardingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOnboardings to fetch.
     */
    orderBy?: UserOnboardingOrderByWithRelationInput | UserOnboardingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserOnboardings.
     */
    cursor?: UserOnboardingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOnboardings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOnboardings.
     */
    skip?: number
    distinct?: UserOnboardingScalarFieldEnum | UserOnboardingScalarFieldEnum[]
  }

  /**
   * UserOnboarding create
   */
  export type UserOnboardingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserOnboarding.
     */
    data: XOR<UserOnboardingCreateInput, UserOnboardingUncheckedCreateInput>
  }

  /**
   * UserOnboarding createMany
   */
  export type UserOnboardingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserOnboardings.
     */
    data: UserOnboardingCreateManyInput | UserOnboardingCreateManyInput[]
  }

  /**
   * UserOnboarding createManyAndReturn
   */
  export type UserOnboardingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserOnboardings.
     */
    data: UserOnboardingCreateManyInput | UserOnboardingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserOnboarding update
   */
  export type UserOnboardingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserOnboarding.
     */
    data: XOR<UserOnboardingUpdateInput, UserOnboardingUncheckedUpdateInput>
    /**
     * Choose, which UserOnboarding to update.
     */
    where: UserOnboardingWhereUniqueInput
  }

  /**
   * UserOnboarding updateMany
   */
  export type UserOnboardingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserOnboardings.
     */
    data: XOR<UserOnboardingUpdateManyMutationInput, UserOnboardingUncheckedUpdateManyInput>
    /**
     * Filter which UserOnboardings to update
     */
    where?: UserOnboardingWhereInput
  }

  /**
   * UserOnboarding upsert
   */
  export type UserOnboardingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserOnboarding to update in case it exists.
     */
    where: UserOnboardingWhereUniqueInput
    /**
     * In case the UserOnboarding found by the `where` argument doesn't exist, create a new UserOnboarding with this data.
     */
    create: XOR<UserOnboardingCreateInput, UserOnboardingUncheckedCreateInput>
    /**
     * In case the UserOnboarding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserOnboardingUpdateInput, UserOnboardingUncheckedUpdateInput>
  }

  /**
   * UserOnboarding delete
   */
  export type UserOnboardingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
    /**
     * Filter which UserOnboarding to delete.
     */
    where: UserOnboardingWhereUniqueInput
  }

  /**
   * UserOnboarding deleteMany
   */
  export type UserOnboardingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOnboardings to delete
     */
    where?: UserOnboardingWhereInput
  }

  /**
   * UserOnboarding without action
   */
  export type UserOnboardingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOnboarding
     */
    select?: UserOnboardingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOnboardingInclude<ExtArgs> | null
  }


  /**
   * Model UserFollow
   */

  export type AggregateUserFollow = {
    _count: UserFollowCountAggregateOutputType | null
    _min: UserFollowMinAggregateOutputType | null
    _max: UserFollowMaxAggregateOutputType | null
  }

  export type UserFollowMinAggregateOutputType = {
    id: string | null
    userId: string | null
    followingUserId: string | null
    createdAt: Date | null
  }

  export type UserFollowMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    followingUserId: string | null
    createdAt: Date | null
  }

  export type UserFollowCountAggregateOutputType = {
    id: number
    userId: number
    followingUserId: number
    createdAt: number
    _all: number
  }


  export type UserFollowMinAggregateInputType = {
    id?: true
    userId?: true
    followingUserId?: true
    createdAt?: true
  }

  export type UserFollowMaxAggregateInputType = {
    id?: true
    userId?: true
    followingUserId?: true
    createdAt?: true
  }

  export type UserFollowCountAggregateInputType = {
    id?: true
    userId?: true
    followingUserId?: true
    createdAt?: true
    _all?: true
  }

  export type UserFollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFollow to aggregate.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFollows
    **/
    _count?: true | UserFollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFollowMaxAggregateInputType
  }

  export type GetUserFollowAggregateType<T extends UserFollowAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFollow[P]>
      : GetScalarType<T[P], AggregateUserFollow[P]>
  }




  export type UserFollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowWhereInput
    orderBy?: UserFollowOrderByWithAggregationInput | UserFollowOrderByWithAggregationInput[]
    by: UserFollowScalarFieldEnum[] | UserFollowScalarFieldEnum
    having?: UserFollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFollowCountAggregateInputType | true
    _min?: UserFollowMinAggregateInputType
    _max?: UserFollowMaxAggregateInputType
  }

  export type UserFollowGroupByOutputType = {
    id: string
    userId: string
    followingUserId: string
    createdAt: Date
    _count: UserFollowCountAggregateOutputType | null
    _min: UserFollowMinAggregateOutputType | null
    _max: UserFollowMaxAggregateOutputType | null
  }

  type GetUserFollowGroupByPayload<T extends UserFollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFollowGroupByOutputType[P]>
            : GetScalarType<T[P], UserFollowGroupByOutputType[P]>
        }
      >
    >


  export type UserFollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    followingUserId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFollow"]>

  export type UserFollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    followingUserId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFollow"]>

  export type UserFollowSelectScalar = {
    id?: boolean
    userId?: boolean
    followingUserId?: boolean
    createdAt?: boolean
  }

  export type UserFollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFollow"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      followingUserId: string
      createdAt: Date
    }, ExtArgs["result"]["userFollow"]>
    composites: {}
  }

  type UserFollowGetPayload<S extends boolean | null | undefined | UserFollowDefaultArgs> = $Result.GetResult<Prisma.$UserFollowPayload, S>

  type UserFollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFollowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserFollowCountAggregateInputType | true
    }

  export interface UserFollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFollow'], meta: { name: 'UserFollow' } }
    /**
     * Find zero or one UserFollow that matches the filter.
     * @param {UserFollowFindUniqueArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFollowFindUniqueArgs>(args: SelectSubset<T, UserFollowFindUniqueArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserFollow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFollowFindUniqueOrThrowArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFollowFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserFollow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowFindFirstArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFollowFindFirstArgs>(args?: SelectSubset<T, UserFollowFindFirstArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserFollow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowFindFirstOrThrowArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFollowFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFollows
     * const userFollows = await prisma.userFollow.findMany()
     * 
     * // Get first 10 UserFollows
     * const userFollows = await prisma.userFollow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFollowWithIdOnly = await prisma.userFollow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFollowFindManyArgs>(args?: SelectSubset<T, UserFollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserFollow.
     * @param {UserFollowCreateArgs} args - Arguments to create a UserFollow.
     * @example
     * // Create one UserFollow
     * const UserFollow = await prisma.userFollow.create({
     *   data: {
     *     // ... data to create a UserFollow
     *   }
     * })
     * 
     */
    create<T extends UserFollowCreateArgs>(args: SelectSubset<T, UserFollowCreateArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserFollows.
     * @param {UserFollowCreateManyArgs} args - Arguments to create many UserFollows.
     * @example
     * // Create many UserFollows
     * const userFollow = await prisma.userFollow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFollowCreateManyArgs>(args?: SelectSubset<T, UserFollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFollows and returns the data saved in the database.
     * @param {UserFollowCreateManyAndReturnArgs} args - Arguments to create many UserFollows.
     * @example
     * // Create many UserFollows
     * const userFollow = await prisma.userFollow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFollows and only return the `id`
     * const userFollowWithIdOnly = await prisma.userFollow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFollowCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserFollow.
     * @param {UserFollowDeleteArgs} args - Arguments to delete one UserFollow.
     * @example
     * // Delete one UserFollow
     * const UserFollow = await prisma.userFollow.delete({
     *   where: {
     *     // ... filter to delete one UserFollow
     *   }
     * })
     * 
     */
    delete<T extends UserFollowDeleteArgs>(args: SelectSubset<T, UserFollowDeleteArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserFollow.
     * @param {UserFollowUpdateArgs} args - Arguments to update one UserFollow.
     * @example
     * // Update one UserFollow
     * const userFollow = await prisma.userFollow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFollowUpdateArgs>(args: SelectSubset<T, UserFollowUpdateArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserFollows.
     * @param {UserFollowDeleteManyArgs} args - Arguments to filter UserFollows to delete.
     * @example
     * // Delete a few UserFollows
     * const { count } = await prisma.userFollow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFollowDeleteManyArgs>(args?: SelectSubset<T, UserFollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFollows
     * const userFollow = await prisma.userFollow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFollowUpdateManyArgs>(args: SelectSubset<T, UserFollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserFollow.
     * @param {UserFollowUpsertArgs} args - Arguments to update or create a UserFollow.
     * @example
     * // Update or create a UserFollow
     * const userFollow = await prisma.userFollow.upsert({
     *   create: {
     *     // ... data to create a UserFollow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFollow we want to update
     *   }
     * })
     */
    upsert<T extends UserFollowUpsertArgs>(args: SelectSubset<T, UserFollowUpsertArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowCountArgs} args - Arguments to filter UserFollows to count.
     * @example
     * // Count the number of UserFollows
     * const count = await prisma.userFollow.count({
     *   where: {
     *     // ... the filter for the UserFollows we want to count
     *   }
     * })
    **/
    count<T extends UserFollowCountArgs>(
      args?: Subset<T, UserFollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFollowAggregateArgs>(args: Subset<T, UserFollowAggregateArgs>): Prisma.PrismaPromise<GetUserFollowAggregateType<T>>

    /**
     * Group by UserFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFollowGroupByArgs['orderBy'] }
        : { orderBy?: UserFollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFollow model
   */
  readonly fields: UserFollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFollow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFollow model
   */ 
  interface UserFollowFieldRefs {
    readonly id: FieldRef<"UserFollow", 'String'>
    readonly userId: FieldRef<"UserFollow", 'String'>
    readonly followingUserId: FieldRef<"UserFollow", 'String'>
    readonly createdAt: FieldRef<"UserFollow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFollow findUnique
   */
  export type UserFollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow findUniqueOrThrow
   */
  export type UserFollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow findFirst
   */
  export type UserFollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFollows.
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFollows.
     */
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * UserFollow findFirstOrThrow
   */
  export type UserFollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFollows.
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFollows.
     */
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * UserFollow findMany
   */
  export type UserFollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollows to fetch.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFollows.
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * UserFollow create
   */
  export type UserFollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFollow.
     */
    data: XOR<UserFollowCreateInput, UserFollowUncheckedCreateInput>
  }

  /**
   * UserFollow createMany
   */
  export type UserFollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFollows.
     */
    data: UserFollowCreateManyInput | UserFollowCreateManyInput[]
  }

  /**
   * UserFollow createManyAndReturn
   */
  export type UserFollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserFollows.
     */
    data: UserFollowCreateManyInput | UserFollowCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFollow update
   */
  export type UserFollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFollow.
     */
    data: XOR<UserFollowUpdateInput, UserFollowUncheckedUpdateInput>
    /**
     * Choose, which UserFollow to update.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow updateMany
   */
  export type UserFollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFollows.
     */
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyInput>
    /**
     * Filter which UserFollows to update
     */
    where?: UserFollowWhereInput
  }

  /**
   * UserFollow upsert
   */
  export type UserFollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFollow to update in case it exists.
     */
    where: UserFollowWhereUniqueInput
    /**
     * In case the UserFollow found by the `where` argument doesn't exist, create a new UserFollow with this data.
     */
    create: XOR<UserFollowCreateInput, UserFollowUncheckedCreateInput>
    /**
     * In case the UserFollow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFollowUpdateInput, UserFollowUncheckedUpdateInput>
  }

  /**
   * UserFollow delete
   */
  export type UserFollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter which UserFollow to delete.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow deleteMany
   */
  export type UserFollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFollows to delete
     */
    where?: UserFollowWhereInput
  }

  /**
   * UserFollow without action
   */
  export type UserFollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
  }


  /**
   * Model Stretch
   */

  export type AggregateStretch = {
    _count: StretchCountAggregateOutputType | null
    _avg: StretchAvgAggregateOutputType | null
    _sum: StretchSumAggregateOutputType | null
    _min: StretchMinAggregateOutputType | null
    _max: StretchMaxAggregateOutputType | null
  }

  export type StretchAvgAggregateOutputType = {
    durationSeconds: number | null
  }

  export type StretchSumAggregateOutputType = {
    durationSeconds: number | null
  }

  export type StretchMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    durationSeconds: number | null
    videoUrl: string | null
    thumbnailUrl: string | null
    animationUrl: string | null
    difficulty: string | null
    primaryMuscles: string | null
    secondaryMuscles: string | null
    instructions: string | null
    tips: string | null
    commonMistakes: string | null
    equipment: string | null
    tags: string | null
    createdAt: Date | null
  }

  export type StretchMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    durationSeconds: number | null
    videoUrl: string | null
    thumbnailUrl: string | null
    animationUrl: string | null
    difficulty: string | null
    primaryMuscles: string | null
    secondaryMuscles: string | null
    instructions: string | null
    tips: string | null
    commonMistakes: string | null
    equipment: string | null
    tags: string | null
    createdAt: Date | null
  }

  export type StretchCountAggregateOutputType = {
    id: number
    name: number
    description: number
    durationSeconds: number
    videoUrl: number
    thumbnailUrl: number
    animationUrl: number
    difficulty: number
    primaryMuscles: number
    secondaryMuscles: number
    instructions: number
    tips: number
    commonMistakes: number
    equipment: number
    tags: number
    createdAt: number
    _all: number
  }


  export type StretchAvgAggregateInputType = {
    durationSeconds?: true
  }

  export type StretchSumAggregateInputType = {
    durationSeconds?: true
  }

  export type StretchMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    durationSeconds?: true
    videoUrl?: true
    thumbnailUrl?: true
    animationUrl?: true
    difficulty?: true
    primaryMuscles?: true
    secondaryMuscles?: true
    instructions?: true
    tips?: true
    commonMistakes?: true
    equipment?: true
    tags?: true
    createdAt?: true
  }

  export type StretchMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    durationSeconds?: true
    videoUrl?: true
    thumbnailUrl?: true
    animationUrl?: true
    difficulty?: true
    primaryMuscles?: true
    secondaryMuscles?: true
    instructions?: true
    tips?: true
    commonMistakes?: true
    equipment?: true
    tags?: true
    createdAt?: true
  }

  export type StretchCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    durationSeconds?: true
    videoUrl?: true
    thumbnailUrl?: true
    animationUrl?: true
    difficulty?: true
    primaryMuscles?: true
    secondaryMuscles?: true
    instructions?: true
    tips?: true
    commonMistakes?: true
    equipment?: true
    tags?: true
    createdAt?: true
    _all?: true
  }

  export type StretchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stretch to aggregate.
     */
    where?: StretchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stretches to fetch.
     */
    orderBy?: StretchOrderByWithRelationInput | StretchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StretchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stretches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stretches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stretches
    **/
    _count?: true | StretchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StretchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StretchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StretchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StretchMaxAggregateInputType
  }

  export type GetStretchAggregateType<T extends StretchAggregateArgs> = {
        [P in keyof T & keyof AggregateStretch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStretch[P]>
      : GetScalarType<T[P], AggregateStretch[P]>
  }




  export type StretchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StretchWhereInput
    orderBy?: StretchOrderByWithAggregationInput | StretchOrderByWithAggregationInput[]
    by: StretchScalarFieldEnum[] | StretchScalarFieldEnum
    having?: StretchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StretchCountAggregateInputType | true
    _avg?: StretchAvgAggregateInputType
    _sum?: StretchSumAggregateInputType
    _min?: StretchMinAggregateInputType
    _max?: StretchMaxAggregateInputType
  }

  export type StretchGroupByOutputType = {
    id: string
    name: string
    description: string | null
    durationSeconds: number
    videoUrl: string | null
    thumbnailUrl: string | null
    animationUrl: string | null
    difficulty: string
    primaryMuscles: string
    secondaryMuscles: string | null
    instructions: string | null
    tips: string | null
    commonMistakes: string | null
    equipment: string | null
    tags: string | null
    createdAt: Date
    _count: StretchCountAggregateOutputType | null
    _avg: StretchAvgAggregateOutputType | null
    _sum: StretchSumAggregateOutputType | null
    _min: StretchMinAggregateOutputType | null
    _max: StretchMaxAggregateOutputType | null
  }

  type GetStretchGroupByPayload<T extends StretchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StretchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StretchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StretchGroupByOutputType[P]>
            : GetScalarType<T[P], StretchGroupByOutputType[P]>
        }
      >
    >


  export type StretchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    durationSeconds?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    animationUrl?: boolean
    difficulty?: boolean
    primaryMuscles?: boolean
    secondaryMuscles?: boolean
    instructions?: boolean
    tips?: boolean
    commonMistakes?: boolean
    equipment?: boolean
    tags?: boolean
    createdAt?: boolean
    routineStretches?: boolean | Stretch$routineStretchesArgs<ExtArgs>
    sessionStretches?: boolean | Stretch$sessionStretchesArgs<ExtArgs>
    _count?: boolean | StretchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stretch"]>

  export type StretchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    durationSeconds?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    animationUrl?: boolean
    difficulty?: boolean
    primaryMuscles?: boolean
    secondaryMuscles?: boolean
    instructions?: boolean
    tips?: boolean
    commonMistakes?: boolean
    equipment?: boolean
    tags?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["stretch"]>

  export type StretchSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    durationSeconds?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    animationUrl?: boolean
    difficulty?: boolean
    primaryMuscles?: boolean
    secondaryMuscles?: boolean
    instructions?: boolean
    tips?: boolean
    commonMistakes?: boolean
    equipment?: boolean
    tags?: boolean
    createdAt?: boolean
  }

  export type StretchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routineStretches?: boolean | Stretch$routineStretchesArgs<ExtArgs>
    sessionStretches?: boolean | Stretch$sessionStretchesArgs<ExtArgs>
    _count?: boolean | StretchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StretchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StretchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stretch"
    objects: {
      routineStretches: Prisma.$RoutineStretchPayload<ExtArgs>[]
      sessionStretches: Prisma.$SessionStretchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      durationSeconds: number
      videoUrl: string | null
      thumbnailUrl: string | null
      animationUrl: string | null
      difficulty: string
      primaryMuscles: string
      secondaryMuscles: string | null
      instructions: string | null
      tips: string | null
      commonMistakes: string | null
      equipment: string | null
      tags: string | null
      createdAt: Date
    }, ExtArgs["result"]["stretch"]>
    composites: {}
  }

  type StretchGetPayload<S extends boolean | null | undefined | StretchDefaultArgs> = $Result.GetResult<Prisma.$StretchPayload, S>

  type StretchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StretchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StretchCountAggregateInputType | true
    }

  export interface StretchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stretch'], meta: { name: 'Stretch' } }
    /**
     * Find zero or one Stretch that matches the filter.
     * @param {StretchFindUniqueArgs} args - Arguments to find a Stretch
     * @example
     * // Get one Stretch
     * const stretch = await prisma.stretch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StretchFindUniqueArgs>(args: SelectSubset<T, StretchFindUniqueArgs<ExtArgs>>): Prisma__StretchClient<$Result.GetResult<Prisma.$StretchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Stretch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StretchFindUniqueOrThrowArgs} args - Arguments to find a Stretch
     * @example
     * // Get one Stretch
     * const stretch = await prisma.stretch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StretchFindUniqueOrThrowArgs>(args: SelectSubset<T, StretchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StretchClient<$Result.GetResult<Prisma.$StretchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Stretch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchFindFirstArgs} args - Arguments to find a Stretch
     * @example
     * // Get one Stretch
     * const stretch = await prisma.stretch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StretchFindFirstArgs>(args?: SelectSubset<T, StretchFindFirstArgs<ExtArgs>>): Prisma__StretchClient<$Result.GetResult<Prisma.$StretchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Stretch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchFindFirstOrThrowArgs} args - Arguments to find a Stretch
     * @example
     * // Get one Stretch
     * const stretch = await prisma.stretch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StretchFindFirstOrThrowArgs>(args?: SelectSubset<T, StretchFindFirstOrThrowArgs<ExtArgs>>): Prisma__StretchClient<$Result.GetResult<Prisma.$StretchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stretches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stretches
     * const stretches = await prisma.stretch.findMany()
     * 
     * // Get first 10 Stretches
     * const stretches = await prisma.stretch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stretchWithIdOnly = await prisma.stretch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StretchFindManyArgs>(args?: SelectSubset<T, StretchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StretchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Stretch.
     * @param {StretchCreateArgs} args - Arguments to create a Stretch.
     * @example
     * // Create one Stretch
     * const Stretch = await prisma.stretch.create({
     *   data: {
     *     // ... data to create a Stretch
     *   }
     * })
     * 
     */
    create<T extends StretchCreateArgs>(args: SelectSubset<T, StretchCreateArgs<ExtArgs>>): Prisma__StretchClient<$Result.GetResult<Prisma.$StretchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stretches.
     * @param {StretchCreateManyArgs} args - Arguments to create many Stretches.
     * @example
     * // Create many Stretches
     * const stretch = await prisma.stretch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StretchCreateManyArgs>(args?: SelectSubset<T, StretchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stretches and returns the data saved in the database.
     * @param {StretchCreateManyAndReturnArgs} args - Arguments to create many Stretches.
     * @example
     * // Create many Stretches
     * const stretch = await prisma.stretch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stretches and only return the `id`
     * const stretchWithIdOnly = await prisma.stretch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StretchCreateManyAndReturnArgs>(args?: SelectSubset<T, StretchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StretchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Stretch.
     * @param {StretchDeleteArgs} args - Arguments to delete one Stretch.
     * @example
     * // Delete one Stretch
     * const Stretch = await prisma.stretch.delete({
     *   where: {
     *     // ... filter to delete one Stretch
     *   }
     * })
     * 
     */
    delete<T extends StretchDeleteArgs>(args: SelectSubset<T, StretchDeleteArgs<ExtArgs>>): Prisma__StretchClient<$Result.GetResult<Prisma.$StretchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Stretch.
     * @param {StretchUpdateArgs} args - Arguments to update one Stretch.
     * @example
     * // Update one Stretch
     * const stretch = await prisma.stretch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StretchUpdateArgs>(args: SelectSubset<T, StretchUpdateArgs<ExtArgs>>): Prisma__StretchClient<$Result.GetResult<Prisma.$StretchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stretches.
     * @param {StretchDeleteManyArgs} args - Arguments to filter Stretches to delete.
     * @example
     * // Delete a few Stretches
     * const { count } = await prisma.stretch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StretchDeleteManyArgs>(args?: SelectSubset<T, StretchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stretches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stretches
     * const stretch = await prisma.stretch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StretchUpdateManyArgs>(args: SelectSubset<T, StretchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stretch.
     * @param {StretchUpsertArgs} args - Arguments to update or create a Stretch.
     * @example
     * // Update or create a Stretch
     * const stretch = await prisma.stretch.upsert({
     *   create: {
     *     // ... data to create a Stretch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stretch we want to update
     *   }
     * })
     */
    upsert<T extends StretchUpsertArgs>(args: SelectSubset<T, StretchUpsertArgs<ExtArgs>>): Prisma__StretchClient<$Result.GetResult<Prisma.$StretchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stretches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchCountArgs} args - Arguments to filter Stretches to count.
     * @example
     * // Count the number of Stretches
     * const count = await prisma.stretch.count({
     *   where: {
     *     // ... the filter for the Stretches we want to count
     *   }
     * })
    **/
    count<T extends StretchCountArgs>(
      args?: Subset<T, StretchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StretchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stretch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StretchAggregateArgs>(args: Subset<T, StretchAggregateArgs>): Prisma.PrismaPromise<GetStretchAggregateType<T>>

    /**
     * Group by Stretch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StretchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StretchGroupByArgs['orderBy'] }
        : { orderBy?: StretchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StretchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStretchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stretch model
   */
  readonly fields: StretchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stretch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StretchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    routineStretches<T extends Stretch$routineStretchesArgs<ExtArgs> = {}>(args?: Subset<T, Stretch$routineStretchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutineStretchPayload<ExtArgs>, T, "findMany"> | Null>
    sessionStretches<T extends Stretch$sessionStretchesArgs<ExtArgs> = {}>(args?: Subset<T, Stretch$sessionStretchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionStretchPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stretch model
   */ 
  interface StretchFieldRefs {
    readonly id: FieldRef<"Stretch", 'String'>
    readonly name: FieldRef<"Stretch", 'String'>
    readonly description: FieldRef<"Stretch", 'String'>
    readonly durationSeconds: FieldRef<"Stretch", 'Int'>
    readonly videoUrl: FieldRef<"Stretch", 'String'>
    readonly thumbnailUrl: FieldRef<"Stretch", 'String'>
    readonly animationUrl: FieldRef<"Stretch", 'String'>
    readonly difficulty: FieldRef<"Stretch", 'String'>
    readonly primaryMuscles: FieldRef<"Stretch", 'String'>
    readonly secondaryMuscles: FieldRef<"Stretch", 'String'>
    readonly instructions: FieldRef<"Stretch", 'String'>
    readonly tips: FieldRef<"Stretch", 'String'>
    readonly commonMistakes: FieldRef<"Stretch", 'String'>
    readonly equipment: FieldRef<"Stretch", 'String'>
    readonly tags: FieldRef<"Stretch", 'String'>
    readonly createdAt: FieldRef<"Stretch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stretch findUnique
   */
  export type StretchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stretch
     */
    select?: StretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchInclude<ExtArgs> | null
    /**
     * Filter, which Stretch to fetch.
     */
    where: StretchWhereUniqueInput
  }

  /**
   * Stretch findUniqueOrThrow
   */
  export type StretchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stretch
     */
    select?: StretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchInclude<ExtArgs> | null
    /**
     * Filter, which Stretch to fetch.
     */
    where: StretchWhereUniqueInput
  }

  /**
   * Stretch findFirst
   */
  export type StretchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stretch
     */
    select?: StretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchInclude<ExtArgs> | null
    /**
     * Filter, which Stretch to fetch.
     */
    where?: StretchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stretches to fetch.
     */
    orderBy?: StretchOrderByWithRelationInput | StretchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stretches.
     */
    cursor?: StretchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stretches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stretches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stretches.
     */
    distinct?: StretchScalarFieldEnum | StretchScalarFieldEnum[]
  }

  /**
   * Stretch findFirstOrThrow
   */
  export type StretchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stretch
     */
    select?: StretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchInclude<ExtArgs> | null
    /**
     * Filter, which Stretch to fetch.
     */
    where?: StretchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stretches to fetch.
     */
    orderBy?: StretchOrderByWithRelationInput | StretchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stretches.
     */
    cursor?: StretchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stretches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stretches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stretches.
     */
    distinct?: StretchScalarFieldEnum | StretchScalarFieldEnum[]
  }

  /**
   * Stretch findMany
   */
  export type StretchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stretch
     */
    select?: StretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchInclude<ExtArgs> | null
    /**
     * Filter, which Stretches to fetch.
     */
    where?: StretchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stretches to fetch.
     */
    orderBy?: StretchOrderByWithRelationInput | StretchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stretches.
     */
    cursor?: StretchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stretches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stretches.
     */
    skip?: number
    distinct?: StretchScalarFieldEnum | StretchScalarFieldEnum[]
  }

  /**
   * Stretch create
   */
  export type StretchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stretch
     */
    select?: StretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchInclude<ExtArgs> | null
    /**
     * The data needed to create a Stretch.
     */
    data: XOR<StretchCreateInput, StretchUncheckedCreateInput>
  }

  /**
   * Stretch createMany
   */
  export type StretchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stretches.
     */
    data: StretchCreateManyInput | StretchCreateManyInput[]
  }

  /**
   * Stretch createManyAndReturn
   */
  export type StretchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stretch
     */
    select?: StretchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Stretches.
     */
    data: StretchCreateManyInput | StretchCreateManyInput[]
  }

  /**
   * Stretch update
   */
  export type StretchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stretch
     */
    select?: StretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchInclude<ExtArgs> | null
    /**
     * The data needed to update a Stretch.
     */
    data: XOR<StretchUpdateInput, StretchUncheckedUpdateInput>
    /**
     * Choose, which Stretch to update.
     */
    where: StretchWhereUniqueInput
  }

  /**
   * Stretch updateMany
   */
  export type StretchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stretches.
     */
    data: XOR<StretchUpdateManyMutationInput, StretchUncheckedUpdateManyInput>
    /**
     * Filter which Stretches to update
     */
    where?: StretchWhereInput
  }

  /**
   * Stretch upsert
   */
  export type StretchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stretch
     */
    select?: StretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchInclude<ExtArgs> | null
    /**
     * The filter to search for the Stretch to update in case it exists.
     */
    where: StretchWhereUniqueInput
    /**
     * In case the Stretch found by the `where` argument doesn't exist, create a new Stretch with this data.
     */
    create: XOR<StretchCreateInput, StretchUncheckedCreateInput>
    /**
     * In case the Stretch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StretchUpdateInput, StretchUncheckedUpdateInput>
  }

  /**
   * Stretch delete
   */
  export type StretchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stretch
     */
    select?: StretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchInclude<ExtArgs> | null
    /**
     * Filter which Stretch to delete.
     */
    where: StretchWhereUniqueInput
  }

  /**
   * Stretch deleteMany
   */
  export type StretchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stretches to delete
     */
    where?: StretchWhereInput
  }

  /**
   * Stretch.routineStretches
   */
  export type Stretch$routineStretchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchInclude<ExtArgs> | null
    where?: RoutineStretchWhereInput
    orderBy?: RoutineStretchOrderByWithRelationInput | RoutineStretchOrderByWithRelationInput[]
    cursor?: RoutineStretchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoutineStretchScalarFieldEnum | RoutineStretchScalarFieldEnum[]
  }

  /**
   * Stretch.sessionStretches
   */
  export type Stretch$sessionStretchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchInclude<ExtArgs> | null
    where?: SessionStretchWhereInput
    orderBy?: SessionStretchOrderByWithRelationInput | SessionStretchOrderByWithRelationInput[]
    cursor?: SessionStretchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionStretchScalarFieldEnum | SessionStretchScalarFieldEnum[]
  }

  /**
   * Stretch without action
   */
  export type StretchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stretch
     */
    select?: StretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchInclude<ExtArgs> | null
  }


  /**
   * Model StretchingRoutine
   */

  export type AggregateStretchingRoutine = {
    _count: StretchingRoutineCountAggregateOutputType | null
    _avg: StretchingRoutineAvgAggregateOutputType | null
    _sum: StretchingRoutineSumAggregateOutputType | null
    _min: StretchingRoutineMinAggregateOutputType | null
    _max: StretchingRoutineMaxAggregateOutputType | null
  }

  export type StretchingRoutineAvgAggregateOutputType = {
    durationSeconds: number | null
    usesCount: number | null
  }

  export type StretchingRoutineSumAggregateOutputType = {
    durationSeconds: number | null
    usesCount: number | null
  }

  export type StretchingRoutineMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    difficulty: string | null
    durationSeconds: number | null
    targetAreas: string | null
    tags: string | null
    isPublic: boolean | null
    isSystem: boolean | null
    usesCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StretchingRoutineMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    difficulty: string | null
    durationSeconds: number | null
    targetAreas: string | null
    tags: string | null
    isPublic: boolean | null
    isSystem: boolean | null
    usesCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StretchingRoutineCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    difficulty: number
    durationSeconds: number
    targetAreas: number
    tags: number
    isPublic: number
    isSystem: number
    usesCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StretchingRoutineAvgAggregateInputType = {
    durationSeconds?: true
    usesCount?: true
  }

  export type StretchingRoutineSumAggregateInputType = {
    durationSeconds?: true
    usesCount?: true
  }

  export type StretchingRoutineMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    difficulty?: true
    durationSeconds?: true
    targetAreas?: true
    tags?: true
    isPublic?: true
    isSystem?: true
    usesCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StretchingRoutineMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    difficulty?: true
    durationSeconds?: true
    targetAreas?: true
    tags?: true
    isPublic?: true
    isSystem?: true
    usesCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StretchingRoutineCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    difficulty?: true
    durationSeconds?: true
    targetAreas?: true
    tags?: true
    isPublic?: true
    isSystem?: true
    usesCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StretchingRoutineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StretchingRoutine to aggregate.
     */
    where?: StretchingRoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StretchingRoutines to fetch.
     */
    orderBy?: StretchingRoutineOrderByWithRelationInput | StretchingRoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StretchingRoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StretchingRoutines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StretchingRoutines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StretchingRoutines
    **/
    _count?: true | StretchingRoutineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StretchingRoutineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StretchingRoutineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StretchingRoutineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StretchingRoutineMaxAggregateInputType
  }

  export type GetStretchingRoutineAggregateType<T extends StretchingRoutineAggregateArgs> = {
        [P in keyof T & keyof AggregateStretchingRoutine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStretchingRoutine[P]>
      : GetScalarType<T[P], AggregateStretchingRoutine[P]>
  }




  export type StretchingRoutineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StretchingRoutineWhereInput
    orderBy?: StretchingRoutineOrderByWithAggregationInput | StretchingRoutineOrderByWithAggregationInput[]
    by: StretchingRoutineScalarFieldEnum[] | StretchingRoutineScalarFieldEnum
    having?: StretchingRoutineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StretchingRoutineCountAggregateInputType | true
    _avg?: StretchingRoutineAvgAggregateInputType
    _sum?: StretchingRoutineSumAggregateInputType
    _min?: StretchingRoutineMinAggregateInputType
    _max?: StretchingRoutineMaxAggregateInputType
  }

  export type StretchingRoutineGroupByOutputType = {
    id: string
    userId: string | null
    name: string
    description: string | null
    difficulty: string
    durationSeconds: number
    targetAreas: string | null
    tags: string | null
    isPublic: boolean
    isSystem: boolean
    usesCount: number
    createdAt: Date
    updatedAt: Date
    _count: StretchingRoutineCountAggregateOutputType | null
    _avg: StretchingRoutineAvgAggregateOutputType | null
    _sum: StretchingRoutineSumAggregateOutputType | null
    _min: StretchingRoutineMinAggregateOutputType | null
    _max: StretchingRoutineMaxAggregateOutputType | null
  }

  type GetStretchingRoutineGroupByPayload<T extends StretchingRoutineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StretchingRoutineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StretchingRoutineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StretchingRoutineGroupByOutputType[P]>
            : GetScalarType<T[P], StretchingRoutineGroupByOutputType[P]>
        }
      >
    >


  export type StretchingRoutineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    difficulty?: boolean
    durationSeconds?: boolean
    targetAreas?: boolean
    tags?: boolean
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | StretchingRoutine$userArgs<ExtArgs>
    stretches?: boolean | StretchingRoutine$stretchesArgs<ExtArgs>
    sessions?: boolean | StretchingRoutine$sessionsArgs<ExtArgs>
    _count?: boolean | StretchingRoutineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stretchingRoutine"]>

  export type StretchingRoutineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    difficulty?: boolean
    durationSeconds?: boolean
    targetAreas?: boolean
    tags?: boolean
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | StretchingRoutine$userArgs<ExtArgs>
  }, ExtArgs["result"]["stretchingRoutine"]>

  export type StretchingRoutineSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    difficulty?: boolean
    durationSeconds?: boolean
    targetAreas?: boolean
    tags?: boolean
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StretchingRoutineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | StretchingRoutine$userArgs<ExtArgs>
    stretches?: boolean | StretchingRoutine$stretchesArgs<ExtArgs>
    sessions?: boolean | StretchingRoutine$sessionsArgs<ExtArgs>
    _count?: boolean | StretchingRoutineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StretchingRoutineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | StretchingRoutine$userArgs<ExtArgs>
  }

  export type $StretchingRoutinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StretchingRoutine"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      stretches: Prisma.$RoutineStretchPayload<ExtArgs>[]
      sessions: Prisma.$StretchingSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      name: string
      description: string | null
      difficulty: string
      durationSeconds: number
      targetAreas: string | null
      tags: string | null
      isPublic: boolean
      isSystem: boolean
      usesCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stretchingRoutine"]>
    composites: {}
  }

  type StretchingRoutineGetPayload<S extends boolean | null | undefined | StretchingRoutineDefaultArgs> = $Result.GetResult<Prisma.$StretchingRoutinePayload, S>

  type StretchingRoutineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StretchingRoutineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StretchingRoutineCountAggregateInputType | true
    }

  export interface StretchingRoutineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StretchingRoutine'], meta: { name: 'StretchingRoutine' } }
    /**
     * Find zero or one StretchingRoutine that matches the filter.
     * @param {StretchingRoutineFindUniqueArgs} args - Arguments to find a StretchingRoutine
     * @example
     * // Get one StretchingRoutine
     * const stretchingRoutine = await prisma.stretchingRoutine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StretchingRoutineFindUniqueArgs>(args: SelectSubset<T, StretchingRoutineFindUniqueArgs<ExtArgs>>): Prisma__StretchingRoutineClient<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StretchingRoutine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StretchingRoutineFindUniqueOrThrowArgs} args - Arguments to find a StretchingRoutine
     * @example
     * // Get one StretchingRoutine
     * const stretchingRoutine = await prisma.stretchingRoutine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StretchingRoutineFindUniqueOrThrowArgs>(args: SelectSubset<T, StretchingRoutineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StretchingRoutineClient<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StretchingRoutine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingRoutineFindFirstArgs} args - Arguments to find a StretchingRoutine
     * @example
     * // Get one StretchingRoutine
     * const stretchingRoutine = await prisma.stretchingRoutine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StretchingRoutineFindFirstArgs>(args?: SelectSubset<T, StretchingRoutineFindFirstArgs<ExtArgs>>): Prisma__StretchingRoutineClient<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StretchingRoutine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingRoutineFindFirstOrThrowArgs} args - Arguments to find a StretchingRoutine
     * @example
     * // Get one StretchingRoutine
     * const stretchingRoutine = await prisma.stretchingRoutine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StretchingRoutineFindFirstOrThrowArgs>(args?: SelectSubset<T, StretchingRoutineFindFirstOrThrowArgs<ExtArgs>>): Prisma__StretchingRoutineClient<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StretchingRoutines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingRoutineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StretchingRoutines
     * const stretchingRoutines = await prisma.stretchingRoutine.findMany()
     * 
     * // Get first 10 StretchingRoutines
     * const stretchingRoutines = await prisma.stretchingRoutine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stretchingRoutineWithIdOnly = await prisma.stretchingRoutine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StretchingRoutineFindManyArgs>(args?: SelectSubset<T, StretchingRoutineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StretchingRoutine.
     * @param {StretchingRoutineCreateArgs} args - Arguments to create a StretchingRoutine.
     * @example
     * // Create one StretchingRoutine
     * const StretchingRoutine = await prisma.stretchingRoutine.create({
     *   data: {
     *     // ... data to create a StretchingRoutine
     *   }
     * })
     * 
     */
    create<T extends StretchingRoutineCreateArgs>(args: SelectSubset<T, StretchingRoutineCreateArgs<ExtArgs>>): Prisma__StretchingRoutineClient<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StretchingRoutines.
     * @param {StretchingRoutineCreateManyArgs} args - Arguments to create many StretchingRoutines.
     * @example
     * // Create many StretchingRoutines
     * const stretchingRoutine = await prisma.stretchingRoutine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StretchingRoutineCreateManyArgs>(args?: SelectSubset<T, StretchingRoutineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StretchingRoutines and returns the data saved in the database.
     * @param {StretchingRoutineCreateManyAndReturnArgs} args - Arguments to create many StretchingRoutines.
     * @example
     * // Create many StretchingRoutines
     * const stretchingRoutine = await prisma.stretchingRoutine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StretchingRoutines and only return the `id`
     * const stretchingRoutineWithIdOnly = await prisma.stretchingRoutine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StretchingRoutineCreateManyAndReturnArgs>(args?: SelectSubset<T, StretchingRoutineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StretchingRoutine.
     * @param {StretchingRoutineDeleteArgs} args - Arguments to delete one StretchingRoutine.
     * @example
     * // Delete one StretchingRoutine
     * const StretchingRoutine = await prisma.stretchingRoutine.delete({
     *   where: {
     *     // ... filter to delete one StretchingRoutine
     *   }
     * })
     * 
     */
    delete<T extends StretchingRoutineDeleteArgs>(args: SelectSubset<T, StretchingRoutineDeleteArgs<ExtArgs>>): Prisma__StretchingRoutineClient<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StretchingRoutine.
     * @param {StretchingRoutineUpdateArgs} args - Arguments to update one StretchingRoutine.
     * @example
     * // Update one StretchingRoutine
     * const stretchingRoutine = await prisma.stretchingRoutine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StretchingRoutineUpdateArgs>(args: SelectSubset<T, StretchingRoutineUpdateArgs<ExtArgs>>): Prisma__StretchingRoutineClient<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StretchingRoutines.
     * @param {StretchingRoutineDeleteManyArgs} args - Arguments to filter StretchingRoutines to delete.
     * @example
     * // Delete a few StretchingRoutines
     * const { count } = await prisma.stretchingRoutine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StretchingRoutineDeleteManyArgs>(args?: SelectSubset<T, StretchingRoutineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StretchingRoutines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingRoutineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StretchingRoutines
     * const stretchingRoutine = await prisma.stretchingRoutine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StretchingRoutineUpdateManyArgs>(args: SelectSubset<T, StretchingRoutineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StretchingRoutine.
     * @param {StretchingRoutineUpsertArgs} args - Arguments to update or create a StretchingRoutine.
     * @example
     * // Update or create a StretchingRoutine
     * const stretchingRoutine = await prisma.stretchingRoutine.upsert({
     *   create: {
     *     // ... data to create a StretchingRoutine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StretchingRoutine we want to update
     *   }
     * })
     */
    upsert<T extends StretchingRoutineUpsertArgs>(args: SelectSubset<T, StretchingRoutineUpsertArgs<ExtArgs>>): Prisma__StretchingRoutineClient<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StretchingRoutines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingRoutineCountArgs} args - Arguments to filter StretchingRoutines to count.
     * @example
     * // Count the number of StretchingRoutines
     * const count = await prisma.stretchingRoutine.count({
     *   where: {
     *     // ... the filter for the StretchingRoutines we want to count
     *   }
     * })
    **/
    count<T extends StretchingRoutineCountArgs>(
      args?: Subset<T, StretchingRoutineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StretchingRoutineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StretchingRoutine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingRoutineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StretchingRoutineAggregateArgs>(args: Subset<T, StretchingRoutineAggregateArgs>): Prisma.PrismaPromise<GetStretchingRoutineAggregateType<T>>

    /**
     * Group by StretchingRoutine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingRoutineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StretchingRoutineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StretchingRoutineGroupByArgs['orderBy'] }
        : { orderBy?: StretchingRoutineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StretchingRoutineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStretchingRoutineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StretchingRoutine model
   */
  readonly fields: StretchingRoutineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StretchingRoutine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StretchingRoutineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends StretchingRoutine$userArgs<ExtArgs> = {}>(args?: Subset<T, StretchingRoutine$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    stretches<T extends StretchingRoutine$stretchesArgs<ExtArgs> = {}>(args?: Subset<T, StretchingRoutine$stretchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutineStretchPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends StretchingRoutine$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, StretchingRoutine$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StretchingRoutine model
   */ 
  interface StretchingRoutineFieldRefs {
    readonly id: FieldRef<"StretchingRoutine", 'String'>
    readonly userId: FieldRef<"StretchingRoutine", 'String'>
    readonly name: FieldRef<"StretchingRoutine", 'String'>
    readonly description: FieldRef<"StretchingRoutine", 'String'>
    readonly difficulty: FieldRef<"StretchingRoutine", 'String'>
    readonly durationSeconds: FieldRef<"StretchingRoutine", 'Int'>
    readonly targetAreas: FieldRef<"StretchingRoutine", 'String'>
    readonly tags: FieldRef<"StretchingRoutine", 'String'>
    readonly isPublic: FieldRef<"StretchingRoutine", 'Boolean'>
    readonly isSystem: FieldRef<"StretchingRoutine", 'Boolean'>
    readonly usesCount: FieldRef<"StretchingRoutine", 'Int'>
    readonly createdAt: FieldRef<"StretchingRoutine", 'DateTime'>
    readonly updatedAt: FieldRef<"StretchingRoutine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StretchingRoutine findUnique
   */
  export type StretchingRoutineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineInclude<ExtArgs> | null
    /**
     * Filter, which StretchingRoutine to fetch.
     */
    where: StretchingRoutineWhereUniqueInput
  }

  /**
   * StretchingRoutine findUniqueOrThrow
   */
  export type StretchingRoutineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineInclude<ExtArgs> | null
    /**
     * Filter, which StretchingRoutine to fetch.
     */
    where: StretchingRoutineWhereUniqueInput
  }

  /**
   * StretchingRoutine findFirst
   */
  export type StretchingRoutineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineInclude<ExtArgs> | null
    /**
     * Filter, which StretchingRoutine to fetch.
     */
    where?: StretchingRoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StretchingRoutines to fetch.
     */
    orderBy?: StretchingRoutineOrderByWithRelationInput | StretchingRoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StretchingRoutines.
     */
    cursor?: StretchingRoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StretchingRoutines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StretchingRoutines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StretchingRoutines.
     */
    distinct?: StretchingRoutineScalarFieldEnum | StretchingRoutineScalarFieldEnum[]
  }

  /**
   * StretchingRoutine findFirstOrThrow
   */
  export type StretchingRoutineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineInclude<ExtArgs> | null
    /**
     * Filter, which StretchingRoutine to fetch.
     */
    where?: StretchingRoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StretchingRoutines to fetch.
     */
    orderBy?: StretchingRoutineOrderByWithRelationInput | StretchingRoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StretchingRoutines.
     */
    cursor?: StretchingRoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StretchingRoutines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StretchingRoutines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StretchingRoutines.
     */
    distinct?: StretchingRoutineScalarFieldEnum | StretchingRoutineScalarFieldEnum[]
  }

  /**
   * StretchingRoutine findMany
   */
  export type StretchingRoutineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineInclude<ExtArgs> | null
    /**
     * Filter, which StretchingRoutines to fetch.
     */
    where?: StretchingRoutineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StretchingRoutines to fetch.
     */
    orderBy?: StretchingRoutineOrderByWithRelationInput | StretchingRoutineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StretchingRoutines.
     */
    cursor?: StretchingRoutineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StretchingRoutines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StretchingRoutines.
     */
    skip?: number
    distinct?: StretchingRoutineScalarFieldEnum | StretchingRoutineScalarFieldEnum[]
  }

  /**
   * StretchingRoutine create
   */
  export type StretchingRoutineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineInclude<ExtArgs> | null
    /**
     * The data needed to create a StretchingRoutine.
     */
    data: XOR<StretchingRoutineCreateInput, StretchingRoutineUncheckedCreateInput>
  }

  /**
   * StretchingRoutine createMany
   */
  export type StretchingRoutineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StretchingRoutines.
     */
    data: StretchingRoutineCreateManyInput | StretchingRoutineCreateManyInput[]
  }

  /**
   * StretchingRoutine createManyAndReturn
   */
  export type StretchingRoutineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StretchingRoutines.
     */
    data: StretchingRoutineCreateManyInput | StretchingRoutineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StretchingRoutine update
   */
  export type StretchingRoutineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineInclude<ExtArgs> | null
    /**
     * The data needed to update a StretchingRoutine.
     */
    data: XOR<StretchingRoutineUpdateInput, StretchingRoutineUncheckedUpdateInput>
    /**
     * Choose, which StretchingRoutine to update.
     */
    where: StretchingRoutineWhereUniqueInput
  }

  /**
   * StretchingRoutine updateMany
   */
  export type StretchingRoutineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StretchingRoutines.
     */
    data: XOR<StretchingRoutineUpdateManyMutationInput, StretchingRoutineUncheckedUpdateManyInput>
    /**
     * Filter which StretchingRoutines to update
     */
    where?: StretchingRoutineWhereInput
  }

  /**
   * StretchingRoutine upsert
   */
  export type StretchingRoutineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineInclude<ExtArgs> | null
    /**
     * The filter to search for the StretchingRoutine to update in case it exists.
     */
    where: StretchingRoutineWhereUniqueInput
    /**
     * In case the StretchingRoutine found by the `where` argument doesn't exist, create a new StretchingRoutine with this data.
     */
    create: XOR<StretchingRoutineCreateInput, StretchingRoutineUncheckedCreateInput>
    /**
     * In case the StretchingRoutine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StretchingRoutineUpdateInput, StretchingRoutineUncheckedUpdateInput>
  }

  /**
   * StretchingRoutine delete
   */
  export type StretchingRoutineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineInclude<ExtArgs> | null
    /**
     * Filter which StretchingRoutine to delete.
     */
    where: StretchingRoutineWhereUniqueInput
  }

  /**
   * StretchingRoutine deleteMany
   */
  export type StretchingRoutineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StretchingRoutines to delete
     */
    where?: StretchingRoutineWhereInput
  }

  /**
   * StretchingRoutine.user
   */
  export type StretchingRoutine$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StretchingRoutine.stretches
   */
  export type StretchingRoutine$stretchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchInclude<ExtArgs> | null
    where?: RoutineStretchWhereInput
    orderBy?: RoutineStretchOrderByWithRelationInput | RoutineStretchOrderByWithRelationInput[]
    cursor?: RoutineStretchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoutineStretchScalarFieldEnum | RoutineStretchScalarFieldEnum[]
  }

  /**
   * StretchingRoutine.sessions
   */
  export type StretchingRoutine$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionInclude<ExtArgs> | null
    where?: StretchingSessionWhereInput
    orderBy?: StretchingSessionOrderByWithRelationInput | StretchingSessionOrderByWithRelationInput[]
    cursor?: StretchingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StretchingSessionScalarFieldEnum | StretchingSessionScalarFieldEnum[]
  }

  /**
   * StretchingRoutine without action
   */
  export type StretchingRoutineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineInclude<ExtArgs> | null
  }


  /**
   * Model RoutineStretch
   */

  export type AggregateRoutineStretch = {
    _count: RoutineStretchCountAggregateOutputType | null
    _avg: RoutineStretchAvgAggregateOutputType | null
    _sum: RoutineStretchSumAggregateOutputType | null
    _min: RoutineStretchMinAggregateOutputType | null
    _max: RoutineStretchMaxAggregateOutputType | null
  }

  export type RoutineStretchAvgAggregateOutputType = {
    positionOrder: number | null
    customDurationSeconds: number | null
  }

  export type RoutineStretchSumAggregateOutputType = {
    positionOrder: number | null
    customDurationSeconds: number | null
  }

  export type RoutineStretchMinAggregateOutputType = {
    id: string | null
    routineId: string | null
    stretchId: string | null
    positionOrder: number | null
    customDurationSeconds: number | null
  }

  export type RoutineStretchMaxAggregateOutputType = {
    id: string | null
    routineId: string | null
    stretchId: string | null
    positionOrder: number | null
    customDurationSeconds: number | null
  }

  export type RoutineStretchCountAggregateOutputType = {
    id: number
    routineId: number
    stretchId: number
    positionOrder: number
    customDurationSeconds: number
    _all: number
  }


  export type RoutineStretchAvgAggregateInputType = {
    positionOrder?: true
    customDurationSeconds?: true
  }

  export type RoutineStretchSumAggregateInputType = {
    positionOrder?: true
    customDurationSeconds?: true
  }

  export type RoutineStretchMinAggregateInputType = {
    id?: true
    routineId?: true
    stretchId?: true
    positionOrder?: true
    customDurationSeconds?: true
  }

  export type RoutineStretchMaxAggregateInputType = {
    id?: true
    routineId?: true
    stretchId?: true
    positionOrder?: true
    customDurationSeconds?: true
  }

  export type RoutineStretchCountAggregateInputType = {
    id?: true
    routineId?: true
    stretchId?: true
    positionOrder?: true
    customDurationSeconds?: true
    _all?: true
  }

  export type RoutineStretchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoutineStretch to aggregate.
     */
    where?: RoutineStretchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutineStretches to fetch.
     */
    orderBy?: RoutineStretchOrderByWithRelationInput | RoutineStretchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoutineStretchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutineStretches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutineStretches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoutineStretches
    **/
    _count?: true | RoutineStretchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoutineStretchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoutineStretchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoutineStretchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoutineStretchMaxAggregateInputType
  }

  export type GetRoutineStretchAggregateType<T extends RoutineStretchAggregateArgs> = {
        [P in keyof T & keyof AggregateRoutineStretch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoutineStretch[P]>
      : GetScalarType<T[P], AggregateRoutineStretch[P]>
  }




  export type RoutineStretchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutineStretchWhereInput
    orderBy?: RoutineStretchOrderByWithAggregationInput | RoutineStretchOrderByWithAggregationInput[]
    by: RoutineStretchScalarFieldEnum[] | RoutineStretchScalarFieldEnum
    having?: RoutineStretchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoutineStretchCountAggregateInputType | true
    _avg?: RoutineStretchAvgAggregateInputType
    _sum?: RoutineStretchSumAggregateInputType
    _min?: RoutineStretchMinAggregateInputType
    _max?: RoutineStretchMaxAggregateInputType
  }

  export type RoutineStretchGroupByOutputType = {
    id: string
    routineId: string
    stretchId: string
    positionOrder: number
    customDurationSeconds: number | null
    _count: RoutineStretchCountAggregateOutputType | null
    _avg: RoutineStretchAvgAggregateOutputType | null
    _sum: RoutineStretchSumAggregateOutputType | null
    _min: RoutineStretchMinAggregateOutputType | null
    _max: RoutineStretchMaxAggregateOutputType | null
  }

  type GetRoutineStretchGroupByPayload<T extends RoutineStretchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoutineStretchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoutineStretchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoutineStretchGroupByOutputType[P]>
            : GetScalarType<T[P], RoutineStretchGroupByOutputType[P]>
        }
      >
    >


  export type RoutineStretchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routineId?: boolean
    stretchId?: boolean
    positionOrder?: boolean
    customDurationSeconds?: boolean
    routine?: boolean | StretchingRoutineDefaultArgs<ExtArgs>
    stretch?: boolean | StretchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routineStretch"]>

  export type RoutineStretchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routineId?: boolean
    stretchId?: boolean
    positionOrder?: boolean
    customDurationSeconds?: boolean
    routine?: boolean | StretchingRoutineDefaultArgs<ExtArgs>
    stretch?: boolean | StretchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routineStretch"]>

  export type RoutineStretchSelectScalar = {
    id?: boolean
    routineId?: boolean
    stretchId?: boolean
    positionOrder?: boolean
    customDurationSeconds?: boolean
  }

  export type RoutineStretchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routine?: boolean | StretchingRoutineDefaultArgs<ExtArgs>
    stretch?: boolean | StretchDefaultArgs<ExtArgs>
  }
  export type RoutineStretchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routine?: boolean | StretchingRoutineDefaultArgs<ExtArgs>
    stretch?: boolean | StretchDefaultArgs<ExtArgs>
  }

  export type $RoutineStretchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoutineStretch"
    objects: {
      routine: Prisma.$StretchingRoutinePayload<ExtArgs>
      stretch: Prisma.$StretchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      routineId: string
      stretchId: string
      positionOrder: number
      customDurationSeconds: number | null
    }, ExtArgs["result"]["routineStretch"]>
    composites: {}
  }

  type RoutineStretchGetPayload<S extends boolean | null | undefined | RoutineStretchDefaultArgs> = $Result.GetResult<Prisma.$RoutineStretchPayload, S>

  type RoutineStretchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoutineStretchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoutineStretchCountAggregateInputType | true
    }

  export interface RoutineStretchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoutineStretch'], meta: { name: 'RoutineStretch' } }
    /**
     * Find zero or one RoutineStretch that matches the filter.
     * @param {RoutineStretchFindUniqueArgs} args - Arguments to find a RoutineStretch
     * @example
     * // Get one RoutineStretch
     * const routineStretch = await prisma.routineStretch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoutineStretchFindUniqueArgs>(args: SelectSubset<T, RoutineStretchFindUniqueArgs<ExtArgs>>): Prisma__RoutineStretchClient<$Result.GetResult<Prisma.$RoutineStretchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoutineStretch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoutineStretchFindUniqueOrThrowArgs} args - Arguments to find a RoutineStretch
     * @example
     * // Get one RoutineStretch
     * const routineStretch = await prisma.routineStretch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoutineStretchFindUniqueOrThrowArgs>(args: SelectSubset<T, RoutineStretchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoutineStretchClient<$Result.GetResult<Prisma.$RoutineStretchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoutineStretch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineStretchFindFirstArgs} args - Arguments to find a RoutineStretch
     * @example
     * // Get one RoutineStretch
     * const routineStretch = await prisma.routineStretch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoutineStretchFindFirstArgs>(args?: SelectSubset<T, RoutineStretchFindFirstArgs<ExtArgs>>): Prisma__RoutineStretchClient<$Result.GetResult<Prisma.$RoutineStretchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoutineStretch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineStretchFindFirstOrThrowArgs} args - Arguments to find a RoutineStretch
     * @example
     * // Get one RoutineStretch
     * const routineStretch = await prisma.routineStretch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoutineStretchFindFirstOrThrowArgs>(args?: SelectSubset<T, RoutineStretchFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoutineStretchClient<$Result.GetResult<Prisma.$RoutineStretchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoutineStretches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineStretchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoutineStretches
     * const routineStretches = await prisma.routineStretch.findMany()
     * 
     * // Get first 10 RoutineStretches
     * const routineStretches = await prisma.routineStretch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routineStretchWithIdOnly = await prisma.routineStretch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoutineStretchFindManyArgs>(args?: SelectSubset<T, RoutineStretchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutineStretchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoutineStretch.
     * @param {RoutineStretchCreateArgs} args - Arguments to create a RoutineStretch.
     * @example
     * // Create one RoutineStretch
     * const RoutineStretch = await prisma.routineStretch.create({
     *   data: {
     *     // ... data to create a RoutineStretch
     *   }
     * })
     * 
     */
    create<T extends RoutineStretchCreateArgs>(args: SelectSubset<T, RoutineStretchCreateArgs<ExtArgs>>): Prisma__RoutineStretchClient<$Result.GetResult<Prisma.$RoutineStretchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoutineStretches.
     * @param {RoutineStretchCreateManyArgs} args - Arguments to create many RoutineStretches.
     * @example
     * // Create many RoutineStretches
     * const routineStretch = await prisma.routineStretch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoutineStretchCreateManyArgs>(args?: SelectSubset<T, RoutineStretchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoutineStretches and returns the data saved in the database.
     * @param {RoutineStretchCreateManyAndReturnArgs} args - Arguments to create many RoutineStretches.
     * @example
     * // Create many RoutineStretches
     * const routineStretch = await prisma.routineStretch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoutineStretches and only return the `id`
     * const routineStretchWithIdOnly = await prisma.routineStretch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoutineStretchCreateManyAndReturnArgs>(args?: SelectSubset<T, RoutineStretchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutineStretchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoutineStretch.
     * @param {RoutineStretchDeleteArgs} args - Arguments to delete one RoutineStretch.
     * @example
     * // Delete one RoutineStretch
     * const RoutineStretch = await prisma.routineStretch.delete({
     *   where: {
     *     // ... filter to delete one RoutineStretch
     *   }
     * })
     * 
     */
    delete<T extends RoutineStretchDeleteArgs>(args: SelectSubset<T, RoutineStretchDeleteArgs<ExtArgs>>): Prisma__RoutineStretchClient<$Result.GetResult<Prisma.$RoutineStretchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoutineStretch.
     * @param {RoutineStretchUpdateArgs} args - Arguments to update one RoutineStretch.
     * @example
     * // Update one RoutineStretch
     * const routineStretch = await prisma.routineStretch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoutineStretchUpdateArgs>(args: SelectSubset<T, RoutineStretchUpdateArgs<ExtArgs>>): Prisma__RoutineStretchClient<$Result.GetResult<Prisma.$RoutineStretchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoutineStretches.
     * @param {RoutineStretchDeleteManyArgs} args - Arguments to filter RoutineStretches to delete.
     * @example
     * // Delete a few RoutineStretches
     * const { count } = await prisma.routineStretch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoutineStretchDeleteManyArgs>(args?: SelectSubset<T, RoutineStretchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoutineStretches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineStretchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoutineStretches
     * const routineStretch = await prisma.routineStretch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoutineStretchUpdateManyArgs>(args: SelectSubset<T, RoutineStretchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoutineStretch.
     * @param {RoutineStretchUpsertArgs} args - Arguments to update or create a RoutineStretch.
     * @example
     * // Update or create a RoutineStretch
     * const routineStretch = await prisma.routineStretch.upsert({
     *   create: {
     *     // ... data to create a RoutineStretch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoutineStretch we want to update
     *   }
     * })
     */
    upsert<T extends RoutineStretchUpsertArgs>(args: SelectSubset<T, RoutineStretchUpsertArgs<ExtArgs>>): Prisma__RoutineStretchClient<$Result.GetResult<Prisma.$RoutineStretchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoutineStretches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineStretchCountArgs} args - Arguments to filter RoutineStretches to count.
     * @example
     * // Count the number of RoutineStretches
     * const count = await prisma.routineStretch.count({
     *   where: {
     *     // ... the filter for the RoutineStretches we want to count
     *   }
     * })
    **/
    count<T extends RoutineStretchCountArgs>(
      args?: Subset<T, RoutineStretchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoutineStretchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoutineStretch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineStretchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoutineStretchAggregateArgs>(args: Subset<T, RoutineStretchAggregateArgs>): Prisma.PrismaPromise<GetRoutineStretchAggregateType<T>>

    /**
     * Group by RoutineStretch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutineStretchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoutineStretchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoutineStretchGroupByArgs['orderBy'] }
        : { orderBy?: RoutineStretchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoutineStretchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoutineStretchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoutineStretch model
   */
  readonly fields: RoutineStretchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoutineStretch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoutineStretchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    routine<T extends StretchingRoutineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StretchingRoutineDefaultArgs<ExtArgs>>): Prisma__StretchingRoutineClient<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stretch<T extends StretchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StretchDefaultArgs<ExtArgs>>): Prisma__StretchClient<$Result.GetResult<Prisma.$StretchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoutineStretch model
   */ 
  interface RoutineStretchFieldRefs {
    readonly id: FieldRef<"RoutineStretch", 'String'>
    readonly routineId: FieldRef<"RoutineStretch", 'String'>
    readonly stretchId: FieldRef<"RoutineStretch", 'String'>
    readonly positionOrder: FieldRef<"RoutineStretch", 'Int'>
    readonly customDurationSeconds: FieldRef<"RoutineStretch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RoutineStretch findUnique
   */
  export type RoutineStretchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchInclude<ExtArgs> | null
    /**
     * Filter, which RoutineStretch to fetch.
     */
    where: RoutineStretchWhereUniqueInput
  }

  /**
   * RoutineStretch findUniqueOrThrow
   */
  export type RoutineStretchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchInclude<ExtArgs> | null
    /**
     * Filter, which RoutineStretch to fetch.
     */
    where: RoutineStretchWhereUniqueInput
  }

  /**
   * RoutineStretch findFirst
   */
  export type RoutineStretchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchInclude<ExtArgs> | null
    /**
     * Filter, which RoutineStretch to fetch.
     */
    where?: RoutineStretchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutineStretches to fetch.
     */
    orderBy?: RoutineStretchOrderByWithRelationInput | RoutineStretchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoutineStretches.
     */
    cursor?: RoutineStretchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutineStretches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutineStretches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoutineStretches.
     */
    distinct?: RoutineStretchScalarFieldEnum | RoutineStretchScalarFieldEnum[]
  }

  /**
   * RoutineStretch findFirstOrThrow
   */
  export type RoutineStretchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchInclude<ExtArgs> | null
    /**
     * Filter, which RoutineStretch to fetch.
     */
    where?: RoutineStretchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutineStretches to fetch.
     */
    orderBy?: RoutineStretchOrderByWithRelationInput | RoutineStretchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoutineStretches.
     */
    cursor?: RoutineStretchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutineStretches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutineStretches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoutineStretches.
     */
    distinct?: RoutineStretchScalarFieldEnum | RoutineStretchScalarFieldEnum[]
  }

  /**
   * RoutineStretch findMany
   */
  export type RoutineStretchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchInclude<ExtArgs> | null
    /**
     * Filter, which RoutineStretches to fetch.
     */
    where?: RoutineStretchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutineStretches to fetch.
     */
    orderBy?: RoutineStretchOrderByWithRelationInput | RoutineStretchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoutineStretches.
     */
    cursor?: RoutineStretchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutineStretches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutineStretches.
     */
    skip?: number
    distinct?: RoutineStretchScalarFieldEnum | RoutineStretchScalarFieldEnum[]
  }

  /**
   * RoutineStretch create
   */
  export type RoutineStretchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchInclude<ExtArgs> | null
    /**
     * The data needed to create a RoutineStretch.
     */
    data: XOR<RoutineStretchCreateInput, RoutineStretchUncheckedCreateInput>
  }

  /**
   * RoutineStretch createMany
   */
  export type RoutineStretchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoutineStretches.
     */
    data: RoutineStretchCreateManyInput | RoutineStretchCreateManyInput[]
  }

  /**
   * RoutineStretch createManyAndReturn
   */
  export type RoutineStretchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoutineStretches.
     */
    data: RoutineStretchCreateManyInput | RoutineStretchCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoutineStretch update
   */
  export type RoutineStretchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchInclude<ExtArgs> | null
    /**
     * The data needed to update a RoutineStretch.
     */
    data: XOR<RoutineStretchUpdateInput, RoutineStretchUncheckedUpdateInput>
    /**
     * Choose, which RoutineStretch to update.
     */
    where: RoutineStretchWhereUniqueInput
  }

  /**
   * RoutineStretch updateMany
   */
  export type RoutineStretchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoutineStretches.
     */
    data: XOR<RoutineStretchUpdateManyMutationInput, RoutineStretchUncheckedUpdateManyInput>
    /**
     * Filter which RoutineStretches to update
     */
    where?: RoutineStretchWhereInput
  }

  /**
   * RoutineStretch upsert
   */
  export type RoutineStretchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchInclude<ExtArgs> | null
    /**
     * The filter to search for the RoutineStretch to update in case it exists.
     */
    where: RoutineStretchWhereUniqueInput
    /**
     * In case the RoutineStretch found by the `where` argument doesn't exist, create a new RoutineStretch with this data.
     */
    create: XOR<RoutineStretchCreateInput, RoutineStretchUncheckedCreateInput>
    /**
     * In case the RoutineStretch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoutineStretchUpdateInput, RoutineStretchUncheckedUpdateInput>
  }

  /**
   * RoutineStretch delete
   */
  export type RoutineStretchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchInclude<ExtArgs> | null
    /**
     * Filter which RoutineStretch to delete.
     */
    where: RoutineStretchWhereUniqueInput
  }

  /**
   * RoutineStretch deleteMany
   */
  export type RoutineStretchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoutineStretches to delete
     */
    where?: RoutineStretchWhereInput
  }

  /**
   * RoutineStretch without action
   */
  export type RoutineStretchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutineStretch
     */
    select?: RoutineStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutineStretchInclude<ExtArgs> | null
  }


  /**
   * Model StretchingSession
   */

  export type AggregateStretchingSession = {
    _count: StretchingSessionCountAggregateOutputType | null
    _avg: StretchingSessionAvgAggregateOutputType | null
    _sum: StretchingSessionSumAggregateOutputType | null
    _min: StretchingSessionMinAggregateOutputType | null
    _max: StretchingSessionMaxAggregateOutputType | null
  }

  export type StretchingSessionAvgAggregateOutputType = {
    durationSeconds: number | null
  }

  export type StretchingSessionSumAggregateOutputType = {
    durationSeconds: number | null
  }

  export type StretchingSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    routineId: string | null
    routineName: string | null
    startedAt: Date | null
    completedAt: Date | null
    durationSeconds: number | null
    completed: boolean | null
    linkedWorkoutId: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type StretchingSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    routineId: string | null
    routineName: string | null
    startedAt: Date | null
    completedAt: Date | null
    durationSeconds: number | null
    completed: boolean | null
    linkedWorkoutId: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type StretchingSessionCountAggregateOutputType = {
    id: number
    userId: number
    routineId: number
    routineName: number
    startedAt: number
    completedAt: number
    durationSeconds: number
    completed: number
    linkedWorkoutId: number
    notes: number
    createdAt: number
    _all: number
  }


  export type StretchingSessionAvgAggregateInputType = {
    durationSeconds?: true
  }

  export type StretchingSessionSumAggregateInputType = {
    durationSeconds?: true
  }

  export type StretchingSessionMinAggregateInputType = {
    id?: true
    userId?: true
    routineId?: true
    routineName?: true
    startedAt?: true
    completedAt?: true
    durationSeconds?: true
    completed?: true
    linkedWorkoutId?: true
    notes?: true
    createdAt?: true
  }

  export type StretchingSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    routineId?: true
    routineName?: true
    startedAt?: true
    completedAt?: true
    durationSeconds?: true
    completed?: true
    linkedWorkoutId?: true
    notes?: true
    createdAt?: true
  }

  export type StretchingSessionCountAggregateInputType = {
    id?: true
    userId?: true
    routineId?: true
    routineName?: true
    startedAt?: true
    completedAt?: true
    durationSeconds?: true
    completed?: true
    linkedWorkoutId?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type StretchingSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StretchingSession to aggregate.
     */
    where?: StretchingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StretchingSessions to fetch.
     */
    orderBy?: StretchingSessionOrderByWithRelationInput | StretchingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StretchingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StretchingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StretchingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StretchingSessions
    **/
    _count?: true | StretchingSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StretchingSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StretchingSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StretchingSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StretchingSessionMaxAggregateInputType
  }

  export type GetStretchingSessionAggregateType<T extends StretchingSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateStretchingSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStretchingSession[P]>
      : GetScalarType<T[P], AggregateStretchingSession[P]>
  }




  export type StretchingSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StretchingSessionWhereInput
    orderBy?: StretchingSessionOrderByWithAggregationInput | StretchingSessionOrderByWithAggregationInput[]
    by: StretchingSessionScalarFieldEnum[] | StretchingSessionScalarFieldEnum
    having?: StretchingSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StretchingSessionCountAggregateInputType | true
    _avg?: StretchingSessionAvgAggregateInputType
    _sum?: StretchingSessionSumAggregateInputType
    _min?: StretchingSessionMinAggregateInputType
    _max?: StretchingSessionMaxAggregateInputType
  }

  export type StretchingSessionGroupByOutputType = {
    id: string
    userId: string
    routineId: string | null
    routineName: string | null
    startedAt: Date
    completedAt: Date | null
    durationSeconds: number | null
    completed: boolean
    linkedWorkoutId: string | null
    notes: string | null
    createdAt: Date
    _count: StretchingSessionCountAggregateOutputType | null
    _avg: StretchingSessionAvgAggregateOutputType | null
    _sum: StretchingSessionSumAggregateOutputType | null
    _min: StretchingSessionMinAggregateOutputType | null
    _max: StretchingSessionMaxAggregateOutputType | null
  }

  type GetStretchingSessionGroupByPayload<T extends StretchingSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StretchingSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StretchingSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StretchingSessionGroupByOutputType[P]>
            : GetScalarType<T[P], StretchingSessionGroupByOutputType[P]>
        }
      >
    >


  export type StretchingSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    routineId?: boolean
    routineName?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationSeconds?: boolean
    completed?: boolean
    linkedWorkoutId?: boolean
    notes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    routine?: boolean | StretchingSession$routineArgs<ExtArgs>
    stretches?: boolean | StretchingSession$stretchesArgs<ExtArgs>
    _count?: boolean | StretchingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stretchingSession"]>

  export type StretchingSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    routineId?: boolean
    routineName?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationSeconds?: boolean
    completed?: boolean
    linkedWorkoutId?: boolean
    notes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    routine?: boolean | StretchingSession$routineArgs<ExtArgs>
  }, ExtArgs["result"]["stretchingSession"]>

  export type StretchingSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    routineId?: boolean
    routineName?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationSeconds?: boolean
    completed?: boolean
    linkedWorkoutId?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type StretchingSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    routine?: boolean | StretchingSession$routineArgs<ExtArgs>
    stretches?: boolean | StretchingSession$stretchesArgs<ExtArgs>
    _count?: boolean | StretchingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StretchingSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    routine?: boolean | StretchingSession$routineArgs<ExtArgs>
  }

  export type $StretchingSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StretchingSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      routine: Prisma.$StretchingRoutinePayload<ExtArgs> | null
      stretches: Prisma.$SessionStretchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      routineId: string | null
      routineName: string | null
      startedAt: Date
      completedAt: Date | null
      durationSeconds: number | null
      completed: boolean
      linkedWorkoutId: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["stretchingSession"]>
    composites: {}
  }

  type StretchingSessionGetPayload<S extends boolean | null | undefined | StretchingSessionDefaultArgs> = $Result.GetResult<Prisma.$StretchingSessionPayload, S>

  type StretchingSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StretchingSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StretchingSessionCountAggregateInputType | true
    }

  export interface StretchingSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StretchingSession'], meta: { name: 'StretchingSession' } }
    /**
     * Find zero or one StretchingSession that matches the filter.
     * @param {StretchingSessionFindUniqueArgs} args - Arguments to find a StretchingSession
     * @example
     * // Get one StretchingSession
     * const stretchingSession = await prisma.stretchingSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StretchingSessionFindUniqueArgs>(args: SelectSubset<T, StretchingSessionFindUniqueArgs<ExtArgs>>): Prisma__StretchingSessionClient<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StretchingSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StretchingSessionFindUniqueOrThrowArgs} args - Arguments to find a StretchingSession
     * @example
     * // Get one StretchingSession
     * const stretchingSession = await prisma.stretchingSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StretchingSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, StretchingSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StretchingSessionClient<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StretchingSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingSessionFindFirstArgs} args - Arguments to find a StretchingSession
     * @example
     * // Get one StretchingSession
     * const stretchingSession = await prisma.stretchingSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StretchingSessionFindFirstArgs>(args?: SelectSubset<T, StretchingSessionFindFirstArgs<ExtArgs>>): Prisma__StretchingSessionClient<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StretchingSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingSessionFindFirstOrThrowArgs} args - Arguments to find a StretchingSession
     * @example
     * // Get one StretchingSession
     * const stretchingSession = await prisma.stretchingSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StretchingSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, StretchingSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StretchingSessionClient<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StretchingSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StretchingSessions
     * const stretchingSessions = await prisma.stretchingSession.findMany()
     * 
     * // Get first 10 StretchingSessions
     * const stretchingSessions = await prisma.stretchingSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stretchingSessionWithIdOnly = await prisma.stretchingSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StretchingSessionFindManyArgs>(args?: SelectSubset<T, StretchingSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StretchingSession.
     * @param {StretchingSessionCreateArgs} args - Arguments to create a StretchingSession.
     * @example
     * // Create one StretchingSession
     * const StretchingSession = await prisma.stretchingSession.create({
     *   data: {
     *     // ... data to create a StretchingSession
     *   }
     * })
     * 
     */
    create<T extends StretchingSessionCreateArgs>(args: SelectSubset<T, StretchingSessionCreateArgs<ExtArgs>>): Prisma__StretchingSessionClient<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StretchingSessions.
     * @param {StretchingSessionCreateManyArgs} args - Arguments to create many StretchingSessions.
     * @example
     * // Create many StretchingSessions
     * const stretchingSession = await prisma.stretchingSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StretchingSessionCreateManyArgs>(args?: SelectSubset<T, StretchingSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StretchingSessions and returns the data saved in the database.
     * @param {StretchingSessionCreateManyAndReturnArgs} args - Arguments to create many StretchingSessions.
     * @example
     * // Create many StretchingSessions
     * const stretchingSession = await prisma.stretchingSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StretchingSessions and only return the `id`
     * const stretchingSessionWithIdOnly = await prisma.stretchingSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StretchingSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, StretchingSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StretchingSession.
     * @param {StretchingSessionDeleteArgs} args - Arguments to delete one StretchingSession.
     * @example
     * // Delete one StretchingSession
     * const StretchingSession = await prisma.stretchingSession.delete({
     *   where: {
     *     // ... filter to delete one StretchingSession
     *   }
     * })
     * 
     */
    delete<T extends StretchingSessionDeleteArgs>(args: SelectSubset<T, StretchingSessionDeleteArgs<ExtArgs>>): Prisma__StretchingSessionClient<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StretchingSession.
     * @param {StretchingSessionUpdateArgs} args - Arguments to update one StretchingSession.
     * @example
     * // Update one StretchingSession
     * const stretchingSession = await prisma.stretchingSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StretchingSessionUpdateArgs>(args: SelectSubset<T, StretchingSessionUpdateArgs<ExtArgs>>): Prisma__StretchingSessionClient<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StretchingSessions.
     * @param {StretchingSessionDeleteManyArgs} args - Arguments to filter StretchingSessions to delete.
     * @example
     * // Delete a few StretchingSessions
     * const { count } = await prisma.stretchingSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StretchingSessionDeleteManyArgs>(args?: SelectSubset<T, StretchingSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StretchingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StretchingSessions
     * const stretchingSession = await prisma.stretchingSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StretchingSessionUpdateManyArgs>(args: SelectSubset<T, StretchingSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StretchingSession.
     * @param {StretchingSessionUpsertArgs} args - Arguments to update or create a StretchingSession.
     * @example
     * // Update or create a StretchingSession
     * const stretchingSession = await prisma.stretchingSession.upsert({
     *   create: {
     *     // ... data to create a StretchingSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StretchingSession we want to update
     *   }
     * })
     */
    upsert<T extends StretchingSessionUpsertArgs>(args: SelectSubset<T, StretchingSessionUpsertArgs<ExtArgs>>): Prisma__StretchingSessionClient<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StretchingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingSessionCountArgs} args - Arguments to filter StretchingSessions to count.
     * @example
     * // Count the number of StretchingSessions
     * const count = await prisma.stretchingSession.count({
     *   where: {
     *     // ... the filter for the StretchingSessions we want to count
     *   }
     * })
    **/
    count<T extends StretchingSessionCountArgs>(
      args?: Subset<T, StretchingSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StretchingSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StretchingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StretchingSessionAggregateArgs>(args: Subset<T, StretchingSessionAggregateArgs>): Prisma.PrismaPromise<GetStretchingSessionAggregateType<T>>

    /**
     * Group by StretchingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StretchingSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StretchingSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StretchingSessionGroupByArgs['orderBy'] }
        : { orderBy?: StretchingSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StretchingSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStretchingSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StretchingSession model
   */
  readonly fields: StretchingSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StretchingSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StretchingSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    routine<T extends StretchingSession$routineArgs<ExtArgs> = {}>(args?: Subset<T, StretchingSession$routineArgs<ExtArgs>>): Prisma__StretchingRoutineClient<$Result.GetResult<Prisma.$StretchingRoutinePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    stretches<T extends StretchingSession$stretchesArgs<ExtArgs> = {}>(args?: Subset<T, StretchingSession$stretchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionStretchPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StretchingSession model
   */ 
  interface StretchingSessionFieldRefs {
    readonly id: FieldRef<"StretchingSession", 'String'>
    readonly userId: FieldRef<"StretchingSession", 'String'>
    readonly routineId: FieldRef<"StretchingSession", 'String'>
    readonly routineName: FieldRef<"StretchingSession", 'String'>
    readonly startedAt: FieldRef<"StretchingSession", 'DateTime'>
    readonly completedAt: FieldRef<"StretchingSession", 'DateTime'>
    readonly durationSeconds: FieldRef<"StretchingSession", 'Int'>
    readonly completed: FieldRef<"StretchingSession", 'Boolean'>
    readonly linkedWorkoutId: FieldRef<"StretchingSession", 'String'>
    readonly notes: FieldRef<"StretchingSession", 'String'>
    readonly createdAt: FieldRef<"StretchingSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StretchingSession findUnique
   */
  export type StretchingSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionInclude<ExtArgs> | null
    /**
     * Filter, which StretchingSession to fetch.
     */
    where: StretchingSessionWhereUniqueInput
  }

  /**
   * StretchingSession findUniqueOrThrow
   */
  export type StretchingSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionInclude<ExtArgs> | null
    /**
     * Filter, which StretchingSession to fetch.
     */
    where: StretchingSessionWhereUniqueInput
  }

  /**
   * StretchingSession findFirst
   */
  export type StretchingSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionInclude<ExtArgs> | null
    /**
     * Filter, which StretchingSession to fetch.
     */
    where?: StretchingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StretchingSessions to fetch.
     */
    orderBy?: StretchingSessionOrderByWithRelationInput | StretchingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StretchingSessions.
     */
    cursor?: StretchingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StretchingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StretchingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StretchingSessions.
     */
    distinct?: StretchingSessionScalarFieldEnum | StretchingSessionScalarFieldEnum[]
  }

  /**
   * StretchingSession findFirstOrThrow
   */
  export type StretchingSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionInclude<ExtArgs> | null
    /**
     * Filter, which StretchingSession to fetch.
     */
    where?: StretchingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StretchingSessions to fetch.
     */
    orderBy?: StretchingSessionOrderByWithRelationInput | StretchingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StretchingSessions.
     */
    cursor?: StretchingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StretchingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StretchingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StretchingSessions.
     */
    distinct?: StretchingSessionScalarFieldEnum | StretchingSessionScalarFieldEnum[]
  }

  /**
   * StretchingSession findMany
   */
  export type StretchingSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionInclude<ExtArgs> | null
    /**
     * Filter, which StretchingSessions to fetch.
     */
    where?: StretchingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StretchingSessions to fetch.
     */
    orderBy?: StretchingSessionOrderByWithRelationInput | StretchingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StretchingSessions.
     */
    cursor?: StretchingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StretchingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StretchingSessions.
     */
    skip?: number
    distinct?: StretchingSessionScalarFieldEnum | StretchingSessionScalarFieldEnum[]
  }

  /**
   * StretchingSession create
   */
  export type StretchingSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a StretchingSession.
     */
    data: XOR<StretchingSessionCreateInput, StretchingSessionUncheckedCreateInput>
  }

  /**
   * StretchingSession createMany
   */
  export type StretchingSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StretchingSessions.
     */
    data: StretchingSessionCreateManyInput | StretchingSessionCreateManyInput[]
  }

  /**
   * StretchingSession createManyAndReturn
   */
  export type StretchingSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StretchingSessions.
     */
    data: StretchingSessionCreateManyInput | StretchingSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StretchingSession update
   */
  export type StretchingSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a StretchingSession.
     */
    data: XOR<StretchingSessionUpdateInput, StretchingSessionUncheckedUpdateInput>
    /**
     * Choose, which StretchingSession to update.
     */
    where: StretchingSessionWhereUniqueInput
  }

  /**
   * StretchingSession updateMany
   */
  export type StretchingSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StretchingSessions.
     */
    data: XOR<StretchingSessionUpdateManyMutationInput, StretchingSessionUncheckedUpdateManyInput>
    /**
     * Filter which StretchingSessions to update
     */
    where?: StretchingSessionWhereInput
  }

  /**
   * StretchingSession upsert
   */
  export type StretchingSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the StretchingSession to update in case it exists.
     */
    where: StretchingSessionWhereUniqueInput
    /**
     * In case the StretchingSession found by the `where` argument doesn't exist, create a new StretchingSession with this data.
     */
    create: XOR<StretchingSessionCreateInput, StretchingSessionUncheckedCreateInput>
    /**
     * In case the StretchingSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StretchingSessionUpdateInput, StretchingSessionUncheckedUpdateInput>
  }

  /**
   * StretchingSession delete
   */
  export type StretchingSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionInclude<ExtArgs> | null
    /**
     * Filter which StretchingSession to delete.
     */
    where: StretchingSessionWhereUniqueInput
  }

  /**
   * StretchingSession deleteMany
   */
  export type StretchingSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StretchingSessions to delete
     */
    where?: StretchingSessionWhereInput
  }

  /**
   * StretchingSession.routine
   */
  export type StretchingSession$routineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingRoutine
     */
    select?: StretchingRoutineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingRoutineInclude<ExtArgs> | null
    where?: StretchingRoutineWhereInput
  }

  /**
   * StretchingSession.stretches
   */
  export type StretchingSession$stretchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchInclude<ExtArgs> | null
    where?: SessionStretchWhereInput
    orderBy?: SessionStretchOrderByWithRelationInput | SessionStretchOrderByWithRelationInput[]
    cursor?: SessionStretchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionStretchScalarFieldEnum | SessionStretchScalarFieldEnum[]
  }

  /**
   * StretchingSession without action
   */
  export type StretchingSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StretchingSession
     */
    select?: StretchingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StretchingSessionInclude<ExtArgs> | null
  }


  /**
   * Model SessionStretch
   */

  export type AggregateSessionStretch = {
    _count: SessionStretchCountAggregateOutputType | null
    _avg: SessionStretchAvgAggregateOutputType | null
    _sum: SessionStretchSumAggregateOutputType | null
    _min: SessionStretchMinAggregateOutputType | null
    _max: SessionStretchMaxAggregateOutputType | null
  }

  export type SessionStretchAvgAggregateOutputType = {
    heldDurationSeconds: number | null
    positionInRoutine: number | null
  }

  export type SessionStretchSumAggregateOutputType = {
    heldDurationSeconds: number | null
    positionInRoutine: number | null
  }

  export type SessionStretchMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    stretchId: string | null
    heldDurationSeconds: number | null
    feltTight: boolean | null
    positionInRoutine: number | null
    completedAt: Date | null
  }

  export type SessionStretchMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    stretchId: string | null
    heldDurationSeconds: number | null
    feltTight: boolean | null
    positionInRoutine: number | null
    completedAt: Date | null
  }

  export type SessionStretchCountAggregateOutputType = {
    id: number
    sessionId: number
    stretchId: number
    heldDurationSeconds: number
    feltTight: number
    positionInRoutine: number
    completedAt: number
    _all: number
  }


  export type SessionStretchAvgAggregateInputType = {
    heldDurationSeconds?: true
    positionInRoutine?: true
  }

  export type SessionStretchSumAggregateInputType = {
    heldDurationSeconds?: true
    positionInRoutine?: true
  }

  export type SessionStretchMinAggregateInputType = {
    id?: true
    sessionId?: true
    stretchId?: true
    heldDurationSeconds?: true
    feltTight?: true
    positionInRoutine?: true
    completedAt?: true
  }

  export type SessionStretchMaxAggregateInputType = {
    id?: true
    sessionId?: true
    stretchId?: true
    heldDurationSeconds?: true
    feltTight?: true
    positionInRoutine?: true
    completedAt?: true
  }

  export type SessionStretchCountAggregateInputType = {
    id?: true
    sessionId?: true
    stretchId?: true
    heldDurationSeconds?: true
    feltTight?: true
    positionInRoutine?: true
    completedAt?: true
    _all?: true
  }

  export type SessionStretchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionStretch to aggregate.
     */
    where?: SessionStretchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionStretches to fetch.
     */
    orderBy?: SessionStretchOrderByWithRelationInput | SessionStretchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionStretchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionStretches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionStretches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionStretches
    **/
    _count?: true | SessionStretchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionStretchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionStretchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionStretchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionStretchMaxAggregateInputType
  }

  export type GetSessionStretchAggregateType<T extends SessionStretchAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionStretch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionStretch[P]>
      : GetScalarType<T[P], AggregateSessionStretch[P]>
  }




  export type SessionStretchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionStretchWhereInput
    orderBy?: SessionStretchOrderByWithAggregationInput | SessionStretchOrderByWithAggregationInput[]
    by: SessionStretchScalarFieldEnum[] | SessionStretchScalarFieldEnum
    having?: SessionStretchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionStretchCountAggregateInputType | true
    _avg?: SessionStretchAvgAggregateInputType
    _sum?: SessionStretchSumAggregateInputType
    _min?: SessionStretchMinAggregateInputType
    _max?: SessionStretchMaxAggregateInputType
  }

  export type SessionStretchGroupByOutputType = {
    id: string
    sessionId: string
    stretchId: string
    heldDurationSeconds: number
    feltTight: boolean
    positionInRoutine: number
    completedAt: Date
    _count: SessionStretchCountAggregateOutputType | null
    _avg: SessionStretchAvgAggregateOutputType | null
    _sum: SessionStretchSumAggregateOutputType | null
    _min: SessionStretchMinAggregateOutputType | null
    _max: SessionStretchMaxAggregateOutputType | null
  }

  type GetSessionStretchGroupByPayload<T extends SessionStretchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionStretchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionStretchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionStretchGroupByOutputType[P]>
            : GetScalarType<T[P], SessionStretchGroupByOutputType[P]>
        }
      >
    >


  export type SessionStretchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    stretchId?: boolean
    heldDurationSeconds?: boolean
    feltTight?: boolean
    positionInRoutine?: boolean
    completedAt?: boolean
    session?: boolean | StretchingSessionDefaultArgs<ExtArgs>
    stretch?: boolean | StretchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionStretch"]>

  export type SessionStretchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    stretchId?: boolean
    heldDurationSeconds?: boolean
    feltTight?: boolean
    positionInRoutine?: boolean
    completedAt?: boolean
    session?: boolean | StretchingSessionDefaultArgs<ExtArgs>
    stretch?: boolean | StretchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionStretch"]>

  export type SessionStretchSelectScalar = {
    id?: boolean
    sessionId?: boolean
    stretchId?: boolean
    heldDurationSeconds?: boolean
    feltTight?: boolean
    positionInRoutine?: boolean
    completedAt?: boolean
  }

  export type SessionStretchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | StretchingSessionDefaultArgs<ExtArgs>
    stretch?: boolean | StretchDefaultArgs<ExtArgs>
  }
  export type SessionStretchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | StretchingSessionDefaultArgs<ExtArgs>
    stretch?: boolean | StretchDefaultArgs<ExtArgs>
  }

  export type $SessionStretchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionStretch"
    objects: {
      session: Prisma.$StretchingSessionPayload<ExtArgs>
      stretch: Prisma.$StretchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      stretchId: string
      heldDurationSeconds: number
      feltTight: boolean
      positionInRoutine: number
      completedAt: Date
    }, ExtArgs["result"]["sessionStretch"]>
    composites: {}
  }

  type SessionStretchGetPayload<S extends boolean | null | undefined | SessionStretchDefaultArgs> = $Result.GetResult<Prisma.$SessionStretchPayload, S>

  type SessionStretchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionStretchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionStretchCountAggregateInputType | true
    }

  export interface SessionStretchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionStretch'], meta: { name: 'SessionStretch' } }
    /**
     * Find zero or one SessionStretch that matches the filter.
     * @param {SessionStretchFindUniqueArgs} args - Arguments to find a SessionStretch
     * @example
     * // Get one SessionStretch
     * const sessionStretch = await prisma.sessionStretch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionStretchFindUniqueArgs>(args: SelectSubset<T, SessionStretchFindUniqueArgs<ExtArgs>>): Prisma__SessionStretchClient<$Result.GetResult<Prisma.$SessionStretchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionStretch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionStretchFindUniqueOrThrowArgs} args - Arguments to find a SessionStretch
     * @example
     * // Get one SessionStretch
     * const sessionStretch = await prisma.sessionStretch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionStretchFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionStretchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionStretchClient<$Result.GetResult<Prisma.$SessionStretchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionStretch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStretchFindFirstArgs} args - Arguments to find a SessionStretch
     * @example
     * // Get one SessionStretch
     * const sessionStretch = await prisma.sessionStretch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionStretchFindFirstArgs>(args?: SelectSubset<T, SessionStretchFindFirstArgs<ExtArgs>>): Prisma__SessionStretchClient<$Result.GetResult<Prisma.$SessionStretchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionStretch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStretchFindFirstOrThrowArgs} args - Arguments to find a SessionStretch
     * @example
     * // Get one SessionStretch
     * const sessionStretch = await prisma.sessionStretch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionStretchFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionStretchFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionStretchClient<$Result.GetResult<Prisma.$SessionStretchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionStretches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStretchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionStretches
     * const sessionStretches = await prisma.sessionStretch.findMany()
     * 
     * // Get first 10 SessionStretches
     * const sessionStretches = await prisma.sessionStretch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionStretchWithIdOnly = await prisma.sessionStretch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionStretchFindManyArgs>(args?: SelectSubset<T, SessionStretchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionStretchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionStretch.
     * @param {SessionStretchCreateArgs} args - Arguments to create a SessionStretch.
     * @example
     * // Create one SessionStretch
     * const SessionStretch = await prisma.sessionStretch.create({
     *   data: {
     *     // ... data to create a SessionStretch
     *   }
     * })
     * 
     */
    create<T extends SessionStretchCreateArgs>(args: SelectSubset<T, SessionStretchCreateArgs<ExtArgs>>): Prisma__SessionStretchClient<$Result.GetResult<Prisma.$SessionStretchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionStretches.
     * @param {SessionStretchCreateManyArgs} args - Arguments to create many SessionStretches.
     * @example
     * // Create many SessionStretches
     * const sessionStretch = await prisma.sessionStretch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionStretchCreateManyArgs>(args?: SelectSubset<T, SessionStretchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionStretches and returns the data saved in the database.
     * @param {SessionStretchCreateManyAndReturnArgs} args - Arguments to create many SessionStretches.
     * @example
     * // Create many SessionStretches
     * const sessionStretch = await prisma.sessionStretch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionStretches and only return the `id`
     * const sessionStretchWithIdOnly = await prisma.sessionStretch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionStretchCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionStretchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionStretchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionStretch.
     * @param {SessionStretchDeleteArgs} args - Arguments to delete one SessionStretch.
     * @example
     * // Delete one SessionStretch
     * const SessionStretch = await prisma.sessionStretch.delete({
     *   where: {
     *     // ... filter to delete one SessionStretch
     *   }
     * })
     * 
     */
    delete<T extends SessionStretchDeleteArgs>(args: SelectSubset<T, SessionStretchDeleteArgs<ExtArgs>>): Prisma__SessionStretchClient<$Result.GetResult<Prisma.$SessionStretchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionStretch.
     * @param {SessionStretchUpdateArgs} args - Arguments to update one SessionStretch.
     * @example
     * // Update one SessionStretch
     * const sessionStretch = await prisma.sessionStretch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionStretchUpdateArgs>(args: SelectSubset<T, SessionStretchUpdateArgs<ExtArgs>>): Prisma__SessionStretchClient<$Result.GetResult<Prisma.$SessionStretchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionStretches.
     * @param {SessionStretchDeleteManyArgs} args - Arguments to filter SessionStretches to delete.
     * @example
     * // Delete a few SessionStretches
     * const { count } = await prisma.sessionStretch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionStretchDeleteManyArgs>(args?: SelectSubset<T, SessionStretchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionStretches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStretchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionStretches
     * const sessionStretch = await prisma.sessionStretch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionStretchUpdateManyArgs>(args: SelectSubset<T, SessionStretchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionStretch.
     * @param {SessionStretchUpsertArgs} args - Arguments to update or create a SessionStretch.
     * @example
     * // Update or create a SessionStretch
     * const sessionStretch = await prisma.sessionStretch.upsert({
     *   create: {
     *     // ... data to create a SessionStretch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionStretch we want to update
     *   }
     * })
     */
    upsert<T extends SessionStretchUpsertArgs>(args: SelectSubset<T, SessionStretchUpsertArgs<ExtArgs>>): Prisma__SessionStretchClient<$Result.GetResult<Prisma.$SessionStretchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionStretches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStretchCountArgs} args - Arguments to filter SessionStretches to count.
     * @example
     * // Count the number of SessionStretches
     * const count = await prisma.sessionStretch.count({
     *   where: {
     *     // ... the filter for the SessionStretches we want to count
     *   }
     * })
    **/
    count<T extends SessionStretchCountArgs>(
      args?: Subset<T, SessionStretchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionStretchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionStretch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStretchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionStretchAggregateArgs>(args: Subset<T, SessionStretchAggregateArgs>): Prisma.PrismaPromise<GetSessionStretchAggregateType<T>>

    /**
     * Group by SessionStretch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionStretchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionStretchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionStretchGroupByArgs['orderBy'] }
        : { orderBy?: SessionStretchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionStretchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionStretchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionStretch model
   */
  readonly fields: SessionStretchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionStretch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionStretchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends StretchingSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StretchingSessionDefaultArgs<ExtArgs>>): Prisma__StretchingSessionClient<$Result.GetResult<Prisma.$StretchingSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stretch<T extends StretchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StretchDefaultArgs<ExtArgs>>): Prisma__StretchClient<$Result.GetResult<Prisma.$StretchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionStretch model
   */ 
  interface SessionStretchFieldRefs {
    readonly id: FieldRef<"SessionStretch", 'String'>
    readonly sessionId: FieldRef<"SessionStretch", 'String'>
    readonly stretchId: FieldRef<"SessionStretch", 'String'>
    readonly heldDurationSeconds: FieldRef<"SessionStretch", 'Int'>
    readonly feltTight: FieldRef<"SessionStretch", 'Boolean'>
    readonly positionInRoutine: FieldRef<"SessionStretch", 'Int'>
    readonly completedAt: FieldRef<"SessionStretch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionStretch findUnique
   */
  export type SessionStretchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchInclude<ExtArgs> | null
    /**
     * Filter, which SessionStretch to fetch.
     */
    where: SessionStretchWhereUniqueInput
  }

  /**
   * SessionStretch findUniqueOrThrow
   */
  export type SessionStretchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchInclude<ExtArgs> | null
    /**
     * Filter, which SessionStretch to fetch.
     */
    where: SessionStretchWhereUniqueInput
  }

  /**
   * SessionStretch findFirst
   */
  export type SessionStretchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchInclude<ExtArgs> | null
    /**
     * Filter, which SessionStretch to fetch.
     */
    where?: SessionStretchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionStretches to fetch.
     */
    orderBy?: SessionStretchOrderByWithRelationInput | SessionStretchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionStretches.
     */
    cursor?: SessionStretchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionStretches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionStretches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionStretches.
     */
    distinct?: SessionStretchScalarFieldEnum | SessionStretchScalarFieldEnum[]
  }

  /**
   * SessionStretch findFirstOrThrow
   */
  export type SessionStretchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchInclude<ExtArgs> | null
    /**
     * Filter, which SessionStretch to fetch.
     */
    where?: SessionStretchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionStretches to fetch.
     */
    orderBy?: SessionStretchOrderByWithRelationInput | SessionStretchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionStretches.
     */
    cursor?: SessionStretchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionStretches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionStretches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionStretches.
     */
    distinct?: SessionStretchScalarFieldEnum | SessionStretchScalarFieldEnum[]
  }

  /**
   * SessionStretch findMany
   */
  export type SessionStretchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchInclude<ExtArgs> | null
    /**
     * Filter, which SessionStretches to fetch.
     */
    where?: SessionStretchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionStretches to fetch.
     */
    orderBy?: SessionStretchOrderByWithRelationInput | SessionStretchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionStretches.
     */
    cursor?: SessionStretchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionStretches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionStretches.
     */
    skip?: number
    distinct?: SessionStretchScalarFieldEnum | SessionStretchScalarFieldEnum[]
  }

  /**
   * SessionStretch create
   */
  export type SessionStretchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionStretch.
     */
    data: XOR<SessionStretchCreateInput, SessionStretchUncheckedCreateInput>
  }

  /**
   * SessionStretch createMany
   */
  export type SessionStretchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionStretches.
     */
    data: SessionStretchCreateManyInput | SessionStretchCreateManyInput[]
  }

  /**
   * SessionStretch createManyAndReturn
   */
  export type SessionStretchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionStretches.
     */
    data: SessionStretchCreateManyInput | SessionStretchCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionStretch update
   */
  export type SessionStretchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionStretch.
     */
    data: XOR<SessionStretchUpdateInput, SessionStretchUncheckedUpdateInput>
    /**
     * Choose, which SessionStretch to update.
     */
    where: SessionStretchWhereUniqueInput
  }

  /**
   * SessionStretch updateMany
   */
  export type SessionStretchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionStretches.
     */
    data: XOR<SessionStretchUpdateManyMutationInput, SessionStretchUncheckedUpdateManyInput>
    /**
     * Filter which SessionStretches to update
     */
    where?: SessionStretchWhereInput
  }

  /**
   * SessionStretch upsert
   */
  export type SessionStretchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionStretch to update in case it exists.
     */
    where: SessionStretchWhereUniqueInput
    /**
     * In case the SessionStretch found by the `where` argument doesn't exist, create a new SessionStretch with this data.
     */
    create: XOR<SessionStretchCreateInput, SessionStretchUncheckedCreateInput>
    /**
     * In case the SessionStretch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionStretchUpdateInput, SessionStretchUncheckedUpdateInput>
  }

  /**
   * SessionStretch delete
   */
  export type SessionStretchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchInclude<ExtArgs> | null
    /**
     * Filter which SessionStretch to delete.
     */
    where: SessionStretchWhereUniqueInput
  }

  /**
   * SessionStretch deleteMany
   */
  export type SessionStretchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionStretches to delete
     */
    where?: SessionStretchWhereInput
  }

  /**
   * SessionStretch without action
   */
  export type SessionStretchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionStretch
     */
    select?: SessionStretchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionStretchInclude<ExtArgs> | null
  }


  /**
   * Model FlexibilityGoal
   */

  export type AggregateFlexibilityGoal = {
    _count: FlexibilityGoalCountAggregateOutputType | null
    _avg: FlexibilityGoalAvgAggregateOutputType | null
    _sum: FlexibilityGoalSumAggregateOutputType | null
    _min: FlexibilityGoalMinAggregateOutputType | null
    _max: FlexibilityGoalMaxAggregateOutputType | null
  }

  export type FlexibilityGoalAvgAggregateOutputType = {
    baselineRom: number | null
    targetRom: number | null
  }

  export type FlexibilityGoalSumAggregateOutputType = {
    baselineRom: number | null
    targetRom: number | null
  }

  export type FlexibilityGoalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    goalType: string | null
    description: string | null
    targetArea: string | null
    baselineRom: number | null
    targetRom: number | null
    targetDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlexibilityGoalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    goalType: string | null
    description: string | null
    targetArea: string | null
    baselineRom: number | null
    targetRom: number | null
    targetDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlexibilityGoalCountAggregateOutputType = {
    id: number
    userId: number
    goalType: number
    description: number
    targetArea: number
    baselineRom: number
    targetRom: number
    targetDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FlexibilityGoalAvgAggregateInputType = {
    baselineRom?: true
    targetRom?: true
  }

  export type FlexibilityGoalSumAggregateInputType = {
    baselineRom?: true
    targetRom?: true
  }

  export type FlexibilityGoalMinAggregateInputType = {
    id?: true
    userId?: true
    goalType?: true
    description?: true
    targetArea?: true
    baselineRom?: true
    targetRom?: true
    targetDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlexibilityGoalMaxAggregateInputType = {
    id?: true
    userId?: true
    goalType?: true
    description?: true
    targetArea?: true
    baselineRom?: true
    targetRom?: true
    targetDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlexibilityGoalCountAggregateInputType = {
    id?: true
    userId?: true
    goalType?: true
    description?: true
    targetArea?: true
    baselineRom?: true
    targetRom?: true
    targetDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FlexibilityGoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlexibilityGoal to aggregate.
     */
    where?: FlexibilityGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlexibilityGoals to fetch.
     */
    orderBy?: FlexibilityGoalOrderByWithRelationInput | FlexibilityGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlexibilityGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlexibilityGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlexibilityGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlexibilityGoals
    **/
    _count?: true | FlexibilityGoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlexibilityGoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlexibilityGoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlexibilityGoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlexibilityGoalMaxAggregateInputType
  }

  export type GetFlexibilityGoalAggregateType<T extends FlexibilityGoalAggregateArgs> = {
        [P in keyof T & keyof AggregateFlexibilityGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlexibilityGoal[P]>
      : GetScalarType<T[P], AggregateFlexibilityGoal[P]>
  }




  export type FlexibilityGoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlexibilityGoalWhereInput
    orderBy?: FlexibilityGoalOrderByWithAggregationInput | FlexibilityGoalOrderByWithAggregationInput[]
    by: FlexibilityGoalScalarFieldEnum[] | FlexibilityGoalScalarFieldEnum
    having?: FlexibilityGoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlexibilityGoalCountAggregateInputType | true
    _avg?: FlexibilityGoalAvgAggregateInputType
    _sum?: FlexibilityGoalSumAggregateInputType
    _min?: FlexibilityGoalMinAggregateInputType
    _max?: FlexibilityGoalMaxAggregateInputType
  }

  export type FlexibilityGoalGroupByOutputType = {
    id: string
    userId: string
    goalType: string
    description: string | null
    targetArea: string
    baselineRom: number | null
    targetRom: number | null
    targetDate: Date | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: FlexibilityGoalCountAggregateOutputType | null
    _avg: FlexibilityGoalAvgAggregateOutputType | null
    _sum: FlexibilityGoalSumAggregateOutputType | null
    _min: FlexibilityGoalMinAggregateOutputType | null
    _max: FlexibilityGoalMaxAggregateOutputType | null
  }

  type GetFlexibilityGoalGroupByPayload<T extends FlexibilityGoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlexibilityGoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlexibilityGoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlexibilityGoalGroupByOutputType[P]>
            : GetScalarType<T[P], FlexibilityGoalGroupByOutputType[P]>
        }
      >
    >


  export type FlexibilityGoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    goalType?: boolean
    description?: boolean
    targetArea?: boolean
    baselineRom?: boolean
    targetRom?: boolean
    targetDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    measurements?: boolean | FlexibilityGoal$measurementsArgs<ExtArgs>
    progressVideos?: boolean | FlexibilityGoal$progressVideosArgs<ExtArgs>
    _count?: boolean | FlexibilityGoalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flexibilityGoal"]>

  export type FlexibilityGoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    goalType?: boolean
    description?: boolean
    targetArea?: boolean
    baselineRom?: boolean
    targetRom?: boolean
    targetDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flexibilityGoal"]>

  export type FlexibilityGoalSelectScalar = {
    id?: boolean
    userId?: boolean
    goalType?: boolean
    description?: boolean
    targetArea?: boolean
    baselineRom?: boolean
    targetRom?: boolean
    targetDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FlexibilityGoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    measurements?: boolean | FlexibilityGoal$measurementsArgs<ExtArgs>
    progressVideos?: boolean | FlexibilityGoal$progressVideosArgs<ExtArgs>
    _count?: boolean | FlexibilityGoalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FlexibilityGoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FlexibilityGoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlexibilityGoal"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      measurements: Prisma.$RomMeasurementPayload<ExtArgs>[]
      progressVideos: Prisma.$ProgressVideoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      goalType: string
      description: string | null
      targetArea: string
      baselineRom: number | null
      targetRom: number | null
      targetDate: Date | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["flexibilityGoal"]>
    composites: {}
  }

  type FlexibilityGoalGetPayload<S extends boolean | null | undefined | FlexibilityGoalDefaultArgs> = $Result.GetResult<Prisma.$FlexibilityGoalPayload, S>

  type FlexibilityGoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FlexibilityGoalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FlexibilityGoalCountAggregateInputType | true
    }

  export interface FlexibilityGoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlexibilityGoal'], meta: { name: 'FlexibilityGoal' } }
    /**
     * Find zero or one FlexibilityGoal that matches the filter.
     * @param {FlexibilityGoalFindUniqueArgs} args - Arguments to find a FlexibilityGoal
     * @example
     * // Get one FlexibilityGoal
     * const flexibilityGoal = await prisma.flexibilityGoal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlexibilityGoalFindUniqueArgs>(args: SelectSubset<T, FlexibilityGoalFindUniqueArgs<ExtArgs>>): Prisma__FlexibilityGoalClient<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FlexibilityGoal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FlexibilityGoalFindUniqueOrThrowArgs} args - Arguments to find a FlexibilityGoal
     * @example
     * // Get one FlexibilityGoal
     * const flexibilityGoal = await prisma.flexibilityGoal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlexibilityGoalFindUniqueOrThrowArgs>(args: SelectSubset<T, FlexibilityGoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlexibilityGoalClient<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FlexibilityGoal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexibilityGoalFindFirstArgs} args - Arguments to find a FlexibilityGoal
     * @example
     * // Get one FlexibilityGoal
     * const flexibilityGoal = await prisma.flexibilityGoal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlexibilityGoalFindFirstArgs>(args?: SelectSubset<T, FlexibilityGoalFindFirstArgs<ExtArgs>>): Prisma__FlexibilityGoalClient<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FlexibilityGoal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexibilityGoalFindFirstOrThrowArgs} args - Arguments to find a FlexibilityGoal
     * @example
     * // Get one FlexibilityGoal
     * const flexibilityGoal = await prisma.flexibilityGoal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlexibilityGoalFindFirstOrThrowArgs>(args?: SelectSubset<T, FlexibilityGoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlexibilityGoalClient<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FlexibilityGoals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexibilityGoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlexibilityGoals
     * const flexibilityGoals = await prisma.flexibilityGoal.findMany()
     * 
     * // Get first 10 FlexibilityGoals
     * const flexibilityGoals = await prisma.flexibilityGoal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flexibilityGoalWithIdOnly = await prisma.flexibilityGoal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlexibilityGoalFindManyArgs>(args?: SelectSubset<T, FlexibilityGoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FlexibilityGoal.
     * @param {FlexibilityGoalCreateArgs} args - Arguments to create a FlexibilityGoal.
     * @example
     * // Create one FlexibilityGoal
     * const FlexibilityGoal = await prisma.flexibilityGoal.create({
     *   data: {
     *     // ... data to create a FlexibilityGoal
     *   }
     * })
     * 
     */
    create<T extends FlexibilityGoalCreateArgs>(args: SelectSubset<T, FlexibilityGoalCreateArgs<ExtArgs>>): Prisma__FlexibilityGoalClient<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FlexibilityGoals.
     * @param {FlexibilityGoalCreateManyArgs} args - Arguments to create many FlexibilityGoals.
     * @example
     * // Create many FlexibilityGoals
     * const flexibilityGoal = await prisma.flexibilityGoal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlexibilityGoalCreateManyArgs>(args?: SelectSubset<T, FlexibilityGoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlexibilityGoals and returns the data saved in the database.
     * @param {FlexibilityGoalCreateManyAndReturnArgs} args - Arguments to create many FlexibilityGoals.
     * @example
     * // Create many FlexibilityGoals
     * const flexibilityGoal = await prisma.flexibilityGoal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlexibilityGoals and only return the `id`
     * const flexibilityGoalWithIdOnly = await prisma.flexibilityGoal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlexibilityGoalCreateManyAndReturnArgs>(args?: SelectSubset<T, FlexibilityGoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FlexibilityGoal.
     * @param {FlexibilityGoalDeleteArgs} args - Arguments to delete one FlexibilityGoal.
     * @example
     * // Delete one FlexibilityGoal
     * const FlexibilityGoal = await prisma.flexibilityGoal.delete({
     *   where: {
     *     // ... filter to delete one FlexibilityGoal
     *   }
     * })
     * 
     */
    delete<T extends FlexibilityGoalDeleteArgs>(args: SelectSubset<T, FlexibilityGoalDeleteArgs<ExtArgs>>): Prisma__FlexibilityGoalClient<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FlexibilityGoal.
     * @param {FlexibilityGoalUpdateArgs} args - Arguments to update one FlexibilityGoal.
     * @example
     * // Update one FlexibilityGoal
     * const flexibilityGoal = await prisma.flexibilityGoal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlexibilityGoalUpdateArgs>(args: SelectSubset<T, FlexibilityGoalUpdateArgs<ExtArgs>>): Prisma__FlexibilityGoalClient<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FlexibilityGoals.
     * @param {FlexibilityGoalDeleteManyArgs} args - Arguments to filter FlexibilityGoals to delete.
     * @example
     * // Delete a few FlexibilityGoals
     * const { count } = await prisma.flexibilityGoal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlexibilityGoalDeleteManyArgs>(args?: SelectSubset<T, FlexibilityGoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlexibilityGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexibilityGoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlexibilityGoals
     * const flexibilityGoal = await prisma.flexibilityGoal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlexibilityGoalUpdateManyArgs>(args: SelectSubset<T, FlexibilityGoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FlexibilityGoal.
     * @param {FlexibilityGoalUpsertArgs} args - Arguments to update or create a FlexibilityGoal.
     * @example
     * // Update or create a FlexibilityGoal
     * const flexibilityGoal = await prisma.flexibilityGoal.upsert({
     *   create: {
     *     // ... data to create a FlexibilityGoal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlexibilityGoal we want to update
     *   }
     * })
     */
    upsert<T extends FlexibilityGoalUpsertArgs>(args: SelectSubset<T, FlexibilityGoalUpsertArgs<ExtArgs>>): Prisma__FlexibilityGoalClient<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FlexibilityGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexibilityGoalCountArgs} args - Arguments to filter FlexibilityGoals to count.
     * @example
     * // Count the number of FlexibilityGoals
     * const count = await prisma.flexibilityGoal.count({
     *   where: {
     *     // ... the filter for the FlexibilityGoals we want to count
     *   }
     * })
    **/
    count<T extends FlexibilityGoalCountArgs>(
      args?: Subset<T, FlexibilityGoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlexibilityGoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlexibilityGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexibilityGoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlexibilityGoalAggregateArgs>(args: Subset<T, FlexibilityGoalAggregateArgs>): Prisma.PrismaPromise<GetFlexibilityGoalAggregateType<T>>

    /**
     * Group by FlexibilityGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlexibilityGoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlexibilityGoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlexibilityGoalGroupByArgs['orderBy'] }
        : { orderBy?: FlexibilityGoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlexibilityGoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlexibilityGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlexibilityGoal model
   */
  readonly fields: FlexibilityGoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlexibilityGoal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlexibilityGoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    measurements<T extends FlexibilityGoal$measurementsArgs<ExtArgs> = {}>(args?: Subset<T, FlexibilityGoal$measurementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RomMeasurementPayload<ExtArgs>, T, "findMany"> | Null>
    progressVideos<T extends FlexibilityGoal$progressVideosArgs<ExtArgs> = {}>(args?: Subset<T, FlexibilityGoal$progressVideosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressVideoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlexibilityGoal model
   */ 
  interface FlexibilityGoalFieldRefs {
    readonly id: FieldRef<"FlexibilityGoal", 'String'>
    readonly userId: FieldRef<"FlexibilityGoal", 'String'>
    readonly goalType: FieldRef<"FlexibilityGoal", 'String'>
    readonly description: FieldRef<"FlexibilityGoal", 'String'>
    readonly targetArea: FieldRef<"FlexibilityGoal", 'String'>
    readonly baselineRom: FieldRef<"FlexibilityGoal", 'Float'>
    readonly targetRom: FieldRef<"FlexibilityGoal", 'Float'>
    readonly targetDate: FieldRef<"FlexibilityGoal", 'DateTime'>
    readonly status: FieldRef<"FlexibilityGoal", 'String'>
    readonly createdAt: FieldRef<"FlexibilityGoal", 'DateTime'>
    readonly updatedAt: FieldRef<"FlexibilityGoal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlexibilityGoal findUnique
   */
  export type FlexibilityGoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalInclude<ExtArgs> | null
    /**
     * Filter, which FlexibilityGoal to fetch.
     */
    where: FlexibilityGoalWhereUniqueInput
  }

  /**
   * FlexibilityGoal findUniqueOrThrow
   */
  export type FlexibilityGoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalInclude<ExtArgs> | null
    /**
     * Filter, which FlexibilityGoal to fetch.
     */
    where: FlexibilityGoalWhereUniqueInput
  }

  /**
   * FlexibilityGoal findFirst
   */
  export type FlexibilityGoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalInclude<ExtArgs> | null
    /**
     * Filter, which FlexibilityGoal to fetch.
     */
    where?: FlexibilityGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlexibilityGoals to fetch.
     */
    orderBy?: FlexibilityGoalOrderByWithRelationInput | FlexibilityGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlexibilityGoals.
     */
    cursor?: FlexibilityGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlexibilityGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlexibilityGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlexibilityGoals.
     */
    distinct?: FlexibilityGoalScalarFieldEnum | FlexibilityGoalScalarFieldEnum[]
  }

  /**
   * FlexibilityGoal findFirstOrThrow
   */
  export type FlexibilityGoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalInclude<ExtArgs> | null
    /**
     * Filter, which FlexibilityGoal to fetch.
     */
    where?: FlexibilityGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlexibilityGoals to fetch.
     */
    orderBy?: FlexibilityGoalOrderByWithRelationInput | FlexibilityGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlexibilityGoals.
     */
    cursor?: FlexibilityGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlexibilityGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlexibilityGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlexibilityGoals.
     */
    distinct?: FlexibilityGoalScalarFieldEnum | FlexibilityGoalScalarFieldEnum[]
  }

  /**
   * FlexibilityGoal findMany
   */
  export type FlexibilityGoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalInclude<ExtArgs> | null
    /**
     * Filter, which FlexibilityGoals to fetch.
     */
    where?: FlexibilityGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlexibilityGoals to fetch.
     */
    orderBy?: FlexibilityGoalOrderByWithRelationInput | FlexibilityGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlexibilityGoals.
     */
    cursor?: FlexibilityGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlexibilityGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlexibilityGoals.
     */
    skip?: number
    distinct?: FlexibilityGoalScalarFieldEnum | FlexibilityGoalScalarFieldEnum[]
  }

  /**
   * FlexibilityGoal create
   */
  export type FlexibilityGoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalInclude<ExtArgs> | null
    /**
     * The data needed to create a FlexibilityGoal.
     */
    data: XOR<FlexibilityGoalCreateInput, FlexibilityGoalUncheckedCreateInput>
  }

  /**
   * FlexibilityGoal createMany
   */
  export type FlexibilityGoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlexibilityGoals.
     */
    data: FlexibilityGoalCreateManyInput | FlexibilityGoalCreateManyInput[]
  }

  /**
   * FlexibilityGoal createManyAndReturn
   */
  export type FlexibilityGoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FlexibilityGoals.
     */
    data: FlexibilityGoalCreateManyInput | FlexibilityGoalCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlexibilityGoal update
   */
  export type FlexibilityGoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalInclude<ExtArgs> | null
    /**
     * The data needed to update a FlexibilityGoal.
     */
    data: XOR<FlexibilityGoalUpdateInput, FlexibilityGoalUncheckedUpdateInput>
    /**
     * Choose, which FlexibilityGoal to update.
     */
    where: FlexibilityGoalWhereUniqueInput
  }

  /**
   * FlexibilityGoal updateMany
   */
  export type FlexibilityGoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlexibilityGoals.
     */
    data: XOR<FlexibilityGoalUpdateManyMutationInput, FlexibilityGoalUncheckedUpdateManyInput>
    /**
     * Filter which FlexibilityGoals to update
     */
    where?: FlexibilityGoalWhereInput
  }

  /**
   * FlexibilityGoal upsert
   */
  export type FlexibilityGoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalInclude<ExtArgs> | null
    /**
     * The filter to search for the FlexibilityGoal to update in case it exists.
     */
    where: FlexibilityGoalWhereUniqueInput
    /**
     * In case the FlexibilityGoal found by the `where` argument doesn't exist, create a new FlexibilityGoal with this data.
     */
    create: XOR<FlexibilityGoalCreateInput, FlexibilityGoalUncheckedCreateInput>
    /**
     * In case the FlexibilityGoal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlexibilityGoalUpdateInput, FlexibilityGoalUncheckedUpdateInput>
  }

  /**
   * FlexibilityGoal delete
   */
  export type FlexibilityGoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalInclude<ExtArgs> | null
    /**
     * Filter which FlexibilityGoal to delete.
     */
    where: FlexibilityGoalWhereUniqueInput
  }

  /**
   * FlexibilityGoal deleteMany
   */
  export type FlexibilityGoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlexibilityGoals to delete
     */
    where?: FlexibilityGoalWhereInput
  }

  /**
   * FlexibilityGoal.measurements
   */
  export type FlexibilityGoal$measurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RomMeasurement
     */
    select?: RomMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RomMeasurementInclude<ExtArgs> | null
    where?: RomMeasurementWhereInput
    orderBy?: RomMeasurementOrderByWithRelationInput | RomMeasurementOrderByWithRelationInput[]
    cursor?: RomMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RomMeasurementScalarFieldEnum | RomMeasurementScalarFieldEnum[]
  }

  /**
   * FlexibilityGoal.progressVideos
   */
  export type FlexibilityGoal$progressVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoInclude<ExtArgs> | null
    where?: ProgressVideoWhereInput
    orderBy?: ProgressVideoOrderByWithRelationInput | ProgressVideoOrderByWithRelationInput[]
    cursor?: ProgressVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressVideoScalarFieldEnum | ProgressVideoScalarFieldEnum[]
  }

  /**
   * FlexibilityGoal without action
   */
  export type FlexibilityGoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalInclude<ExtArgs> | null
  }


  /**
   * Model RomMeasurement
   */

  export type AggregateRomMeasurement = {
    _count: RomMeasurementCountAggregateOutputType | null
    _avg: RomMeasurementAvgAggregateOutputType | null
    _sum: RomMeasurementSumAggregateOutputType | null
    _min: RomMeasurementMinAggregateOutputType | null
    _max: RomMeasurementMaxAggregateOutputType | null
  }

  export type RomMeasurementAvgAggregateOutputType = {
    romDegrees: number | null
  }

  export type RomMeasurementSumAggregateOutputType = {
    romDegrees: number | null
  }

  export type RomMeasurementMinAggregateOutputType = {
    id: string | null
    goalId: string | null
    romDegrees: number | null
    measurementDate: Date | null
    measurementMethod: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type RomMeasurementMaxAggregateOutputType = {
    id: string | null
    goalId: string | null
    romDegrees: number | null
    measurementDate: Date | null
    measurementMethod: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type RomMeasurementCountAggregateOutputType = {
    id: number
    goalId: number
    romDegrees: number
    measurementDate: number
    measurementMethod: number
    notes: number
    createdAt: number
    _all: number
  }


  export type RomMeasurementAvgAggregateInputType = {
    romDegrees?: true
  }

  export type RomMeasurementSumAggregateInputType = {
    romDegrees?: true
  }

  export type RomMeasurementMinAggregateInputType = {
    id?: true
    goalId?: true
    romDegrees?: true
    measurementDate?: true
    measurementMethod?: true
    notes?: true
    createdAt?: true
  }

  export type RomMeasurementMaxAggregateInputType = {
    id?: true
    goalId?: true
    romDegrees?: true
    measurementDate?: true
    measurementMethod?: true
    notes?: true
    createdAt?: true
  }

  export type RomMeasurementCountAggregateInputType = {
    id?: true
    goalId?: true
    romDegrees?: true
    measurementDate?: true
    measurementMethod?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type RomMeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RomMeasurement to aggregate.
     */
    where?: RomMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RomMeasurements to fetch.
     */
    orderBy?: RomMeasurementOrderByWithRelationInput | RomMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RomMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RomMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RomMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RomMeasurements
    **/
    _count?: true | RomMeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RomMeasurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RomMeasurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RomMeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RomMeasurementMaxAggregateInputType
  }

  export type GetRomMeasurementAggregateType<T extends RomMeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateRomMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRomMeasurement[P]>
      : GetScalarType<T[P], AggregateRomMeasurement[P]>
  }




  export type RomMeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RomMeasurementWhereInput
    orderBy?: RomMeasurementOrderByWithAggregationInput | RomMeasurementOrderByWithAggregationInput[]
    by: RomMeasurementScalarFieldEnum[] | RomMeasurementScalarFieldEnum
    having?: RomMeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RomMeasurementCountAggregateInputType | true
    _avg?: RomMeasurementAvgAggregateInputType
    _sum?: RomMeasurementSumAggregateInputType
    _min?: RomMeasurementMinAggregateInputType
    _max?: RomMeasurementMaxAggregateInputType
  }

  export type RomMeasurementGroupByOutputType = {
    id: string
    goalId: string
    romDegrees: number
    measurementDate: Date
    measurementMethod: string | null
    notes: string | null
    createdAt: Date
    _count: RomMeasurementCountAggregateOutputType | null
    _avg: RomMeasurementAvgAggregateOutputType | null
    _sum: RomMeasurementSumAggregateOutputType | null
    _min: RomMeasurementMinAggregateOutputType | null
    _max: RomMeasurementMaxAggregateOutputType | null
  }

  type GetRomMeasurementGroupByPayload<T extends RomMeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RomMeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RomMeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RomMeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], RomMeasurementGroupByOutputType[P]>
        }
      >
    >


  export type RomMeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    romDegrees?: boolean
    measurementDate?: boolean
    measurementMethod?: boolean
    notes?: boolean
    createdAt?: boolean
    goal?: boolean | FlexibilityGoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["romMeasurement"]>

  export type RomMeasurementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    romDegrees?: boolean
    measurementDate?: boolean
    measurementMethod?: boolean
    notes?: boolean
    createdAt?: boolean
    goal?: boolean | FlexibilityGoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["romMeasurement"]>

  export type RomMeasurementSelectScalar = {
    id?: boolean
    goalId?: boolean
    romDegrees?: boolean
    measurementDate?: boolean
    measurementMethod?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type RomMeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | FlexibilityGoalDefaultArgs<ExtArgs>
  }
  export type RomMeasurementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | FlexibilityGoalDefaultArgs<ExtArgs>
  }

  export type $RomMeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RomMeasurement"
    objects: {
      goal: Prisma.$FlexibilityGoalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      goalId: string
      romDegrees: number
      measurementDate: Date
      measurementMethod: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["romMeasurement"]>
    composites: {}
  }

  type RomMeasurementGetPayload<S extends boolean | null | undefined | RomMeasurementDefaultArgs> = $Result.GetResult<Prisma.$RomMeasurementPayload, S>

  type RomMeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RomMeasurementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RomMeasurementCountAggregateInputType | true
    }

  export interface RomMeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RomMeasurement'], meta: { name: 'RomMeasurement' } }
    /**
     * Find zero or one RomMeasurement that matches the filter.
     * @param {RomMeasurementFindUniqueArgs} args - Arguments to find a RomMeasurement
     * @example
     * // Get one RomMeasurement
     * const romMeasurement = await prisma.romMeasurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RomMeasurementFindUniqueArgs>(args: SelectSubset<T, RomMeasurementFindUniqueArgs<ExtArgs>>): Prisma__RomMeasurementClient<$Result.GetResult<Prisma.$RomMeasurementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RomMeasurement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RomMeasurementFindUniqueOrThrowArgs} args - Arguments to find a RomMeasurement
     * @example
     * // Get one RomMeasurement
     * const romMeasurement = await prisma.romMeasurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RomMeasurementFindUniqueOrThrowArgs>(args: SelectSubset<T, RomMeasurementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RomMeasurementClient<$Result.GetResult<Prisma.$RomMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RomMeasurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RomMeasurementFindFirstArgs} args - Arguments to find a RomMeasurement
     * @example
     * // Get one RomMeasurement
     * const romMeasurement = await prisma.romMeasurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RomMeasurementFindFirstArgs>(args?: SelectSubset<T, RomMeasurementFindFirstArgs<ExtArgs>>): Prisma__RomMeasurementClient<$Result.GetResult<Prisma.$RomMeasurementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RomMeasurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RomMeasurementFindFirstOrThrowArgs} args - Arguments to find a RomMeasurement
     * @example
     * // Get one RomMeasurement
     * const romMeasurement = await prisma.romMeasurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RomMeasurementFindFirstOrThrowArgs>(args?: SelectSubset<T, RomMeasurementFindFirstOrThrowArgs<ExtArgs>>): Prisma__RomMeasurementClient<$Result.GetResult<Prisma.$RomMeasurementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RomMeasurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RomMeasurementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RomMeasurements
     * const romMeasurements = await prisma.romMeasurement.findMany()
     * 
     * // Get first 10 RomMeasurements
     * const romMeasurements = await prisma.romMeasurement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const romMeasurementWithIdOnly = await prisma.romMeasurement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RomMeasurementFindManyArgs>(args?: SelectSubset<T, RomMeasurementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RomMeasurementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RomMeasurement.
     * @param {RomMeasurementCreateArgs} args - Arguments to create a RomMeasurement.
     * @example
     * // Create one RomMeasurement
     * const RomMeasurement = await prisma.romMeasurement.create({
     *   data: {
     *     // ... data to create a RomMeasurement
     *   }
     * })
     * 
     */
    create<T extends RomMeasurementCreateArgs>(args: SelectSubset<T, RomMeasurementCreateArgs<ExtArgs>>): Prisma__RomMeasurementClient<$Result.GetResult<Prisma.$RomMeasurementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RomMeasurements.
     * @param {RomMeasurementCreateManyArgs} args - Arguments to create many RomMeasurements.
     * @example
     * // Create many RomMeasurements
     * const romMeasurement = await prisma.romMeasurement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RomMeasurementCreateManyArgs>(args?: SelectSubset<T, RomMeasurementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RomMeasurements and returns the data saved in the database.
     * @param {RomMeasurementCreateManyAndReturnArgs} args - Arguments to create many RomMeasurements.
     * @example
     * // Create many RomMeasurements
     * const romMeasurement = await prisma.romMeasurement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RomMeasurements and only return the `id`
     * const romMeasurementWithIdOnly = await prisma.romMeasurement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RomMeasurementCreateManyAndReturnArgs>(args?: SelectSubset<T, RomMeasurementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RomMeasurementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RomMeasurement.
     * @param {RomMeasurementDeleteArgs} args - Arguments to delete one RomMeasurement.
     * @example
     * // Delete one RomMeasurement
     * const RomMeasurement = await prisma.romMeasurement.delete({
     *   where: {
     *     // ... filter to delete one RomMeasurement
     *   }
     * })
     * 
     */
    delete<T extends RomMeasurementDeleteArgs>(args: SelectSubset<T, RomMeasurementDeleteArgs<ExtArgs>>): Prisma__RomMeasurementClient<$Result.GetResult<Prisma.$RomMeasurementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RomMeasurement.
     * @param {RomMeasurementUpdateArgs} args - Arguments to update one RomMeasurement.
     * @example
     * // Update one RomMeasurement
     * const romMeasurement = await prisma.romMeasurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RomMeasurementUpdateArgs>(args: SelectSubset<T, RomMeasurementUpdateArgs<ExtArgs>>): Prisma__RomMeasurementClient<$Result.GetResult<Prisma.$RomMeasurementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RomMeasurements.
     * @param {RomMeasurementDeleteManyArgs} args - Arguments to filter RomMeasurements to delete.
     * @example
     * // Delete a few RomMeasurements
     * const { count } = await prisma.romMeasurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RomMeasurementDeleteManyArgs>(args?: SelectSubset<T, RomMeasurementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RomMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RomMeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RomMeasurements
     * const romMeasurement = await prisma.romMeasurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RomMeasurementUpdateManyArgs>(args: SelectSubset<T, RomMeasurementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RomMeasurement.
     * @param {RomMeasurementUpsertArgs} args - Arguments to update or create a RomMeasurement.
     * @example
     * // Update or create a RomMeasurement
     * const romMeasurement = await prisma.romMeasurement.upsert({
     *   create: {
     *     // ... data to create a RomMeasurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RomMeasurement we want to update
     *   }
     * })
     */
    upsert<T extends RomMeasurementUpsertArgs>(args: SelectSubset<T, RomMeasurementUpsertArgs<ExtArgs>>): Prisma__RomMeasurementClient<$Result.GetResult<Prisma.$RomMeasurementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RomMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RomMeasurementCountArgs} args - Arguments to filter RomMeasurements to count.
     * @example
     * // Count the number of RomMeasurements
     * const count = await prisma.romMeasurement.count({
     *   where: {
     *     // ... the filter for the RomMeasurements we want to count
     *   }
     * })
    **/
    count<T extends RomMeasurementCountArgs>(
      args?: Subset<T, RomMeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RomMeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RomMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RomMeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RomMeasurementAggregateArgs>(args: Subset<T, RomMeasurementAggregateArgs>): Prisma.PrismaPromise<GetRomMeasurementAggregateType<T>>

    /**
     * Group by RomMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RomMeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RomMeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RomMeasurementGroupByArgs['orderBy'] }
        : { orderBy?: RomMeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RomMeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRomMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RomMeasurement model
   */
  readonly fields: RomMeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RomMeasurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RomMeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goal<T extends FlexibilityGoalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlexibilityGoalDefaultArgs<ExtArgs>>): Prisma__FlexibilityGoalClient<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RomMeasurement model
   */ 
  interface RomMeasurementFieldRefs {
    readonly id: FieldRef<"RomMeasurement", 'String'>
    readonly goalId: FieldRef<"RomMeasurement", 'String'>
    readonly romDegrees: FieldRef<"RomMeasurement", 'Float'>
    readonly measurementDate: FieldRef<"RomMeasurement", 'DateTime'>
    readonly measurementMethod: FieldRef<"RomMeasurement", 'String'>
    readonly notes: FieldRef<"RomMeasurement", 'String'>
    readonly createdAt: FieldRef<"RomMeasurement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RomMeasurement findUnique
   */
  export type RomMeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RomMeasurement
     */
    select?: RomMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RomMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which RomMeasurement to fetch.
     */
    where: RomMeasurementWhereUniqueInput
  }

  /**
   * RomMeasurement findUniqueOrThrow
   */
  export type RomMeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RomMeasurement
     */
    select?: RomMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RomMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which RomMeasurement to fetch.
     */
    where: RomMeasurementWhereUniqueInput
  }

  /**
   * RomMeasurement findFirst
   */
  export type RomMeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RomMeasurement
     */
    select?: RomMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RomMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which RomMeasurement to fetch.
     */
    where?: RomMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RomMeasurements to fetch.
     */
    orderBy?: RomMeasurementOrderByWithRelationInput | RomMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RomMeasurements.
     */
    cursor?: RomMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RomMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RomMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RomMeasurements.
     */
    distinct?: RomMeasurementScalarFieldEnum | RomMeasurementScalarFieldEnum[]
  }

  /**
   * RomMeasurement findFirstOrThrow
   */
  export type RomMeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RomMeasurement
     */
    select?: RomMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RomMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which RomMeasurement to fetch.
     */
    where?: RomMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RomMeasurements to fetch.
     */
    orderBy?: RomMeasurementOrderByWithRelationInput | RomMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RomMeasurements.
     */
    cursor?: RomMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RomMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RomMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RomMeasurements.
     */
    distinct?: RomMeasurementScalarFieldEnum | RomMeasurementScalarFieldEnum[]
  }

  /**
   * RomMeasurement findMany
   */
  export type RomMeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RomMeasurement
     */
    select?: RomMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RomMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which RomMeasurements to fetch.
     */
    where?: RomMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RomMeasurements to fetch.
     */
    orderBy?: RomMeasurementOrderByWithRelationInput | RomMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RomMeasurements.
     */
    cursor?: RomMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RomMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RomMeasurements.
     */
    skip?: number
    distinct?: RomMeasurementScalarFieldEnum | RomMeasurementScalarFieldEnum[]
  }

  /**
   * RomMeasurement create
   */
  export type RomMeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RomMeasurement
     */
    select?: RomMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RomMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a RomMeasurement.
     */
    data: XOR<RomMeasurementCreateInput, RomMeasurementUncheckedCreateInput>
  }

  /**
   * RomMeasurement createMany
   */
  export type RomMeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RomMeasurements.
     */
    data: RomMeasurementCreateManyInput | RomMeasurementCreateManyInput[]
  }

  /**
   * RomMeasurement createManyAndReturn
   */
  export type RomMeasurementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RomMeasurement
     */
    select?: RomMeasurementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RomMeasurements.
     */
    data: RomMeasurementCreateManyInput | RomMeasurementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RomMeasurementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RomMeasurement update
   */
  export type RomMeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RomMeasurement
     */
    select?: RomMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RomMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a RomMeasurement.
     */
    data: XOR<RomMeasurementUpdateInput, RomMeasurementUncheckedUpdateInput>
    /**
     * Choose, which RomMeasurement to update.
     */
    where: RomMeasurementWhereUniqueInput
  }

  /**
   * RomMeasurement updateMany
   */
  export type RomMeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RomMeasurements.
     */
    data: XOR<RomMeasurementUpdateManyMutationInput, RomMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which RomMeasurements to update
     */
    where?: RomMeasurementWhereInput
  }

  /**
   * RomMeasurement upsert
   */
  export type RomMeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RomMeasurement
     */
    select?: RomMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RomMeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the RomMeasurement to update in case it exists.
     */
    where: RomMeasurementWhereUniqueInput
    /**
     * In case the RomMeasurement found by the `where` argument doesn't exist, create a new RomMeasurement with this data.
     */
    create: XOR<RomMeasurementCreateInput, RomMeasurementUncheckedCreateInput>
    /**
     * In case the RomMeasurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RomMeasurementUpdateInput, RomMeasurementUncheckedUpdateInput>
  }

  /**
   * RomMeasurement delete
   */
  export type RomMeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RomMeasurement
     */
    select?: RomMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RomMeasurementInclude<ExtArgs> | null
    /**
     * Filter which RomMeasurement to delete.
     */
    where: RomMeasurementWhereUniqueInput
  }

  /**
   * RomMeasurement deleteMany
   */
  export type RomMeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RomMeasurements to delete
     */
    where?: RomMeasurementWhereInput
  }

  /**
   * RomMeasurement without action
   */
  export type RomMeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RomMeasurement
     */
    select?: RomMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RomMeasurementInclude<ExtArgs> | null
  }


  /**
   * Model ProgressVideo
   */

  export type AggregateProgressVideo = {
    _count: ProgressVideoCountAggregateOutputType | null
    _min: ProgressVideoMinAggregateOutputType | null
    _max: ProgressVideoMaxAggregateOutputType | null
  }

  export type ProgressVideoMinAggregateOutputType = {
    id: string | null
    userId: string | null
    goalId: string | null
    videoUrl: string | null
    uploadedAt: Date | null
  }

  export type ProgressVideoMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    goalId: string | null
    videoUrl: string | null
    uploadedAt: Date | null
  }

  export type ProgressVideoCountAggregateOutputType = {
    id: number
    userId: number
    goalId: number
    videoUrl: number
    uploadedAt: number
    _all: number
  }


  export type ProgressVideoMinAggregateInputType = {
    id?: true
    userId?: true
    goalId?: true
    videoUrl?: true
    uploadedAt?: true
  }

  export type ProgressVideoMaxAggregateInputType = {
    id?: true
    userId?: true
    goalId?: true
    videoUrl?: true
    uploadedAt?: true
  }

  export type ProgressVideoCountAggregateInputType = {
    id?: true
    userId?: true
    goalId?: true
    videoUrl?: true
    uploadedAt?: true
    _all?: true
  }

  export type ProgressVideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgressVideo to aggregate.
     */
    where?: ProgressVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressVideos to fetch.
     */
    orderBy?: ProgressVideoOrderByWithRelationInput | ProgressVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgressVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgressVideos
    **/
    _count?: true | ProgressVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgressVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgressVideoMaxAggregateInputType
  }

  export type GetProgressVideoAggregateType<T extends ProgressVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateProgressVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgressVideo[P]>
      : GetScalarType<T[P], AggregateProgressVideo[P]>
  }




  export type ProgressVideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressVideoWhereInput
    orderBy?: ProgressVideoOrderByWithAggregationInput | ProgressVideoOrderByWithAggregationInput[]
    by: ProgressVideoScalarFieldEnum[] | ProgressVideoScalarFieldEnum
    having?: ProgressVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgressVideoCountAggregateInputType | true
    _min?: ProgressVideoMinAggregateInputType
    _max?: ProgressVideoMaxAggregateInputType
  }

  export type ProgressVideoGroupByOutputType = {
    id: string
    userId: string
    goalId: string | null
    videoUrl: string
    uploadedAt: Date
    _count: ProgressVideoCountAggregateOutputType | null
    _min: ProgressVideoMinAggregateOutputType | null
    _max: ProgressVideoMaxAggregateOutputType | null
  }

  type GetProgressVideoGroupByPayload<T extends ProgressVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgressVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgressVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgressVideoGroupByOutputType[P]>
            : GetScalarType<T[P], ProgressVideoGroupByOutputType[P]>
        }
      >
    >


  export type ProgressVideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    goalId?: boolean
    videoUrl?: boolean
    uploadedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    goal?: boolean | ProgressVideo$goalArgs<ExtArgs>
  }, ExtArgs["result"]["progressVideo"]>

  export type ProgressVideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    goalId?: boolean
    videoUrl?: boolean
    uploadedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    goal?: boolean | ProgressVideo$goalArgs<ExtArgs>
  }, ExtArgs["result"]["progressVideo"]>

  export type ProgressVideoSelectScalar = {
    id?: boolean
    userId?: boolean
    goalId?: boolean
    videoUrl?: boolean
    uploadedAt?: boolean
  }

  export type ProgressVideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    goal?: boolean | ProgressVideo$goalArgs<ExtArgs>
  }
  export type ProgressVideoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    goal?: boolean | ProgressVideo$goalArgs<ExtArgs>
  }

  export type $ProgressVideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgressVideo"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      goal: Prisma.$FlexibilityGoalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      goalId: string | null
      videoUrl: string
      uploadedAt: Date
    }, ExtArgs["result"]["progressVideo"]>
    composites: {}
  }

  type ProgressVideoGetPayload<S extends boolean | null | undefined | ProgressVideoDefaultArgs> = $Result.GetResult<Prisma.$ProgressVideoPayload, S>

  type ProgressVideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgressVideoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgressVideoCountAggregateInputType | true
    }

  export interface ProgressVideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgressVideo'], meta: { name: 'ProgressVideo' } }
    /**
     * Find zero or one ProgressVideo that matches the filter.
     * @param {ProgressVideoFindUniqueArgs} args - Arguments to find a ProgressVideo
     * @example
     * // Get one ProgressVideo
     * const progressVideo = await prisma.progressVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgressVideoFindUniqueArgs>(args: SelectSubset<T, ProgressVideoFindUniqueArgs<ExtArgs>>): Prisma__ProgressVideoClient<$Result.GetResult<Prisma.$ProgressVideoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgressVideo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgressVideoFindUniqueOrThrowArgs} args - Arguments to find a ProgressVideo
     * @example
     * // Get one ProgressVideo
     * const progressVideo = await prisma.progressVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgressVideoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgressVideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgressVideoClient<$Result.GetResult<Prisma.$ProgressVideoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgressVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressVideoFindFirstArgs} args - Arguments to find a ProgressVideo
     * @example
     * // Get one ProgressVideo
     * const progressVideo = await prisma.progressVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgressVideoFindFirstArgs>(args?: SelectSubset<T, ProgressVideoFindFirstArgs<ExtArgs>>): Prisma__ProgressVideoClient<$Result.GetResult<Prisma.$ProgressVideoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgressVideo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressVideoFindFirstOrThrowArgs} args - Arguments to find a ProgressVideo
     * @example
     * // Get one ProgressVideo
     * const progressVideo = await prisma.progressVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgressVideoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgressVideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgressVideoClient<$Result.GetResult<Prisma.$ProgressVideoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgressVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressVideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgressVideos
     * const progressVideos = await prisma.progressVideo.findMany()
     * 
     * // Get first 10 ProgressVideos
     * const progressVideos = await prisma.progressVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const progressVideoWithIdOnly = await prisma.progressVideo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgressVideoFindManyArgs>(args?: SelectSubset<T, ProgressVideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressVideoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgressVideo.
     * @param {ProgressVideoCreateArgs} args - Arguments to create a ProgressVideo.
     * @example
     * // Create one ProgressVideo
     * const ProgressVideo = await prisma.progressVideo.create({
     *   data: {
     *     // ... data to create a ProgressVideo
     *   }
     * })
     * 
     */
    create<T extends ProgressVideoCreateArgs>(args: SelectSubset<T, ProgressVideoCreateArgs<ExtArgs>>): Prisma__ProgressVideoClient<$Result.GetResult<Prisma.$ProgressVideoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgressVideos.
     * @param {ProgressVideoCreateManyArgs} args - Arguments to create many ProgressVideos.
     * @example
     * // Create many ProgressVideos
     * const progressVideo = await prisma.progressVideo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgressVideoCreateManyArgs>(args?: SelectSubset<T, ProgressVideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgressVideos and returns the data saved in the database.
     * @param {ProgressVideoCreateManyAndReturnArgs} args - Arguments to create many ProgressVideos.
     * @example
     * // Create many ProgressVideos
     * const progressVideo = await prisma.progressVideo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgressVideos and only return the `id`
     * const progressVideoWithIdOnly = await prisma.progressVideo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgressVideoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgressVideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressVideoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProgressVideo.
     * @param {ProgressVideoDeleteArgs} args - Arguments to delete one ProgressVideo.
     * @example
     * // Delete one ProgressVideo
     * const ProgressVideo = await prisma.progressVideo.delete({
     *   where: {
     *     // ... filter to delete one ProgressVideo
     *   }
     * })
     * 
     */
    delete<T extends ProgressVideoDeleteArgs>(args: SelectSubset<T, ProgressVideoDeleteArgs<ExtArgs>>): Prisma__ProgressVideoClient<$Result.GetResult<Prisma.$ProgressVideoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgressVideo.
     * @param {ProgressVideoUpdateArgs} args - Arguments to update one ProgressVideo.
     * @example
     * // Update one ProgressVideo
     * const progressVideo = await prisma.progressVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgressVideoUpdateArgs>(args: SelectSubset<T, ProgressVideoUpdateArgs<ExtArgs>>): Prisma__ProgressVideoClient<$Result.GetResult<Prisma.$ProgressVideoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgressVideos.
     * @param {ProgressVideoDeleteManyArgs} args - Arguments to filter ProgressVideos to delete.
     * @example
     * // Delete a few ProgressVideos
     * const { count } = await prisma.progressVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgressVideoDeleteManyArgs>(args?: SelectSubset<T, ProgressVideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgressVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgressVideos
     * const progressVideo = await prisma.progressVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgressVideoUpdateManyArgs>(args: SelectSubset<T, ProgressVideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgressVideo.
     * @param {ProgressVideoUpsertArgs} args - Arguments to update or create a ProgressVideo.
     * @example
     * // Update or create a ProgressVideo
     * const progressVideo = await prisma.progressVideo.upsert({
     *   create: {
     *     // ... data to create a ProgressVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgressVideo we want to update
     *   }
     * })
     */
    upsert<T extends ProgressVideoUpsertArgs>(args: SelectSubset<T, ProgressVideoUpsertArgs<ExtArgs>>): Prisma__ProgressVideoClient<$Result.GetResult<Prisma.$ProgressVideoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgressVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressVideoCountArgs} args - Arguments to filter ProgressVideos to count.
     * @example
     * // Count the number of ProgressVideos
     * const count = await prisma.progressVideo.count({
     *   where: {
     *     // ... the filter for the ProgressVideos we want to count
     *   }
     * })
    **/
    count<T extends ProgressVideoCountArgs>(
      args?: Subset<T, ProgressVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgressVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgressVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgressVideoAggregateArgs>(args: Subset<T, ProgressVideoAggregateArgs>): Prisma.PrismaPromise<GetProgressVideoAggregateType<T>>

    /**
     * Group by ProgressVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgressVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgressVideoGroupByArgs['orderBy'] }
        : { orderBy?: ProgressVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgressVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgressVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgressVideo model
   */
  readonly fields: ProgressVideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgressVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgressVideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    goal<T extends ProgressVideo$goalArgs<ExtArgs> = {}>(args?: Subset<T, ProgressVideo$goalArgs<ExtArgs>>): Prisma__FlexibilityGoalClient<$Result.GetResult<Prisma.$FlexibilityGoalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgressVideo model
   */ 
  interface ProgressVideoFieldRefs {
    readonly id: FieldRef<"ProgressVideo", 'String'>
    readonly userId: FieldRef<"ProgressVideo", 'String'>
    readonly goalId: FieldRef<"ProgressVideo", 'String'>
    readonly videoUrl: FieldRef<"ProgressVideo", 'String'>
    readonly uploadedAt: FieldRef<"ProgressVideo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgressVideo findUnique
   */
  export type ProgressVideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoInclude<ExtArgs> | null
    /**
     * Filter, which ProgressVideo to fetch.
     */
    where: ProgressVideoWhereUniqueInput
  }

  /**
   * ProgressVideo findUniqueOrThrow
   */
  export type ProgressVideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoInclude<ExtArgs> | null
    /**
     * Filter, which ProgressVideo to fetch.
     */
    where: ProgressVideoWhereUniqueInput
  }

  /**
   * ProgressVideo findFirst
   */
  export type ProgressVideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoInclude<ExtArgs> | null
    /**
     * Filter, which ProgressVideo to fetch.
     */
    where?: ProgressVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressVideos to fetch.
     */
    orderBy?: ProgressVideoOrderByWithRelationInput | ProgressVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgressVideos.
     */
    cursor?: ProgressVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgressVideos.
     */
    distinct?: ProgressVideoScalarFieldEnum | ProgressVideoScalarFieldEnum[]
  }

  /**
   * ProgressVideo findFirstOrThrow
   */
  export type ProgressVideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoInclude<ExtArgs> | null
    /**
     * Filter, which ProgressVideo to fetch.
     */
    where?: ProgressVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressVideos to fetch.
     */
    orderBy?: ProgressVideoOrderByWithRelationInput | ProgressVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgressVideos.
     */
    cursor?: ProgressVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgressVideos.
     */
    distinct?: ProgressVideoScalarFieldEnum | ProgressVideoScalarFieldEnum[]
  }

  /**
   * ProgressVideo findMany
   */
  export type ProgressVideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoInclude<ExtArgs> | null
    /**
     * Filter, which ProgressVideos to fetch.
     */
    where?: ProgressVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressVideos to fetch.
     */
    orderBy?: ProgressVideoOrderByWithRelationInput | ProgressVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgressVideos.
     */
    cursor?: ProgressVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressVideos.
     */
    skip?: number
    distinct?: ProgressVideoScalarFieldEnum | ProgressVideoScalarFieldEnum[]
  }

  /**
   * ProgressVideo create
   */
  export type ProgressVideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgressVideo.
     */
    data: XOR<ProgressVideoCreateInput, ProgressVideoUncheckedCreateInput>
  }

  /**
   * ProgressVideo createMany
   */
  export type ProgressVideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgressVideos.
     */
    data: ProgressVideoCreateManyInput | ProgressVideoCreateManyInput[]
  }

  /**
   * ProgressVideo createManyAndReturn
   */
  export type ProgressVideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProgressVideos.
     */
    data: ProgressVideoCreateManyInput | ProgressVideoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgressVideo update
   */
  export type ProgressVideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgressVideo.
     */
    data: XOR<ProgressVideoUpdateInput, ProgressVideoUncheckedUpdateInput>
    /**
     * Choose, which ProgressVideo to update.
     */
    where: ProgressVideoWhereUniqueInput
  }

  /**
   * ProgressVideo updateMany
   */
  export type ProgressVideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgressVideos.
     */
    data: XOR<ProgressVideoUpdateManyMutationInput, ProgressVideoUncheckedUpdateManyInput>
    /**
     * Filter which ProgressVideos to update
     */
    where?: ProgressVideoWhereInput
  }

  /**
   * ProgressVideo upsert
   */
  export type ProgressVideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgressVideo to update in case it exists.
     */
    where: ProgressVideoWhereUniqueInput
    /**
     * In case the ProgressVideo found by the `where` argument doesn't exist, create a new ProgressVideo with this data.
     */
    create: XOR<ProgressVideoCreateInput, ProgressVideoUncheckedCreateInput>
    /**
     * In case the ProgressVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgressVideoUpdateInput, ProgressVideoUncheckedUpdateInput>
  }

  /**
   * ProgressVideo delete
   */
  export type ProgressVideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoInclude<ExtArgs> | null
    /**
     * Filter which ProgressVideo to delete.
     */
    where: ProgressVideoWhereUniqueInput
  }

  /**
   * ProgressVideo deleteMany
   */
  export type ProgressVideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgressVideos to delete
     */
    where?: ProgressVideoWhereInput
  }

  /**
   * ProgressVideo.goal
   */
  export type ProgressVideo$goalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlexibilityGoal
     */
    select?: FlexibilityGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlexibilityGoalInclude<ExtArgs> | null
    where?: FlexibilityGoalWhereInput
  }

  /**
   * ProgressVideo without action
   */
  export type ProgressVideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressVideo
     */
    select?: ProgressVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressVideoInclude<ExtArgs> | null
  }


  /**
   * Model Exercise
   */

  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseAvgAggregateOutputType = {
    metValue: number | null
  }

  export type ExerciseSumAggregateOutputType = {
    metValue: number | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    equipmentNeeded: string | null
    videoUrl: string | null
    thumbnailUrl: string | null
    primaryMuscles: string | null
    secondaryMuscles: string | null
    difficulty: string | null
    instructions: string | null
    tips: string | null
    commonMistakes: string | null
    isCompound: boolean | null
    isUnilateral: boolean | null
    forceType: string | null
    mechanic: string | null
    metValue: number | null
    is1RMEligible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    equipmentNeeded: string | null
    videoUrl: string | null
    thumbnailUrl: string | null
    primaryMuscles: string | null
    secondaryMuscles: string | null
    difficulty: string | null
    instructions: string | null
    tips: string | null
    commonMistakes: string | null
    isCompound: boolean | null
    isUnilateral: boolean | null
    forceType: string | null
    mechanic: string | null
    metValue: number | null
    is1RMEligible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    equipmentNeeded: number
    videoUrl: number
    thumbnailUrl: number
    primaryMuscles: number
    secondaryMuscles: number
    difficulty: number
    instructions: number
    tips: number
    commonMistakes: number
    isCompound: number
    isUnilateral: number
    forceType: number
    mechanic: number
    metValue: number
    is1RMEligible: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExerciseAvgAggregateInputType = {
    metValue?: true
  }

  export type ExerciseSumAggregateInputType = {
    metValue?: true
  }

  export type ExerciseMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    equipmentNeeded?: true
    videoUrl?: true
    thumbnailUrl?: true
    primaryMuscles?: true
    secondaryMuscles?: true
    difficulty?: true
    instructions?: true
    tips?: true
    commonMistakes?: true
    isCompound?: true
    isUnilateral?: true
    forceType?: true
    mechanic?: true
    metValue?: true
    is1RMEligible?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    equipmentNeeded?: true
    videoUrl?: true
    thumbnailUrl?: true
    primaryMuscles?: true
    secondaryMuscles?: true
    difficulty?: true
    instructions?: true
    tips?: true
    commonMistakes?: true
    isCompound?: true
    isUnilateral?: true
    forceType?: true
    mechanic?: true
    metValue?: true
    is1RMEligible?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    equipmentNeeded?: true
    videoUrl?: true
    thumbnailUrl?: true
    primaryMuscles?: true
    secondaryMuscles?: true
    difficulty?: true
    instructions?: true
    tips?: true
    commonMistakes?: true
    isCompound?: true
    isUnilateral?: true
    forceType?: true
    mechanic?: true
    metValue?: true
    is1RMEligible?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithAggregationInput | ExerciseOrderByWithAggregationInput[]
    by: ExerciseScalarFieldEnum[] | ExerciseScalarFieldEnum
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _avg?: ExerciseAvgAggregateInputType
    _sum?: ExerciseSumAggregateInputType
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }

  export type ExerciseGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string
    equipmentNeeded: string | null
    videoUrl: string | null
    thumbnailUrl: string | null
    primaryMuscles: string
    secondaryMuscles: string | null
    difficulty: string
    instructions: string | null
    tips: string | null
    commonMistakes: string | null
    isCompound: boolean
    isUnilateral: boolean
    forceType: string | null
    mechanic: string | null
    metValue: number | null
    is1RMEligible: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    equipmentNeeded?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    primaryMuscles?: boolean
    secondaryMuscles?: boolean
    difficulty?: boolean
    instructions?: boolean
    tips?: boolean
    commonMistakes?: boolean
    isCompound?: boolean
    isUnilateral?: boolean
    forceType?: boolean
    mechanic?: boolean
    metValue?: boolean
    is1RMEligible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workoutExercises?: boolean | Exercise$workoutExercisesArgs<ExtArgs>
    personalRecords?: boolean | Exercise$personalRecordsArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    equipmentNeeded?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    primaryMuscles?: boolean
    secondaryMuscles?: boolean
    difficulty?: boolean
    instructions?: boolean
    tips?: boolean
    commonMistakes?: boolean
    isCompound?: boolean
    isUnilateral?: boolean
    forceType?: boolean
    mechanic?: boolean
    metValue?: boolean
    is1RMEligible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    equipmentNeeded?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    primaryMuscles?: boolean
    secondaryMuscles?: boolean
    difficulty?: boolean
    instructions?: boolean
    tips?: boolean
    commonMistakes?: boolean
    isCompound?: boolean
    isUnilateral?: boolean
    forceType?: boolean
    mechanic?: boolean
    metValue?: boolean
    is1RMEligible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workoutExercises?: boolean | Exercise$workoutExercisesArgs<ExtArgs>
    personalRecords?: boolean | Exercise$personalRecordsArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exercise"
    objects: {
      workoutExercises: Prisma.$WorkoutExercisePayload<ExtArgs>[]
      personalRecords: Prisma.$PersonalRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: string
      equipmentNeeded: string | null
      videoUrl: string | null
      thumbnailUrl: string | null
      primaryMuscles: string
      secondaryMuscles: string | null
      difficulty: string
      instructions: string | null
      tips: string | null
      commonMistakes: string | null
      isCompound: boolean
      isUnilateral: boolean
      forceType: string | null
      mechanic: string | null
      metValue: number | null
      is1RMEligible: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exercise"]>
    composites: {}
  }

  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExerciseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseFindUniqueArgs>(args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exercise that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseFindFirstArgs>(args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseFindManyArgs>(args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
     */
    create<T extends ExerciseCreateArgs>(args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exercises.
     * @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseCreateManyArgs>(args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exercises and returns the data saved in the database.
     * @param {ExerciseCreateManyAndReturnArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
     */
    delete<T extends ExerciseDeleteArgs>(args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseUpdateArgs>(args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseDeleteManyArgs>(args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseUpdateManyArgs>(args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseUpsertArgs>(args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exercise model
   */
  readonly fields: ExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workoutExercises<T extends Exercise$workoutExercisesArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$workoutExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findMany"> | Null>
    personalRecords<T extends Exercise$personalRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$personalRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exercise model
   */ 
  interface ExerciseFieldRefs {
    readonly id: FieldRef<"Exercise", 'String'>
    readonly name: FieldRef<"Exercise", 'String'>
    readonly description: FieldRef<"Exercise", 'String'>
    readonly category: FieldRef<"Exercise", 'String'>
    readonly equipmentNeeded: FieldRef<"Exercise", 'String'>
    readonly videoUrl: FieldRef<"Exercise", 'String'>
    readonly thumbnailUrl: FieldRef<"Exercise", 'String'>
    readonly primaryMuscles: FieldRef<"Exercise", 'String'>
    readonly secondaryMuscles: FieldRef<"Exercise", 'String'>
    readonly difficulty: FieldRef<"Exercise", 'String'>
    readonly instructions: FieldRef<"Exercise", 'String'>
    readonly tips: FieldRef<"Exercise", 'String'>
    readonly commonMistakes: FieldRef<"Exercise", 'String'>
    readonly isCompound: FieldRef<"Exercise", 'Boolean'>
    readonly isUnilateral: FieldRef<"Exercise", 'Boolean'>
    readonly forceType: FieldRef<"Exercise", 'String'>
    readonly mechanic: FieldRef<"Exercise", 'String'>
    readonly metValue: FieldRef<"Exercise", 'Float'>
    readonly is1RMEligible: FieldRef<"Exercise", 'Boolean'>
    readonly createdAt: FieldRef<"Exercise", 'DateTime'>
    readonly updatedAt: FieldRef<"Exercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }

  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
  }

  /**
   * Exercise createManyAndReturn
   */
  export type ExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
  }

  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
  }

  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }

  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
  }

  /**
   * Exercise.workoutExercises
   */
  export type Exercise$workoutExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    where?: WorkoutExerciseWhereInput
    orderBy?: WorkoutExerciseOrderByWithRelationInput | WorkoutExerciseOrderByWithRelationInput[]
    cursor?: WorkoutExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutExerciseScalarFieldEnum | WorkoutExerciseScalarFieldEnum[]
  }

  /**
   * Exercise.personalRecords
   */
  export type Exercise$personalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    where?: PersonalRecordWhereInput
    orderBy?: PersonalRecordOrderByWithRelationInput | PersonalRecordOrderByWithRelationInput[]
    cursor?: PersonalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalRecordScalarFieldEnum | PersonalRecordScalarFieldEnum[]
  }

  /**
   * Exercise without action
   */
  export type ExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
  }


  /**
   * Model StrengthWorkout
   */

  export type AggregateStrengthWorkout = {
    _count: StrengthWorkoutCountAggregateOutputType | null
    _avg: StrengthWorkoutAvgAggregateOutputType | null
    _sum: StrengthWorkoutSumAggregateOutputType | null
    _min: StrengthWorkoutMinAggregateOutputType | null
    _max: StrengthWorkoutMaxAggregateOutputType | null
  }

  export type StrengthWorkoutAvgAggregateOutputType = {
    durationSeconds: number | null
    sessionIntensityRpe: number | null
    totalVolume: number | null
  }

  export type StrengthWorkoutSumAggregateOutputType = {
    durationSeconds: number | null
    sessionIntensityRpe: number | null
    totalVolume: number | null
  }

  export type StrengthWorkoutMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    startedAt: Date | null
    completedAt: Date | null
    durationSeconds: number | null
    sessionIntensityRpe: number | null
    notes: string | null
    totalVolume: number | null
    createdAt: Date | null
  }

  export type StrengthWorkoutMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    startedAt: Date | null
    completedAt: Date | null
    durationSeconds: number | null
    sessionIntensityRpe: number | null
    notes: string | null
    totalVolume: number | null
    createdAt: Date | null
  }

  export type StrengthWorkoutCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    startedAt: number
    completedAt: number
    durationSeconds: number
    sessionIntensityRpe: number
    notes: number
    totalVolume: number
    createdAt: number
    _all: number
  }


  export type StrengthWorkoutAvgAggregateInputType = {
    durationSeconds?: true
    sessionIntensityRpe?: true
    totalVolume?: true
  }

  export type StrengthWorkoutSumAggregateInputType = {
    durationSeconds?: true
    sessionIntensityRpe?: true
    totalVolume?: true
  }

  export type StrengthWorkoutMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    startedAt?: true
    completedAt?: true
    durationSeconds?: true
    sessionIntensityRpe?: true
    notes?: true
    totalVolume?: true
    createdAt?: true
  }

  export type StrengthWorkoutMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    startedAt?: true
    completedAt?: true
    durationSeconds?: true
    sessionIntensityRpe?: true
    notes?: true
    totalVolume?: true
    createdAt?: true
  }

  export type StrengthWorkoutCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    startedAt?: true
    completedAt?: true
    durationSeconds?: true
    sessionIntensityRpe?: true
    notes?: true
    totalVolume?: true
    createdAt?: true
    _all?: true
  }

  export type StrengthWorkoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrengthWorkout to aggregate.
     */
    where?: StrengthWorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrengthWorkouts to fetch.
     */
    orderBy?: StrengthWorkoutOrderByWithRelationInput | StrengthWorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StrengthWorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrengthWorkouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrengthWorkouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StrengthWorkouts
    **/
    _count?: true | StrengthWorkoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StrengthWorkoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StrengthWorkoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrengthWorkoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrengthWorkoutMaxAggregateInputType
  }

  export type GetStrengthWorkoutAggregateType<T extends StrengthWorkoutAggregateArgs> = {
        [P in keyof T & keyof AggregateStrengthWorkout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrengthWorkout[P]>
      : GetScalarType<T[P], AggregateStrengthWorkout[P]>
  }




  export type StrengthWorkoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrengthWorkoutWhereInput
    orderBy?: StrengthWorkoutOrderByWithAggregationInput | StrengthWorkoutOrderByWithAggregationInput[]
    by: StrengthWorkoutScalarFieldEnum[] | StrengthWorkoutScalarFieldEnum
    having?: StrengthWorkoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrengthWorkoutCountAggregateInputType | true
    _avg?: StrengthWorkoutAvgAggregateInputType
    _sum?: StrengthWorkoutSumAggregateInputType
    _min?: StrengthWorkoutMinAggregateInputType
    _max?: StrengthWorkoutMaxAggregateInputType
  }

  export type StrengthWorkoutGroupByOutputType = {
    id: string
    userId: string
    name: string | null
    startedAt: Date
    completedAt: Date | null
    durationSeconds: number | null
    sessionIntensityRpe: number | null
    notes: string | null
    totalVolume: number | null
    createdAt: Date
    _count: StrengthWorkoutCountAggregateOutputType | null
    _avg: StrengthWorkoutAvgAggregateOutputType | null
    _sum: StrengthWorkoutSumAggregateOutputType | null
    _min: StrengthWorkoutMinAggregateOutputType | null
    _max: StrengthWorkoutMaxAggregateOutputType | null
  }

  type GetStrengthWorkoutGroupByPayload<T extends StrengthWorkoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StrengthWorkoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrengthWorkoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrengthWorkoutGroupByOutputType[P]>
            : GetScalarType<T[P], StrengthWorkoutGroupByOutputType[P]>
        }
      >
    >


  export type StrengthWorkoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationSeconds?: boolean
    sessionIntensityRpe?: boolean
    notes?: boolean
    totalVolume?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercises?: boolean | StrengthWorkout$exercisesArgs<ExtArgs>
    _count?: boolean | StrengthWorkoutCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strengthWorkout"]>

  export type StrengthWorkoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationSeconds?: boolean
    sessionIntensityRpe?: boolean
    notes?: boolean
    totalVolume?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strengthWorkout"]>

  export type StrengthWorkoutSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationSeconds?: boolean
    sessionIntensityRpe?: boolean
    notes?: boolean
    totalVolume?: boolean
    createdAt?: boolean
  }

  export type StrengthWorkoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercises?: boolean | StrengthWorkout$exercisesArgs<ExtArgs>
    _count?: boolean | StrengthWorkoutCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StrengthWorkoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StrengthWorkoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StrengthWorkout"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      exercises: Prisma.$WorkoutExercisePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string | null
      startedAt: Date
      completedAt: Date | null
      durationSeconds: number | null
      sessionIntensityRpe: number | null
      notes: string | null
      totalVolume: number | null
      createdAt: Date
    }, ExtArgs["result"]["strengthWorkout"]>
    composites: {}
  }

  type StrengthWorkoutGetPayload<S extends boolean | null | undefined | StrengthWorkoutDefaultArgs> = $Result.GetResult<Prisma.$StrengthWorkoutPayload, S>

  type StrengthWorkoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StrengthWorkoutFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StrengthWorkoutCountAggregateInputType | true
    }

  export interface StrengthWorkoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StrengthWorkout'], meta: { name: 'StrengthWorkout' } }
    /**
     * Find zero or one StrengthWorkout that matches the filter.
     * @param {StrengthWorkoutFindUniqueArgs} args - Arguments to find a StrengthWorkout
     * @example
     * // Get one StrengthWorkout
     * const strengthWorkout = await prisma.strengthWorkout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StrengthWorkoutFindUniqueArgs>(args: SelectSubset<T, StrengthWorkoutFindUniqueArgs<ExtArgs>>): Prisma__StrengthWorkoutClient<$Result.GetResult<Prisma.$StrengthWorkoutPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StrengthWorkout that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StrengthWorkoutFindUniqueOrThrowArgs} args - Arguments to find a StrengthWorkout
     * @example
     * // Get one StrengthWorkout
     * const strengthWorkout = await prisma.strengthWorkout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StrengthWorkoutFindUniqueOrThrowArgs>(args: SelectSubset<T, StrengthWorkoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StrengthWorkoutClient<$Result.GetResult<Prisma.$StrengthWorkoutPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StrengthWorkout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthWorkoutFindFirstArgs} args - Arguments to find a StrengthWorkout
     * @example
     * // Get one StrengthWorkout
     * const strengthWorkout = await prisma.strengthWorkout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StrengthWorkoutFindFirstArgs>(args?: SelectSubset<T, StrengthWorkoutFindFirstArgs<ExtArgs>>): Prisma__StrengthWorkoutClient<$Result.GetResult<Prisma.$StrengthWorkoutPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StrengthWorkout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthWorkoutFindFirstOrThrowArgs} args - Arguments to find a StrengthWorkout
     * @example
     * // Get one StrengthWorkout
     * const strengthWorkout = await prisma.strengthWorkout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StrengthWorkoutFindFirstOrThrowArgs>(args?: SelectSubset<T, StrengthWorkoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__StrengthWorkoutClient<$Result.GetResult<Prisma.$StrengthWorkoutPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StrengthWorkouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthWorkoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StrengthWorkouts
     * const strengthWorkouts = await prisma.strengthWorkout.findMany()
     * 
     * // Get first 10 StrengthWorkouts
     * const strengthWorkouts = await prisma.strengthWorkout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strengthWorkoutWithIdOnly = await prisma.strengthWorkout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StrengthWorkoutFindManyArgs>(args?: SelectSubset<T, StrengthWorkoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrengthWorkoutPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StrengthWorkout.
     * @param {StrengthWorkoutCreateArgs} args - Arguments to create a StrengthWorkout.
     * @example
     * // Create one StrengthWorkout
     * const StrengthWorkout = await prisma.strengthWorkout.create({
     *   data: {
     *     // ... data to create a StrengthWorkout
     *   }
     * })
     * 
     */
    create<T extends StrengthWorkoutCreateArgs>(args: SelectSubset<T, StrengthWorkoutCreateArgs<ExtArgs>>): Prisma__StrengthWorkoutClient<$Result.GetResult<Prisma.$StrengthWorkoutPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StrengthWorkouts.
     * @param {StrengthWorkoutCreateManyArgs} args - Arguments to create many StrengthWorkouts.
     * @example
     * // Create many StrengthWorkouts
     * const strengthWorkout = await prisma.strengthWorkout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StrengthWorkoutCreateManyArgs>(args?: SelectSubset<T, StrengthWorkoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StrengthWorkouts and returns the data saved in the database.
     * @param {StrengthWorkoutCreateManyAndReturnArgs} args - Arguments to create many StrengthWorkouts.
     * @example
     * // Create many StrengthWorkouts
     * const strengthWorkout = await prisma.strengthWorkout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StrengthWorkouts and only return the `id`
     * const strengthWorkoutWithIdOnly = await prisma.strengthWorkout.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StrengthWorkoutCreateManyAndReturnArgs>(args?: SelectSubset<T, StrengthWorkoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrengthWorkoutPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StrengthWorkout.
     * @param {StrengthWorkoutDeleteArgs} args - Arguments to delete one StrengthWorkout.
     * @example
     * // Delete one StrengthWorkout
     * const StrengthWorkout = await prisma.strengthWorkout.delete({
     *   where: {
     *     // ... filter to delete one StrengthWorkout
     *   }
     * })
     * 
     */
    delete<T extends StrengthWorkoutDeleteArgs>(args: SelectSubset<T, StrengthWorkoutDeleteArgs<ExtArgs>>): Prisma__StrengthWorkoutClient<$Result.GetResult<Prisma.$StrengthWorkoutPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StrengthWorkout.
     * @param {StrengthWorkoutUpdateArgs} args - Arguments to update one StrengthWorkout.
     * @example
     * // Update one StrengthWorkout
     * const strengthWorkout = await prisma.strengthWorkout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StrengthWorkoutUpdateArgs>(args: SelectSubset<T, StrengthWorkoutUpdateArgs<ExtArgs>>): Prisma__StrengthWorkoutClient<$Result.GetResult<Prisma.$StrengthWorkoutPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StrengthWorkouts.
     * @param {StrengthWorkoutDeleteManyArgs} args - Arguments to filter StrengthWorkouts to delete.
     * @example
     * // Delete a few StrengthWorkouts
     * const { count } = await prisma.strengthWorkout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StrengthWorkoutDeleteManyArgs>(args?: SelectSubset<T, StrengthWorkoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StrengthWorkouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthWorkoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StrengthWorkouts
     * const strengthWorkout = await prisma.strengthWorkout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StrengthWorkoutUpdateManyArgs>(args: SelectSubset<T, StrengthWorkoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StrengthWorkout.
     * @param {StrengthWorkoutUpsertArgs} args - Arguments to update or create a StrengthWorkout.
     * @example
     * // Update or create a StrengthWorkout
     * const strengthWorkout = await prisma.strengthWorkout.upsert({
     *   create: {
     *     // ... data to create a StrengthWorkout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StrengthWorkout we want to update
     *   }
     * })
     */
    upsert<T extends StrengthWorkoutUpsertArgs>(args: SelectSubset<T, StrengthWorkoutUpsertArgs<ExtArgs>>): Prisma__StrengthWorkoutClient<$Result.GetResult<Prisma.$StrengthWorkoutPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StrengthWorkouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthWorkoutCountArgs} args - Arguments to filter StrengthWorkouts to count.
     * @example
     * // Count the number of StrengthWorkouts
     * const count = await prisma.strengthWorkout.count({
     *   where: {
     *     // ... the filter for the StrengthWorkouts we want to count
     *   }
     * })
    **/
    count<T extends StrengthWorkoutCountArgs>(
      args?: Subset<T, StrengthWorkoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrengthWorkoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StrengthWorkout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthWorkoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrengthWorkoutAggregateArgs>(args: Subset<T, StrengthWorkoutAggregateArgs>): Prisma.PrismaPromise<GetStrengthWorkoutAggregateType<T>>

    /**
     * Group by StrengthWorkout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthWorkoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrengthWorkoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrengthWorkoutGroupByArgs['orderBy'] }
        : { orderBy?: StrengthWorkoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrengthWorkoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrengthWorkoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StrengthWorkout model
   */
  readonly fields: StrengthWorkoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StrengthWorkout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StrengthWorkoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exercises<T extends StrengthWorkout$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, StrengthWorkout$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StrengthWorkout model
   */ 
  interface StrengthWorkoutFieldRefs {
    readonly id: FieldRef<"StrengthWorkout", 'String'>
    readonly userId: FieldRef<"StrengthWorkout", 'String'>
    readonly name: FieldRef<"StrengthWorkout", 'String'>
    readonly startedAt: FieldRef<"StrengthWorkout", 'DateTime'>
    readonly completedAt: FieldRef<"StrengthWorkout", 'DateTime'>
    readonly durationSeconds: FieldRef<"StrengthWorkout", 'Int'>
    readonly sessionIntensityRpe: FieldRef<"StrengthWorkout", 'Int'>
    readonly notes: FieldRef<"StrengthWorkout", 'String'>
    readonly totalVolume: FieldRef<"StrengthWorkout", 'Float'>
    readonly createdAt: FieldRef<"StrengthWorkout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StrengthWorkout findUnique
   */
  export type StrengthWorkoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkout
     */
    select?: StrengthWorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthWorkoutInclude<ExtArgs> | null
    /**
     * Filter, which StrengthWorkout to fetch.
     */
    where: StrengthWorkoutWhereUniqueInput
  }

  /**
   * StrengthWorkout findUniqueOrThrow
   */
  export type StrengthWorkoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkout
     */
    select?: StrengthWorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthWorkoutInclude<ExtArgs> | null
    /**
     * Filter, which StrengthWorkout to fetch.
     */
    where: StrengthWorkoutWhereUniqueInput
  }

  /**
   * StrengthWorkout findFirst
   */
  export type StrengthWorkoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkout
     */
    select?: StrengthWorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthWorkoutInclude<ExtArgs> | null
    /**
     * Filter, which StrengthWorkout to fetch.
     */
    where?: StrengthWorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrengthWorkouts to fetch.
     */
    orderBy?: StrengthWorkoutOrderByWithRelationInput | StrengthWorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrengthWorkouts.
     */
    cursor?: StrengthWorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrengthWorkouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrengthWorkouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrengthWorkouts.
     */
    distinct?: StrengthWorkoutScalarFieldEnum | StrengthWorkoutScalarFieldEnum[]
  }

  /**
   * StrengthWorkout findFirstOrThrow
   */
  export type StrengthWorkoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkout
     */
    select?: StrengthWorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthWorkoutInclude<ExtArgs> | null
    /**
     * Filter, which StrengthWorkout to fetch.
     */
    where?: StrengthWorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrengthWorkouts to fetch.
     */
    orderBy?: StrengthWorkoutOrderByWithRelationInput | StrengthWorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrengthWorkouts.
     */
    cursor?: StrengthWorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrengthWorkouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrengthWorkouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrengthWorkouts.
     */
    distinct?: StrengthWorkoutScalarFieldEnum | StrengthWorkoutScalarFieldEnum[]
  }

  /**
   * StrengthWorkout findMany
   */
  export type StrengthWorkoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkout
     */
    select?: StrengthWorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthWorkoutInclude<ExtArgs> | null
    /**
     * Filter, which StrengthWorkouts to fetch.
     */
    where?: StrengthWorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrengthWorkouts to fetch.
     */
    orderBy?: StrengthWorkoutOrderByWithRelationInput | StrengthWorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StrengthWorkouts.
     */
    cursor?: StrengthWorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrengthWorkouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrengthWorkouts.
     */
    skip?: number
    distinct?: StrengthWorkoutScalarFieldEnum | StrengthWorkoutScalarFieldEnum[]
  }

  /**
   * StrengthWorkout create
   */
  export type StrengthWorkoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkout
     */
    select?: StrengthWorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthWorkoutInclude<ExtArgs> | null
    /**
     * The data needed to create a StrengthWorkout.
     */
    data: XOR<StrengthWorkoutCreateInput, StrengthWorkoutUncheckedCreateInput>
  }

  /**
   * StrengthWorkout createMany
   */
  export type StrengthWorkoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StrengthWorkouts.
     */
    data: StrengthWorkoutCreateManyInput | StrengthWorkoutCreateManyInput[]
  }

  /**
   * StrengthWorkout createManyAndReturn
   */
  export type StrengthWorkoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkout
     */
    select?: StrengthWorkoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StrengthWorkouts.
     */
    data: StrengthWorkoutCreateManyInput | StrengthWorkoutCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthWorkoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StrengthWorkout update
   */
  export type StrengthWorkoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkout
     */
    select?: StrengthWorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthWorkoutInclude<ExtArgs> | null
    /**
     * The data needed to update a StrengthWorkout.
     */
    data: XOR<StrengthWorkoutUpdateInput, StrengthWorkoutUncheckedUpdateInput>
    /**
     * Choose, which StrengthWorkout to update.
     */
    where: StrengthWorkoutWhereUniqueInput
  }

  /**
   * StrengthWorkout updateMany
   */
  export type StrengthWorkoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StrengthWorkouts.
     */
    data: XOR<StrengthWorkoutUpdateManyMutationInput, StrengthWorkoutUncheckedUpdateManyInput>
    /**
     * Filter which StrengthWorkouts to update
     */
    where?: StrengthWorkoutWhereInput
  }

  /**
   * StrengthWorkout upsert
   */
  export type StrengthWorkoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkout
     */
    select?: StrengthWorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthWorkoutInclude<ExtArgs> | null
    /**
     * The filter to search for the StrengthWorkout to update in case it exists.
     */
    where: StrengthWorkoutWhereUniqueInput
    /**
     * In case the StrengthWorkout found by the `where` argument doesn't exist, create a new StrengthWorkout with this data.
     */
    create: XOR<StrengthWorkoutCreateInput, StrengthWorkoutUncheckedCreateInput>
    /**
     * In case the StrengthWorkout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StrengthWorkoutUpdateInput, StrengthWorkoutUncheckedUpdateInput>
  }

  /**
   * StrengthWorkout delete
   */
  export type StrengthWorkoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkout
     */
    select?: StrengthWorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthWorkoutInclude<ExtArgs> | null
    /**
     * Filter which StrengthWorkout to delete.
     */
    where: StrengthWorkoutWhereUniqueInput
  }

  /**
   * StrengthWorkout deleteMany
   */
  export type StrengthWorkoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrengthWorkouts to delete
     */
    where?: StrengthWorkoutWhereInput
  }

  /**
   * StrengthWorkout.exercises
   */
  export type StrengthWorkout$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    where?: WorkoutExerciseWhereInput
    orderBy?: WorkoutExerciseOrderByWithRelationInput | WorkoutExerciseOrderByWithRelationInput[]
    cursor?: WorkoutExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutExerciseScalarFieldEnum | WorkoutExerciseScalarFieldEnum[]
  }

  /**
   * StrengthWorkout without action
   */
  export type StrengthWorkoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthWorkout
     */
    select?: StrengthWorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthWorkoutInclude<ExtArgs> | null
  }


  /**
   * Model WorkoutExercise
   */

  export type AggregateWorkoutExercise = {
    _count: WorkoutExerciseCountAggregateOutputType | null
    _avg: WorkoutExerciseAvgAggregateOutputType | null
    _sum: WorkoutExerciseSumAggregateOutputType | null
    _min: WorkoutExerciseMinAggregateOutputType | null
    _max: WorkoutExerciseMaxAggregateOutputType | null
  }

  export type WorkoutExerciseAvgAggregateOutputType = {
    positionOrder: number | null
  }

  export type WorkoutExerciseSumAggregateOutputType = {
    positionOrder: number | null
  }

  export type WorkoutExerciseMinAggregateOutputType = {
    id: string | null
    workoutId: string | null
    exerciseId: string | null
    positionOrder: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type WorkoutExerciseMaxAggregateOutputType = {
    id: string | null
    workoutId: string | null
    exerciseId: string | null
    positionOrder: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type WorkoutExerciseCountAggregateOutputType = {
    id: number
    workoutId: number
    exerciseId: number
    positionOrder: number
    notes: number
    createdAt: number
    _all: number
  }


  export type WorkoutExerciseAvgAggregateInputType = {
    positionOrder?: true
  }

  export type WorkoutExerciseSumAggregateInputType = {
    positionOrder?: true
  }

  export type WorkoutExerciseMinAggregateInputType = {
    id?: true
    workoutId?: true
    exerciseId?: true
    positionOrder?: true
    notes?: true
    createdAt?: true
  }

  export type WorkoutExerciseMaxAggregateInputType = {
    id?: true
    workoutId?: true
    exerciseId?: true
    positionOrder?: true
    notes?: true
    createdAt?: true
  }

  export type WorkoutExerciseCountAggregateInputType = {
    id?: true
    workoutId?: true
    exerciseId?: true
    positionOrder?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type WorkoutExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutExercise to aggregate.
     */
    where?: WorkoutExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutExercises to fetch.
     */
    orderBy?: WorkoutExerciseOrderByWithRelationInput | WorkoutExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutExercises
    **/
    _count?: true | WorkoutExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutExerciseMaxAggregateInputType
  }

  export type GetWorkoutExerciseAggregateType<T extends WorkoutExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutExercise[P]>
      : GetScalarType<T[P], AggregateWorkoutExercise[P]>
  }




  export type WorkoutExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutExerciseWhereInput
    orderBy?: WorkoutExerciseOrderByWithAggregationInput | WorkoutExerciseOrderByWithAggregationInput[]
    by: WorkoutExerciseScalarFieldEnum[] | WorkoutExerciseScalarFieldEnum
    having?: WorkoutExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutExerciseCountAggregateInputType | true
    _avg?: WorkoutExerciseAvgAggregateInputType
    _sum?: WorkoutExerciseSumAggregateInputType
    _min?: WorkoutExerciseMinAggregateInputType
    _max?: WorkoutExerciseMaxAggregateInputType
  }

  export type WorkoutExerciseGroupByOutputType = {
    id: string
    workoutId: string
    exerciseId: string
    positionOrder: number
    notes: string | null
    createdAt: Date
    _count: WorkoutExerciseCountAggregateOutputType | null
    _avg: WorkoutExerciseAvgAggregateOutputType | null
    _sum: WorkoutExerciseSumAggregateOutputType | null
    _min: WorkoutExerciseMinAggregateOutputType | null
    _max: WorkoutExerciseMaxAggregateOutputType | null
  }

  type GetWorkoutExerciseGroupByPayload<T extends WorkoutExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutExerciseGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutId?: boolean
    exerciseId?: boolean
    positionOrder?: boolean
    notes?: boolean
    createdAt?: boolean
    workout?: boolean | StrengthWorkoutDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    sets?: boolean | WorkoutExercise$setsArgs<ExtArgs>
    _count?: boolean | WorkoutExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutExercise"]>

  export type WorkoutExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutId?: boolean
    exerciseId?: boolean
    positionOrder?: boolean
    notes?: boolean
    createdAt?: boolean
    workout?: boolean | StrengthWorkoutDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutExercise"]>

  export type WorkoutExerciseSelectScalar = {
    id?: boolean
    workoutId?: boolean
    exerciseId?: boolean
    positionOrder?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type WorkoutExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout?: boolean | StrengthWorkoutDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    sets?: boolean | WorkoutExercise$setsArgs<ExtArgs>
    _count?: boolean | WorkoutExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkoutExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout?: boolean | StrengthWorkoutDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }

  export type $WorkoutExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkoutExercise"
    objects: {
      workout: Prisma.$StrengthWorkoutPayload<ExtArgs>
      exercise: Prisma.$ExercisePayload<ExtArgs>
      sets: Prisma.$WorkoutSetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workoutId: string
      exerciseId: string
      positionOrder: number
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["workoutExercise"]>
    composites: {}
  }

  type WorkoutExerciseGetPayload<S extends boolean | null | undefined | WorkoutExerciseDefaultArgs> = $Result.GetResult<Prisma.$WorkoutExercisePayload, S>

  type WorkoutExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkoutExerciseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkoutExerciseCountAggregateInputType | true
    }

  export interface WorkoutExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkoutExercise'], meta: { name: 'WorkoutExercise' } }
    /**
     * Find zero or one WorkoutExercise that matches the filter.
     * @param {WorkoutExerciseFindUniqueArgs} args - Arguments to find a WorkoutExercise
     * @example
     * // Get one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutExerciseFindUniqueArgs>(args: SelectSubset<T, WorkoutExerciseFindUniqueArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkoutExercise that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkoutExerciseFindUniqueOrThrowArgs} args - Arguments to find a WorkoutExercise
     * @example
     * // Get one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkoutExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseFindFirstArgs} args - Arguments to find a WorkoutExercise
     * @example
     * // Get one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutExerciseFindFirstArgs>(args?: SelectSubset<T, WorkoutExerciseFindFirstArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkoutExercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseFindFirstOrThrowArgs} args - Arguments to find a WorkoutExercise
     * @example
     * // Get one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkoutExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutExercises
     * const workoutExercises = await prisma.workoutExercise.findMany()
     * 
     * // Get first 10 WorkoutExercises
     * const workoutExercises = await prisma.workoutExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutExerciseWithIdOnly = await prisma.workoutExercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutExerciseFindManyArgs>(args?: SelectSubset<T, WorkoutExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkoutExercise.
     * @param {WorkoutExerciseCreateArgs} args - Arguments to create a WorkoutExercise.
     * @example
     * // Create one WorkoutExercise
     * const WorkoutExercise = await prisma.workoutExercise.create({
     *   data: {
     *     // ... data to create a WorkoutExercise
     *   }
     * })
     * 
     */
    create<T extends WorkoutExerciseCreateArgs>(args: SelectSubset<T, WorkoutExerciseCreateArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkoutExercises.
     * @param {WorkoutExerciseCreateManyArgs} args - Arguments to create many WorkoutExercises.
     * @example
     * // Create many WorkoutExercises
     * const workoutExercise = await prisma.workoutExercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutExerciseCreateManyArgs>(args?: SelectSubset<T, WorkoutExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkoutExercises and returns the data saved in the database.
     * @param {WorkoutExerciseCreateManyAndReturnArgs} args - Arguments to create many WorkoutExercises.
     * @example
     * // Create many WorkoutExercises
     * const workoutExercise = await prisma.workoutExercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkoutExercises and only return the `id`
     * const workoutExerciseWithIdOnly = await prisma.workoutExercise.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkoutExercise.
     * @param {WorkoutExerciseDeleteArgs} args - Arguments to delete one WorkoutExercise.
     * @example
     * // Delete one WorkoutExercise
     * const WorkoutExercise = await prisma.workoutExercise.delete({
     *   where: {
     *     // ... filter to delete one WorkoutExercise
     *   }
     * })
     * 
     */
    delete<T extends WorkoutExerciseDeleteArgs>(args: SelectSubset<T, WorkoutExerciseDeleteArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkoutExercise.
     * @param {WorkoutExerciseUpdateArgs} args - Arguments to update one WorkoutExercise.
     * @example
     * // Update one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutExerciseUpdateArgs>(args: SelectSubset<T, WorkoutExerciseUpdateArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkoutExercises.
     * @param {WorkoutExerciseDeleteManyArgs} args - Arguments to filter WorkoutExercises to delete.
     * @example
     * // Delete a few WorkoutExercises
     * const { count } = await prisma.workoutExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutExerciseDeleteManyArgs>(args?: SelectSubset<T, WorkoutExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutExercises
     * const workoutExercise = await prisma.workoutExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutExerciseUpdateManyArgs>(args: SelectSubset<T, WorkoutExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkoutExercise.
     * @param {WorkoutExerciseUpsertArgs} args - Arguments to update or create a WorkoutExercise.
     * @example
     * // Update or create a WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.upsert({
     *   create: {
     *     // ... data to create a WorkoutExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutExercise we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutExerciseUpsertArgs>(args: SelectSubset<T, WorkoutExerciseUpsertArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkoutExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseCountArgs} args - Arguments to filter WorkoutExercises to count.
     * @example
     * // Count the number of WorkoutExercises
     * const count = await prisma.workoutExercise.count({
     *   where: {
     *     // ... the filter for the WorkoutExercises we want to count
     *   }
     * })
    **/
    count<T extends WorkoutExerciseCountArgs>(
      args?: Subset<T, WorkoutExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutExerciseAggregateArgs>(args: Subset<T, WorkoutExerciseAggregateArgs>): Prisma.PrismaPromise<GetWorkoutExerciseAggregateType<T>>

    /**
     * Group by WorkoutExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutExerciseGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkoutExercise model
   */
  readonly fields: WorkoutExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workout<T extends StrengthWorkoutDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StrengthWorkoutDefaultArgs<ExtArgs>>): Prisma__StrengthWorkoutClient<$Result.GetResult<Prisma.$StrengthWorkoutPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sets<T extends WorkoutExercise$setsArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutExercise$setsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkoutExercise model
   */ 
  interface WorkoutExerciseFieldRefs {
    readonly id: FieldRef<"WorkoutExercise", 'String'>
    readonly workoutId: FieldRef<"WorkoutExercise", 'String'>
    readonly exerciseId: FieldRef<"WorkoutExercise", 'String'>
    readonly positionOrder: FieldRef<"WorkoutExercise", 'Int'>
    readonly notes: FieldRef<"WorkoutExercise", 'String'>
    readonly createdAt: FieldRef<"WorkoutExercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkoutExercise findUnique
   */
  export type WorkoutExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutExercise to fetch.
     */
    where: WorkoutExerciseWhereUniqueInput
  }

  /**
   * WorkoutExercise findUniqueOrThrow
   */
  export type WorkoutExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutExercise to fetch.
     */
    where: WorkoutExerciseWhereUniqueInput
  }

  /**
   * WorkoutExercise findFirst
   */
  export type WorkoutExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutExercise to fetch.
     */
    where?: WorkoutExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutExercises to fetch.
     */
    orderBy?: WorkoutExerciseOrderByWithRelationInput | WorkoutExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutExercises.
     */
    cursor?: WorkoutExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutExercises.
     */
    distinct?: WorkoutExerciseScalarFieldEnum | WorkoutExerciseScalarFieldEnum[]
  }

  /**
   * WorkoutExercise findFirstOrThrow
   */
  export type WorkoutExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutExercise to fetch.
     */
    where?: WorkoutExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutExercises to fetch.
     */
    orderBy?: WorkoutExerciseOrderByWithRelationInput | WorkoutExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutExercises.
     */
    cursor?: WorkoutExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutExercises.
     */
    distinct?: WorkoutExerciseScalarFieldEnum | WorkoutExerciseScalarFieldEnum[]
  }

  /**
   * WorkoutExercise findMany
   */
  export type WorkoutExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutExercises to fetch.
     */
    where?: WorkoutExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutExercises to fetch.
     */
    orderBy?: WorkoutExerciseOrderByWithRelationInput | WorkoutExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutExercises.
     */
    cursor?: WorkoutExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutExercises.
     */
    skip?: number
    distinct?: WorkoutExerciseScalarFieldEnum | WorkoutExerciseScalarFieldEnum[]
  }

  /**
   * WorkoutExercise create
   */
  export type WorkoutExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkoutExercise.
     */
    data: XOR<WorkoutExerciseCreateInput, WorkoutExerciseUncheckedCreateInput>
  }

  /**
   * WorkoutExercise createMany
   */
  export type WorkoutExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkoutExercises.
     */
    data: WorkoutExerciseCreateManyInput | WorkoutExerciseCreateManyInput[]
  }

  /**
   * WorkoutExercise createManyAndReturn
   */
  export type WorkoutExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkoutExercises.
     */
    data: WorkoutExerciseCreateManyInput | WorkoutExerciseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutExercise update
   */
  export type WorkoutExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkoutExercise.
     */
    data: XOR<WorkoutExerciseUpdateInput, WorkoutExerciseUncheckedUpdateInput>
    /**
     * Choose, which WorkoutExercise to update.
     */
    where: WorkoutExerciseWhereUniqueInput
  }

  /**
   * WorkoutExercise updateMany
   */
  export type WorkoutExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkoutExercises.
     */
    data: XOR<WorkoutExerciseUpdateManyMutationInput, WorkoutExerciseUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutExercises to update
     */
    where?: WorkoutExerciseWhereInput
  }

  /**
   * WorkoutExercise upsert
   */
  export type WorkoutExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkoutExercise to update in case it exists.
     */
    where: WorkoutExerciseWhereUniqueInput
    /**
     * In case the WorkoutExercise found by the `where` argument doesn't exist, create a new WorkoutExercise with this data.
     */
    create: XOR<WorkoutExerciseCreateInput, WorkoutExerciseUncheckedCreateInput>
    /**
     * In case the WorkoutExercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutExerciseUpdateInput, WorkoutExerciseUncheckedUpdateInput>
  }

  /**
   * WorkoutExercise delete
   */
  export type WorkoutExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
    /**
     * Filter which WorkoutExercise to delete.
     */
    where: WorkoutExerciseWhereUniqueInput
  }

  /**
   * WorkoutExercise deleteMany
   */
  export type WorkoutExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutExercises to delete
     */
    where?: WorkoutExerciseWhereInput
  }

  /**
   * WorkoutExercise.sets
   */
  export type WorkoutExercise$setsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    where?: WorkoutSetWhereInput
    orderBy?: WorkoutSetOrderByWithRelationInput | WorkoutSetOrderByWithRelationInput[]
    cursor?: WorkoutSetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutSetScalarFieldEnum | WorkoutSetScalarFieldEnum[]
  }

  /**
   * WorkoutExercise without action
   */
  export type WorkoutExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     */
    select?: WorkoutExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutExerciseInclude<ExtArgs> | null
  }


  /**
   * Model WorkoutSet
   */

  export type AggregateWorkoutSet = {
    _count: WorkoutSetCountAggregateOutputType | null
    _avg: WorkoutSetAvgAggregateOutputType | null
    _sum: WorkoutSetSumAggregateOutputType | null
    _min: WorkoutSetMinAggregateOutputType | null
    _max: WorkoutSetMaxAggregateOutputType | null
  }

  export type WorkoutSetAvgAggregateOutputType = {
    setNumber: number | null
    reps: number | null
    weight: number | null
    rpe: number | null
    restSeconds: number | null
    durationSeconds: number | null
    distanceMeters: number | null
  }

  export type WorkoutSetSumAggregateOutputType = {
    setNumber: number | null
    reps: number | null
    weight: number | null
    rpe: number | null
    restSeconds: number | null
    durationSeconds: number | null
    distanceMeters: number | null
  }

  export type WorkoutSetMinAggregateOutputType = {
    id: string | null
    workoutExerciseId: string | null
    setNumber: number | null
    reps: number | null
    weight: number | null
    weightUnit: string | null
    setType: string | null
    rpe: number | null
    isPr: boolean | null
    completed: boolean | null
    restSeconds: number | null
    durationSeconds: number | null
    distanceMeters: number | null
    createdAt: Date | null
  }

  export type WorkoutSetMaxAggregateOutputType = {
    id: string | null
    workoutExerciseId: string | null
    setNumber: number | null
    reps: number | null
    weight: number | null
    weightUnit: string | null
    setType: string | null
    rpe: number | null
    isPr: boolean | null
    completed: boolean | null
    restSeconds: number | null
    durationSeconds: number | null
    distanceMeters: number | null
    createdAt: Date | null
  }

  export type WorkoutSetCountAggregateOutputType = {
    id: number
    workoutExerciseId: number
    setNumber: number
    reps: number
    weight: number
    weightUnit: number
    setType: number
    rpe: number
    isPr: number
    completed: number
    restSeconds: number
    durationSeconds: number
    distanceMeters: number
    createdAt: number
    _all: number
  }


  export type WorkoutSetAvgAggregateInputType = {
    setNumber?: true
    reps?: true
    weight?: true
    rpe?: true
    restSeconds?: true
    durationSeconds?: true
    distanceMeters?: true
  }

  export type WorkoutSetSumAggregateInputType = {
    setNumber?: true
    reps?: true
    weight?: true
    rpe?: true
    restSeconds?: true
    durationSeconds?: true
    distanceMeters?: true
  }

  export type WorkoutSetMinAggregateInputType = {
    id?: true
    workoutExerciseId?: true
    setNumber?: true
    reps?: true
    weight?: true
    weightUnit?: true
    setType?: true
    rpe?: true
    isPr?: true
    completed?: true
    restSeconds?: true
    durationSeconds?: true
    distanceMeters?: true
    createdAt?: true
  }

  export type WorkoutSetMaxAggregateInputType = {
    id?: true
    workoutExerciseId?: true
    setNumber?: true
    reps?: true
    weight?: true
    weightUnit?: true
    setType?: true
    rpe?: true
    isPr?: true
    completed?: true
    restSeconds?: true
    durationSeconds?: true
    distanceMeters?: true
    createdAt?: true
  }

  export type WorkoutSetCountAggregateInputType = {
    id?: true
    workoutExerciseId?: true
    setNumber?: true
    reps?: true
    weight?: true
    weightUnit?: true
    setType?: true
    rpe?: true
    isPr?: true
    completed?: true
    restSeconds?: true
    durationSeconds?: true
    distanceMeters?: true
    createdAt?: true
    _all?: true
  }

  export type WorkoutSetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutSet to aggregate.
     */
    where?: WorkoutSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSets to fetch.
     */
    orderBy?: WorkoutSetOrderByWithRelationInput | WorkoutSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutSets
    **/
    _count?: true | WorkoutSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutSetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutSetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutSetMaxAggregateInputType
  }

  export type GetWorkoutSetAggregateType<T extends WorkoutSetAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutSet[P]>
      : GetScalarType<T[P], AggregateWorkoutSet[P]>
  }




  export type WorkoutSetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutSetWhereInput
    orderBy?: WorkoutSetOrderByWithAggregationInput | WorkoutSetOrderByWithAggregationInput[]
    by: WorkoutSetScalarFieldEnum[] | WorkoutSetScalarFieldEnum
    having?: WorkoutSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutSetCountAggregateInputType | true
    _avg?: WorkoutSetAvgAggregateInputType
    _sum?: WorkoutSetSumAggregateInputType
    _min?: WorkoutSetMinAggregateInputType
    _max?: WorkoutSetMaxAggregateInputType
  }

  export type WorkoutSetGroupByOutputType = {
    id: string
    workoutExerciseId: string
    setNumber: number
    reps: number | null
    weight: number | null
    weightUnit: string
    setType: string
    rpe: number | null
    isPr: boolean
    completed: boolean
    restSeconds: number | null
    durationSeconds: number | null
    distanceMeters: number | null
    createdAt: Date
    _count: WorkoutSetCountAggregateOutputType | null
    _avg: WorkoutSetAvgAggregateOutputType | null
    _sum: WorkoutSetSumAggregateOutputType | null
    _min: WorkoutSetMinAggregateOutputType | null
    _max: WorkoutSetMaxAggregateOutputType | null
  }

  type GetWorkoutSetGroupByPayload<T extends WorkoutSetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutSetGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutSetGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutSetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutExerciseId?: boolean
    setNumber?: boolean
    reps?: boolean
    weight?: boolean
    weightUnit?: boolean
    setType?: boolean
    rpe?: boolean
    isPr?: boolean
    completed?: boolean
    restSeconds?: boolean
    durationSeconds?: boolean
    distanceMeters?: boolean
    createdAt?: boolean
    workoutExercise?: boolean | WorkoutExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutSet"]>

  export type WorkoutSetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutExerciseId?: boolean
    setNumber?: boolean
    reps?: boolean
    weight?: boolean
    weightUnit?: boolean
    setType?: boolean
    rpe?: boolean
    isPr?: boolean
    completed?: boolean
    restSeconds?: boolean
    durationSeconds?: boolean
    distanceMeters?: boolean
    createdAt?: boolean
    workoutExercise?: boolean | WorkoutExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutSet"]>

  export type WorkoutSetSelectScalar = {
    id?: boolean
    workoutExerciseId?: boolean
    setNumber?: boolean
    reps?: boolean
    weight?: boolean
    weightUnit?: boolean
    setType?: boolean
    rpe?: boolean
    isPr?: boolean
    completed?: boolean
    restSeconds?: boolean
    durationSeconds?: boolean
    distanceMeters?: boolean
    createdAt?: boolean
  }

  export type WorkoutSetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workoutExercise?: boolean | WorkoutExerciseDefaultArgs<ExtArgs>
  }
  export type WorkoutSetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workoutExercise?: boolean | WorkoutExerciseDefaultArgs<ExtArgs>
  }

  export type $WorkoutSetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkoutSet"
    objects: {
      workoutExercise: Prisma.$WorkoutExercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workoutExerciseId: string
      setNumber: number
      reps: number | null
      weight: number | null
      weightUnit: string
      setType: string
      rpe: number | null
      isPr: boolean
      completed: boolean
      restSeconds: number | null
      durationSeconds: number | null
      distanceMeters: number | null
      createdAt: Date
    }, ExtArgs["result"]["workoutSet"]>
    composites: {}
  }

  type WorkoutSetGetPayload<S extends boolean | null | undefined | WorkoutSetDefaultArgs> = $Result.GetResult<Prisma.$WorkoutSetPayload, S>

  type WorkoutSetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkoutSetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkoutSetCountAggregateInputType | true
    }

  export interface WorkoutSetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkoutSet'], meta: { name: 'WorkoutSet' } }
    /**
     * Find zero or one WorkoutSet that matches the filter.
     * @param {WorkoutSetFindUniqueArgs} args - Arguments to find a WorkoutSet
     * @example
     * // Get one WorkoutSet
     * const workoutSet = await prisma.workoutSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutSetFindUniqueArgs>(args: SelectSubset<T, WorkoutSetFindUniqueArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkoutSet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkoutSetFindUniqueOrThrowArgs} args - Arguments to find a WorkoutSet
     * @example
     * // Get one WorkoutSet
     * const workoutSet = await prisma.workoutSet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutSetFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutSetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkoutSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetFindFirstArgs} args - Arguments to find a WorkoutSet
     * @example
     * // Get one WorkoutSet
     * const workoutSet = await prisma.workoutSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutSetFindFirstArgs>(args?: SelectSubset<T, WorkoutSetFindFirstArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkoutSet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetFindFirstOrThrowArgs} args - Arguments to find a WorkoutSet
     * @example
     * // Get one WorkoutSet
     * const workoutSet = await prisma.workoutSet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutSetFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutSetFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkoutSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutSets
     * const workoutSets = await prisma.workoutSet.findMany()
     * 
     * // Get first 10 WorkoutSets
     * const workoutSets = await prisma.workoutSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutSetWithIdOnly = await prisma.workoutSet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutSetFindManyArgs>(args?: SelectSubset<T, WorkoutSetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkoutSet.
     * @param {WorkoutSetCreateArgs} args - Arguments to create a WorkoutSet.
     * @example
     * // Create one WorkoutSet
     * const WorkoutSet = await prisma.workoutSet.create({
     *   data: {
     *     // ... data to create a WorkoutSet
     *   }
     * })
     * 
     */
    create<T extends WorkoutSetCreateArgs>(args: SelectSubset<T, WorkoutSetCreateArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkoutSets.
     * @param {WorkoutSetCreateManyArgs} args - Arguments to create many WorkoutSets.
     * @example
     * // Create many WorkoutSets
     * const workoutSet = await prisma.workoutSet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutSetCreateManyArgs>(args?: SelectSubset<T, WorkoutSetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkoutSets and returns the data saved in the database.
     * @param {WorkoutSetCreateManyAndReturnArgs} args - Arguments to create many WorkoutSets.
     * @example
     * // Create many WorkoutSets
     * const workoutSet = await prisma.workoutSet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkoutSets and only return the `id`
     * const workoutSetWithIdOnly = await prisma.workoutSet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutSetCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutSetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkoutSet.
     * @param {WorkoutSetDeleteArgs} args - Arguments to delete one WorkoutSet.
     * @example
     * // Delete one WorkoutSet
     * const WorkoutSet = await prisma.workoutSet.delete({
     *   where: {
     *     // ... filter to delete one WorkoutSet
     *   }
     * })
     * 
     */
    delete<T extends WorkoutSetDeleteArgs>(args: SelectSubset<T, WorkoutSetDeleteArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkoutSet.
     * @param {WorkoutSetUpdateArgs} args - Arguments to update one WorkoutSet.
     * @example
     * // Update one WorkoutSet
     * const workoutSet = await prisma.workoutSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutSetUpdateArgs>(args: SelectSubset<T, WorkoutSetUpdateArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkoutSets.
     * @param {WorkoutSetDeleteManyArgs} args - Arguments to filter WorkoutSets to delete.
     * @example
     * // Delete a few WorkoutSets
     * const { count } = await prisma.workoutSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutSetDeleteManyArgs>(args?: SelectSubset<T, WorkoutSetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutSets
     * const workoutSet = await prisma.workoutSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutSetUpdateManyArgs>(args: SelectSubset<T, WorkoutSetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkoutSet.
     * @param {WorkoutSetUpsertArgs} args - Arguments to update or create a WorkoutSet.
     * @example
     * // Update or create a WorkoutSet
     * const workoutSet = await prisma.workoutSet.upsert({
     *   create: {
     *     // ... data to create a WorkoutSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutSet we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutSetUpsertArgs>(args: SelectSubset<T, WorkoutSetUpsertArgs<ExtArgs>>): Prisma__WorkoutSetClient<$Result.GetResult<Prisma.$WorkoutSetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkoutSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetCountArgs} args - Arguments to filter WorkoutSets to count.
     * @example
     * // Count the number of WorkoutSets
     * const count = await prisma.workoutSet.count({
     *   where: {
     *     // ... the filter for the WorkoutSets we want to count
     *   }
     * })
    **/
    count<T extends WorkoutSetCountArgs>(
      args?: Subset<T, WorkoutSetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutSetAggregateArgs>(args: Subset<T, WorkoutSetAggregateArgs>): Prisma.PrismaPromise<GetWorkoutSetAggregateType<T>>

    /**
     * Group by WorkoutSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutSetGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutSetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkoutSet model
   */
  readonly fields: WorkoutSetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutSetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workoutExercise<T extends WorkoutExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutExerciseDefaultArgs<ExtArgs>>): Prisma__WorkoutExerciseClient<$Result.GetResult<Prisma.$WorkoutExercisePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkoutSet model
   */ 
  interface WorkoutSetFieldRefs {
    readonly id: FieldRef<"WorkoutSet", 'String'>
    readonly workoutExerciseId: FieldRef<"WorkoutSet", 'String'>
    readonly setNumber: FieldRef<"WorkoutSet", 'Int'>
    readonly reps: FieldRef<"WorkoutSet", 'Int'>
    readonly weight: FieldRef<"WorkoutSet", 'Float'>
    readonly weightUnit: FieldRef<"WorkoutSet", 'String'>
    readonly setType: FieldRef<"WorkoutSet", 'String'>
    readonly rpe: FieldRef<"WorkoutSet", 'Int'>
    readonly isPr: FieldRef<"WorkoutSet", 'Boolean'>
    readonly completed: FieldRef<"WorkoutSet", 'Boolean'>
    readonly restSeconds: FieldRef<"WorkoutSet", 'Int'>
    readonly durationSeconds: FieldRef<"WorkoutSet", 'Int'>
    readonly distanceMeters: FieldRef<"WorkoutSet", 'Float'>
    readonly createdAt: FieldRef<"WorkoutSet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkoutSet findUnique
   */
  export type WorkoutSetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSet to fetch.
     */
    where: WorkoutSetWhereUniqueInput
  }

  /**
   * WorkoutSet findUniqueOrThrow
   */
  export type WorkoutSetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSet to fetch.
     */
    where: WorkoutSetWhereUniqueInput
  }

  /**
   * WorkoutSet findFirst
   */
  export type WorkoutSetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSet to fetch.
     */
    where?: WorkoutSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSets to fetch.
     */
    orderBy?: WorkoutSetOrderByWithRelationInput | WorkoutSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutSets.
     */
    cursor?: WorkoutSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutSets.
     */
    distinct?: WorkoutSetScalarFieldEnum | WorkoutSetScalarFieldEnum[]
  }

  /**
   * WorkoutSet findFirstOrThrow
   */
  export type WorkoutSetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSet to fetch.
     */
    where?: WorkoutSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSets to fetch.
     */
    orderBy?: WorkoutSetOrderByWithRelationInput | WorkoutSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutSets.
     */
    cursor?: WorkoutSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutSets.
     */
    distinct?: WorkoutSetScalarFieldEnum | WorkoutSetScalarFieldEnum[]
  }

  /**
   * WorkoutSet findMany
   */
  export type WorkoutSetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutSets to fetch.
     */
    where?: WorkoutSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSets to fetch.
     */
    orderBy?: WorkoutSetOrderByWithRelationInput | WorkoutSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutSets.
     */
    cursor?: WorkoutSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSets.
     */
    skip?: number
    distinct?: WorkoutSetScalarFieldEnum | WorkoutSetScalarFieldEnum[]
  }

  /**
   * WorkoutSet create
   */
  export type WorkoutSetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkoutSet.
     */
    data: XOR<WorkoutSetCreateInput, WorkoutSetUncheckedCreateInput>
  }

  /**
   * WorkoutSet createMany
   */
  export type WorkoutSetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkoutSets.
     */
    data: WorkoutSetCreateManyInput | WorkoutSetCreateManyInput[]
  }

  /**
   * WorkoutSet createManyAndReturn
   */
  export type WorkoutSetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkoutSets.
     */
    data: WorkoutSetCreateManyInput | WorkoutSetCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutSet update
   */
  export type WorkoutSetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkoutSet.
     */
    data: XOR<WorkoutSetUpdateInput, WorkoutSetUncheckedUpdateInput>
    /**
     * Choose, which WorkoutSet to update.
     */
    where: WorkoutSetWhereUniqueInput
  }

  /**
   * WorkoutSet updateMany
   */
  export type WorkoutSetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkoutSets.
     */
    data: XOR<WorkoutSetUpdateManyMutationInput, WorkoutSetUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutSets to update
     */
    where?: WorkoutSetWhereInput
  }

  /**
   * WorkoutSet upsert
   */
  export type WorkoutSetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkoutSet to update in case it exists.
     */
    where: WorkoutSetWhereUniqueInput
    /**
     * In case the WorkoutSet found by the `where` argument doesn't exist, create a new WorkoutSet with this data.
     */
    create: XOR<WorkoutSetCreateInput, WorkoutSetUncheckedCreateInput>
    /**
     * In case the WorkoutSet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutSetUpdateInput, WorkoutSetUncheckedUpdateInput>
  }

  /**
   * WorkoutSet delete
   */
  export type WorkoutSetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
    /**
     * Filter which WorkoutSet to delete.
     */
    where: WorkoutSetWhereUniqueInput
  }

  /**
   * WorkoutSet deleteMany
   */
  export type WorkoutSetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutSets to delete
     */
    where?: WorkoutSetWhereInput
  }

  /**
   * WorkoutSet without action
   */
  export type WorkoutSetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     */
    select?: WorkoutSetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutSetInclude<ExtArgs> | null
  }


  /**
   * Model PersonalRecord
   */

  export type AggregatePersonalRecord = {
    _count: PersonalRecordCountAggregateOutputType | null
    _avg: PersonalRecordAvgAggregateOutputType | null
    _sum: PersonalRecordSumAggregateOutputType | null
    _min: PersonalRecordMinAggregateOutputType | null
    _max: PersonalRecordMaxAggregateOutputType | null
  }

  export type PersonalRecordAvgAggregateOutputType = {
    value: number | null
  }

  export type PersonalRecordSumAggregateOutputType = {
    value: number | null
  }

  export type PersonalRecordMinAggregateOutputType = {
    id: string | null
    userId: string | null
    exerciseId: string | null
    recordType: string | null
    value: number | null
    weightUnit: string | null
    achievedAt: Date | null
    workoutId: string | null
  }

  export type PersonalRecordMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    exerciseId: string | null
    recordType: string | null
    value: number | null
    weightUnit: string | null
    achievedAt: Date | null
    workoutId: string | null
  }

  export type PersonalRecordCountAggregateOutputType = {
    id: number
    userId: number
    exerciseId: number
    recordType: number
    value: number
    weightUnit: number
    achievedAt: number
    workoutId: number
    _all: number
  }


  export type PersonalRecordAvgAggregateInputType = {
    value?: true
  }

  export type PersonalRecordSumAggregateInputType = {
    value?: true
  }

  export type PersonalRecordMinAggregateInputType = {
    id?: true
    userId?: true
    exerciseId?: true
    recordType?: true
    value?: true
    weightUnit?: true
    achievedAt?: true
    workoutId?: true
  }

  export type PersonalRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    exerciseId?: true
    recordType?: true
    value?: true
    weightUnit?: true
    achievedAt?: true
    workoutId?: true
  }

  export type PersonalRecordCountAggregateInputType = {
    id?: true
    userId?: true
    exerciseId?: true
    recordType?: true
    value?: true
    weightUnit?: true
    achievedAt?: true
    workoutId?: true
    _all?: true
  }

  export type PersonalRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalRecord to aggregate.
     */
    where?: PersonalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalRecords to fetch.
     */
    orderBy?: PersonalRecordOrderByWithRelationInput | PersonalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalRecords
    **/
    _count?: true | PersonalRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonalRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonalRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalRecordMaxAggregateInputType
  }

  export type GetPersonalRecordAggregateType<T extends PersonalRecordAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalRecord[P]>
      : GetScalarType<T[P], AggregatePersonalRecord[P]>
  }




  export type PersonalRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalRecordWhereInput
    orderBy?: PersonalRecordOrderByWithAggregationInput | PersonalRecordOrderByWithAggregationInput[]
    by: PersonalRecordScalarFieldEnum[] | PersonalRecordScalarFieldEnum
    having?: PersonalRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalRecordCountAggregateInputType | true
    _avg?: PersonalRecordAvgAggregateInputType
    _sum?: PersonalRecordSumAggregateInputType
    _min?: PersonalRecordMinAggregateInputType
    _max?: PersonalRecordMaxAggregateInputType
  }

  export type PersonalRecordGroupByOutputType = {
    id: string
    userId: string
    exerciseId: string
    recordType: string
    value: number
    weightUnit: string
    achievedAt: Date
    workoutId: string | null
    _count: PersonalRecordCountAggregateOutputType | null
    _avg: PersonalRecordAvgAggregateOutputType | null
    _sum: PersonalRecordSumAggregateOutputType | null
    _min: PersonalRecordMinAggregateOutputType | null
    _max: PersonalRecordMaxAggregateOutputType | null
  }

  type GetPersonalRecordGroupByPayload<T extends PersonalRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalRecordGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalRecordGroupByOutputType[P]>
        }
      >
    >


  export type PersonalRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    recordType?: boolean
    value?: boolean
    weightUnit?: boolean
    achievedAt?: boolean
    workoutId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalRecord"]>

  export type PersonalRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    recordType?: boolean
    value?: boolean
    weightUnit?: boolean
    achievedAt?: boolean
    workoutId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalRecord"]>

  export type PersonalRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    exerciseId?: boolean
    recordType?: boolean
    value?: boolean
    weightUnit?: boolean
    achievedAt?: boolean
    workoutId?: boolean
  }

  export type PersonalRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type PersonalRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }

  export type $PersonalRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonalRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      exercise: Prisma.$ExercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      exerciseId: string
      recordType: string
      value: number
      weightUnit: string
      achievedAt: Date
      workoutId: string | null
    }, ExtArgs["result"]["personalRecord"]>
    composites: {}
  }

  type PersonalRecordGetPayload<S extends boolean | null | undefined | PersonalRecordDefaultArgs> = $Result.GetResult<Prisma.$PersonalRecordPayload, S>

  type PersonalRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonalRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonalRecordCountAggregateInputType | true
    }

  export interface PersonalRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalRecord'], meta: { name: 'PersonalRecord' } }
    /**
     * Find zero or one PersonalRecord that matches the filter.
     * @param {PersonalRecordFindUniqueArgs} args - Arguments to find a PersonalRecord
     * @example
     * // Get one PersonalRecord
     * const personalRecord = await prisma.personalRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonalRecordFindUniqueArgs>(args: SelectSubset<T, PersonalRecordFindUniqueArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PersonalRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonalRecordFindUniqueOrThrowArgs} args - Arguments to find a PersonalRecord
     * @example
     * // Get one PersonalRecord
     * const personalRecord = await prisma.personalRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonalRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonalRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PersonalRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordFindFirstArgs} args - Arguments to find a PersonalRecord
     * @example
     * // Get one PersonalRecord
     * const personalRecord = await prisma.personalRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonalRecordFindFirstArgs>(args?: SelectSubset<T, PersonalRecordFindFirstArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PersonalRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordFindFirstOrThrowArgs} args - Arguments to find a PersonalRecord
     * @example
     * // Get one PersonalRecord
     * const personalRecord = await prisma.personalRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonalRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonalRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PersonalRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalRecords
     * const personalRecords = await prisma.personalRecord.findMany()
     * 
     * // Get first 10 PersonalRecords
     * const personalRecords = await prisma.personalRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalRecordWithIdOnly = await prisma.personalRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonalRecordFindManyArgs>(args?: SelectSubset<T, PersonalRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PersonalRecord.
     * @param {PersonalRecordCreateArgs} args - Arguments to create a PersonalRecord.
     * @example
     * // Create one PersonalRecord
     * const PersonalRecord = await prisma.personalRecord.create({
     *   data: {
     *     // ... data to create a PersonalRecord
     *   }
     * })
     * 
     */
    create<T extends PersonalRecordCreateArgs>(args: SelectSubset<T, PersonalRecordCreateArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PersonalRecords.
     * @param {PersonalRecordCreateManyArgs} args - Arguments to create many PersonalRecords.
     * @example
     * // Create many PersonalRecords
     * const personalRecord = await prisma.personalRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonalRecordCreateManyArgs>(args?: SelectSubset<T, PersonalRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonalRecords and returns the data saved in the database.
     * @param {PersonalRecordCreateManyAndReturnArgs} args - Arguments to create many PersonalRecords.
     * @example
     * // Create many PersonalRecords
     * const personalRecord = await prisma.personalRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonalRecords and only return the `id`
     * const personalRecordWithIdOnly = await prisma.personalRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonalRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonalRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PersonalRecord.
     * @param {PersonalRecordDeleteArgs} args - Arguments to delete one PersonalRecord.
     * @example
     * // Delete one PersonalRecord
     * const PersonalRecord = await prisma.personalRecord.delete({
     *   where: {
     *     // ... filter to delete one PersonalRecord
     *   }
     * })
     * 
     */
    delete<T extends PersonalRecordDeleteArgs>(args: SelectSubset<T, PersonalRecordDeleteArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PersonalRecord.
     * @param {PersonalRecordUpdateArgs} args - Arguments to update one PersonalRecord.
     * @example
     * // Update one PersonalRecord
     * const personalRecord = await prisma.personalRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonalRecordUpdateArgs>(args: SelectSubset<T, PersonalRecordUpdateArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PersonalRecords.
     * @param {PersonalRecordDeleteManyArgs} args - Arguments to filter PersonalRecords to delete.
     * @example
     * // Delete a few PersonalRecords
     * const { count } = await prisma.personalRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonalRecordDeleteManyArgs>(args?: SelectSubset<T, PersonalRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalRecords
     * const personalRecord = await prisma.personalRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonalRecordUpdateManyArgs>(args: SelectSubset<T, PersonalRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonalRecord.
     * @param {PersonalRecordUpsertArgs} args - Arguments to update or create a PersonalRecord.
     * @example
     * // Update or create a PersonalRecord
     * const personalRecord = await prisma.personalRecord.upsert({
     *   create: {
     *     // ... data to create a PersonalRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalRecord we want to update
     *   }
     * })
     */
    upsert<T extends PersonalRecordUpsertArgs>(args: SelectSubset<T, PersonalRecordUpsertArgs<ExtArgs>>): Prisma__PersonalRecordClient<$Result.GetResult<Prisma.$PersonalRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PersonalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordCountArgs} args - Arguments to filter PersonalRecords to count.
     * @example
     * // Count the number of PersonalRecords
     * const count = await prisma.personalRecord.count({
     *   where: {
     *     // ... the filter for the PersonalRecords we want to count
     *   }
     * })
    **/
    count<T extends PersonalRecordCountArgs>(
      args?: Subset<T, PersonalRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalRecordAggregateArgs>(args: Subset<T, PersonalRecordAggregateArgs>): Prisma.PrismaPromise<GetPersonalRecordAggregateType<T>>

    /**
     * Group by PersonalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalRecordGroupByArgs['orderBy'] }
        : { orderBy?: PersonalRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonalRecord model
   */
  readonly fields: PersonalRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonalRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonalRecord model
   */ 
  interface PersonalRecordFieldRefs {
    readonly id: FieldRef<"PersonalRecord", 'String'>
    readonly userId: FieldRef<"PersonalRecord", 'String'>
    readonly exerciseId: FieldRef<"PersonalRecord", 'String'>
    readonly recordType: FieldRef<"PersonalRecord", 'String'>
    readonly value: FieldRef<"PersonalRecord", 'Float'>
    readonly weightUnit: FieldRef<"PersonalRecord", 'String'>
    readonly achievedAt: FieldRef<"PersonalRecord", 'DateTime'>
    readonly workoutId: FieldRef<"PersonalRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PersonalRecord findUnique
   */
  export type PersonalRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * Filter, which PersonalRecord to fetch.
     */
    where: PersonalRecordWhereUniqueInput
  }

  /**
   * PersonalRecord findUniqueOrThrow
   */
  export type PersonalRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * Filter, which PersonalRecord to fetch.
     */
    where: PersonalRecordWhereUniqueInput
  }

  /**
   * PersonalRecord findFirst
   */
  export type PersonalRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * Filter, which PersonalRecord to fetch.
     */
    where?: PersonalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalRecords to fetch.
     */
    orderBy?: PersonalRecordOrderByWithRelationInput | PersonalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalRecords.
     */
    cursor?: PersonalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalRecords.
     */
    distinct?: PersonalRecordScalarFieldEnum | PersonalRecordScalarFieldEnum[]
  }

  /**
   * PersonalRecord findFirstOrThrow
   */
  export type PersonalRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * Filter, which PersonalRecord to fetch.
     */
    where?: PersonalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalRecords to fetch.
     */
    orderBy?: PersonalRecordOrderByWithRelationInput | PersonalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalRecords.
     */
    cursor?: PersonalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalRecords.
     */
    distinct?: PersonalRecordScalarFieldEnum | PersonalRecordScalarFieldEnum[]
  }

  /**
   * PersonalRecord findMany
   */
  export type PersonalRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * Filter, which PersonalRecords to fetch.
     */
    where?: PersonalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalRecords to fetch.
     */
    orderBy?: PersonalRecordOrderByWithRelationInput | PersonalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalRecords.
     */
    cursor?: PersonalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalRecords.
     */
    skip?: number
    distinct?: PersonalRecordScalarFieldEnum | PersonalRecordScalarFieldEnum[]
  }

  /**
   * PersonalRecord create
   */
  export type PersonalRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonalRecord.
     */
    data: XOR<PersonalRecordCreateInput, PersonalRecordUncheckedCreateInput>
  }

  /**
   * PersonalRecord createMany
   */
  export type PersonalRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalRecords.
     */
    data: PersonalRecordCreateManyInput | PersonalRecordCreateManyInput[]
  }

  /**
   * PersonalRecord createManyAndReturn
   */
  export type PersonalRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PersonalRecords.
     */
    data: PersonalRecordCreateManyInput | PersonalRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalRecord update
   */
  export type PersonalRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonalRecord.
     */
    data: XOR<PersonalRecordUpdateInput, PersonalRecordUncheckedUpdateInput>
    /**
     * Choose, which PersonalRecord to update.
     */
    where: PersonalRecordWhereUniqueInput
  }

  /**
   * PersonalRecord updateMany
   */
  export type PersonalRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalRecords.
     */
    data: XOR<PersonalRecordUpdateManyMutationInput, PersonalRecordUncheckedUpdateManyInput>
    /**
     * Filter which PersonalRecords to update
     */
    where?: PersonalRecordWhereInput
  }

  /**
   * PersonalRecord upsert
   */
  export type PersonalRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonalRecord to update in case it exists.
     */
    where: PersonalRecordWhereUniqueInput
    /**
     * In case the PersonalRecord found by the `where` argument doesn't exist, create a new PersonalRecord with this data.
     */
    create: XOR<PersonalRecordCreateInput, PersonalRecordUncheckedCreateInput>
    /**
     * In case the PersonalRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalRecordUpdateInput, PersonalRecordUncheckedUpdateInput>
  }

  /**
   * PersonalRecord delete
   */
  export type PersonalRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
    /**
     * Filter which PersonalRecord to delete.
     */
    where: PersonalRecordWhereUniqueInput
  }

  /**
   * PersonalRecord deleteMany
   */
  export type PersonalRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalRecords to delete
     */
    where?: PersonalRecordWhereInput
  }

  /**
   * PersonalRecord without action
   */
  export type PersonalRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalRecord
     */
    select?: PersonalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalRecordInclude<ExtArgs> | null
  }


  /**
   * Model BodyMetric
   */

  export type AggregateBodyMetric = {
    _count: BodyMetricCountAggregateOutputType | null
    _avg: BodyMetricAvgAggregateOutputType | null
    _sum: BodyMetricSumAggregateOutputType | null
    _min: BodyMetricMinAggregateOutputType | null
    _max: BodyMetricMaxAggregateOutputType | null
  }

  export type BodyMetricAvgAggregateOutputType = {
    weight: number | null
    bodyFatPercentage: number | null
    chest: number | null
    waist: number | null
    hips: number | null
    arms: number | null
    thighs: number | null
  }

  export type BodyMetricSumAggregateOutputType = {
    weight: number | null
    bodyFatPercentage: number | null
    chest: number | null
    waist: number | null
    hips: number | null
    arms: number | null
    thighs: number | null
  }

  export type BodyMetricMinAggregateOutputType = {
    id: string | null
    userId: string | null
    weight: number | null
    weightUnit: string | null
    bodyFatPercentage: number | null
    chest: number | null
    waist: number | null
    hips: number | null
    arms: number | null
    thighs: number | null
    measurementUnit: string | null
    measurementDate: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type BodyMetricMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    weight: number | null
    weightUnit: string | null
    bodyFatPercentage: number | null
    chest: number | null
    waist: number | null
    hips: number | null
    arms: number | null
    thighs: number | null
    measurementUnit: string | null
    measurementDate: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type BodyMetricCountAggregateOutputType = {
    id: number
    userId: number
    weight: number
    weightUnit: number
    bodyFatPercentage: number
    chest: number
    waist: number
    hips: number
    arms: number
    thighs: number
    measurementUnit: number
    measurementDate: number
    notes: number
    createdAt: number
    _all: number
  }


  export type BodyMetricAvgAggregateInputType = {
    weight?: true
    bodyFatPercentage?: true
    chest?: true
    waist?: true
    hips?: true
    arms?: true
    thighs?: true
  }

  export type BodyMetricSumAggregateInputType = {
    weight?: true
    bodyFatPercentage?: true
    chest?: true
    waist?: true
    hips?: true
    arms?: true
    thighs?: true
  }

  export type BodyMetricMinAggregateInputType = {
    id?: true
    userId?: true
    weight?: true
    weightUnit?: true
    bodyFatPercentage?: true
    chest?: true
    waist?: true
    hips?: true
    arms?: true
    thighs?: true
    measurementUnit?: true
    measurementDate?: true
    notes?: true
    createdAt?: true
  }

  export type BodyMetricMaxAggregateInputType = {
    id?: true
    userId?: true
    weight?: true
    weightUnit?: true
    bodyFatPercentage?: true
    chest?: true
    waist?: true
    hips?: true
    arms?: true
    thighs?: true
    measurementUnit?: true
    measurementDate?: true
    notes?: true
    createdAt?: true
  }

  export type BodyMetricCountAggregateInputType = {
    id?: true
    userId?: true
    weight?: true
    weightUnit?: true
    bodyFatPercentage?: true
    chest?: true
    waist?: true
    hips?: true
    arms?: true
    thighs?: true
    measurementUnit?: true
    measurementDate?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type BodyMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BodyMetric to aggregate.
     */
    where?: BodyMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyMetrics to fetch.
     */
    orderBy?: BodyMetricOrderByWithRelationInput | BodyMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BodyMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BodyMetrics
    **/
    _count?: true | BodyMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BodyMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BodyMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BodyMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BodyMetricMaxAggregateInputType
  }

  export type GetBodyMetricAggregateType<T extends BodyMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateBodyMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBodyMetric[P]>
      : GetScalarType<T[P], AggregateBodyMetric[P]>
  }




  export type BodyMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BodyMetricWhereInput
    orderBy?: BodyMetricOrderByWithAggregationInput | BodyMetricOrderByWithAggregationInput[]
    by: BodyMetricScalarFieldEnum[] | BodyMetricScalarFieldEnum
    having?: BodyMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BodyMetricCountAggregateInputType | true
    _avg?: BodyMetricAvgAggregateInputType
    _sum?: BodyMetricSumAggregateInputType
    _min?: BodyMetricMinAggregateInputType
    _max?: BodyMetricMaxAggregateInputType
  }

  export type BodyMetricGroupByOutputType = {
    id: string
    userId: string
    weight: number | null
    weightUnit: string
    bodyFatPercentage: number | null
    chest: number | null
    waist: number | null
    hips: number | null
    arms: number | null
    thighs: number | null
    measurementUnit: string
    measurementDate: Date
    notes: string | null
    createdAt: Date
    _count: BodyMetricCountAggregateOutputType | null
    _avg: BodyMetricAvgAggregateOutputType | null
    _sum: BodyMetricSumAggregateOutputType | null
    _min: BodyMetricMinAggregateOutputType | null
    _max: BodyMetricMaxAggregateOutputType | null
  }

  type GetBodyMetricGroupByPayload<T extends BodyMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BodyMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BodyMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BodyMetricGroupByOutputType[P]>
            : GetScalarType<T[P], BodyMetricGroupByOutputType[P]>
        }
      >
    >


  export type BodyMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    weight?: boolean
    weightUnit?: boolean
    bodyFatPercentage?: boolean
    chest?: boolean
    waist?: boolean
    hips?: boolean
    arms?: boolean
    thighs?: boolean
    measurementUnit?: boolean
    measurementDate?: boolean
    notes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bodyMetric"]>

  export type BodyMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    weight?: boolean
    weightUnit?: boolean
    bodyFatPercentage?: boolean
    chest?: boolean
    waist?: boolean
    hips?: boolean
    arms?: boolean
    thighs?: boolean
    measurementUnit?: boolean
    measurementDate?: boolean
    notes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bodyMetric"]>

  export type BodyMetricSelectScalar = {
    id?: boolean
    userId?: boolean
    weight?: boolean
    weightUnit?: boolean
    bodyFatPercentage?: boolean
    chest?: boolean
    waist?: boolean
    hips?: boolean
    arms?: boolean
    thighs?: boolean
    measurementUnit?: boolean
    measurementDate?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type BodyMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BodyMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BodyMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BodyMetric"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      weight: number | null
      weightUnit: string
      bodyFatPercentage: number | null
      chest: number | null
      waist: number | null
      hips: number | null
      arms: number | null
      thighs: number | null
      measurementUnit: string
      measurementDate: Date
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["bodyMetric"]>
    composites: {}
  }

  type BodyMetricGetPayload<S extends boolean | null | undefined | BodyMetricDefaultArgs> = $Result.GetResult<Prisma.$BodyMetricPayload, S>

  type BodyMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BodyMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BodyMetricCountAggregateInputType | true
    }

  export interface BodyMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BodyMetric'], meta: { name: 'BodyMetric' } }
    /**
     * Find zero or one BodyMetric that matches the filter.
     * @param {BodyMetricFindUniqueArgs} args - Arguments to find a BodyMetric
     * @example
     * // Get one BodyMetric
     * const bodyMetric = await prisma.bodyMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BodyMetricFindUniqueArgs>(args: SelectSubset<T, BodyMetricFindUniqueArgs<ExtArgs>>): Prisma__BodyMetricClient<$Result.GetResult<Prisma.$BodyMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BodyMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BodyMetricFindUniqueOrThrowArgs} args - Arguments to find a BodyMetric
     * @example
     * // Get one BodyMetric
     * const bodyMetric = await prisma.bodyMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BodyMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, BodyMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BodyMetricClient<$Result.GetResult<Prisma.$BodyMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BodyMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyMetricFindFirstArgs} args - Arguments to find a BodyMetric
     * @example
     * // Get one BodyMetric
     * const bodyMetric = await prisma.bodyMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BodyMetricFindFirstArgs>(args?: SelectSubset<T, BodyMetricFindFirstArgs<ExtArgs>>): Prisma__BodyMetricClient<$Result.GetResult<Prisma.$BodyMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BodyMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyMetricFindFirstOrThrowArgs} args - Arguments to find a BodyMetric
     * @example
     * // Get one BodyMetric
     * const bodyMetric = await prisma.bodyMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BodyMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, BodyMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__BodyMetricClient<$Result.GetResult<Prisma.$BodyMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BodyMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BodyMetrics
     * const bodyMetrics = await prisma.bodyMetric.findMany()
     * 
     * // Get first 10 BodyMetrics
     * const bodyMetrics = await prisma.bodyMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bodyMetricWithIdOnly = await prisma.bodyMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BodyMetricFindManyArgs>(args?: SelectSubset<T, BodyMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodyMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BodyMetric.
     * @param {BodyMetricCreateArgs} args - Arguments to create a BodyMetric.
     * @example
     * // Create one BodyMetric
     * const BodyMetric = await prisma.bodyMetric.create({
     *   data: {
     *     // ... data to create a BodyMetric
     *   }
     * })
     * 
     */
    create<T extends BodyMetricCreateArgs>(args: SelectSubset<T, BodyMetricCreateArgs<ExtArgs>>): Prisma__BodyMetricClient<$Result.GetResult<Prisma.$BodyMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BodyMetrics.
     * @param {BodyMetricCreateManyArgs} args - Arguments to create many BodyMetrics.
     * @example
     * // Create many BodyMetrics
     * const bodyMetric = await prisma.bodyMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BodyMetricCreateManyArgs>(args?: SelectSubset<T, BodyMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BodyMetrics and returns the data saved in the database.
     * @param {BodyMetricCreateManyAndReturnArgs} args - Arguments to create many BodyMetrics.
     * @example
     * // Create many BodyMetrics
     * const bodyMetric = await prisma.bodyMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BodyMetrics and only return the `id`
     * const bodyMetricWithIdOnly = await prisma.bodyMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BodyMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, BodyMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodyMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BodyMetric.
     * @param {BodyMetricDeleteArgs} args - Arguments to delete one BodyMetric.
     * @example
     * // Delete one BodyMetric
     * const BodyMetric = await prisma.bodyMetric.delete({
     *   where: {
     *     // ... filter to delete one BodyMetric
     *   }
     * })
     * 
     */
    delete<T extends BodyMetricDeleteArgs>(args: SelectSubset<T, BodyMetricDeleteArgs<ExtArgs>>): Prisma__BodyMetricClient<$Result.GetResult<Prisma.$BodyMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BodyMetric.
     * @param {BodyMetricUpdateArgs} args - Arguments to update one BodyMetric.
     * @example
     * // Update one BodyMetric
     * const bodyMetric = await prisma.bodyMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BodyMetricUpdateArgs>(args: SelectSubset<T, BodyMetricUpdateArgs<ExtArgs>>): Prisma__BodyMetricClient<$Result.GetResult<Prisma.$BodyMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BodyMetrics.
     * @param {BodyMetricDeleteManyArgs} args - Arguments to filter BodyMetrics to delete.
     * @example
     * // Delete a few BodyMetrics
     * const { count } = await prisma.bodyMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BodyMetricDeleteManyArgs>(args?: SelectSubset<T, BodyMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BodyMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BodyMetrics
     * const bodyMetric = await prisma.bodyMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BodyMetricUpdateManyArgs>(args: SelectSubset<T, BodyMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BodyMetric.
     * @param {BodyMetricUpsertArgs} args - Arguments to update or create a BodyMetric.
     * @example
     * // Update or create a BodyMetric
     * const bodyMetric = await prisma.bodyMetric.upsert({
     *   create: {
     *     // ... data to create a BodyMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BodyMetric we want to update
     *   }
     * })
     */
    upsert<T extends BodyMetricUpsertArgs>(args: SelectSubset<T, BodyMetricUpsertArgs<ExtArgs>>): Prisma__BodyMetricClient<$Result.GetResult<Prisma.$BodyMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BodyMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyMetricCountArgs} args - Arguments to filter BodyMetrics to count.
     * @example
     * // Count the number of BodyMetrics
     * const count = await prisma.bodyMetric.count({
     *   where: {
     *     // ... the filter for the BodyMetrics we want to count
     *   }
     * })
    **/
    count<T extends BodyMetricCountArgs>(
      args?: Subset<T, BodyMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BodyMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BodyMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BodyMetricAggregateArgs>(args: Subset<T, BodyMetricAggregateArgs>): Prisma.PrismaPromise<GetBodyMetricAggregateType<T>>

    /**
     * Group by BodyMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BodyMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BodyMetricGroupByArgs['orderBy'] }
        : { orderBy?: BodyMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BodyMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBodyMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BodyMetric model
   */
  readonly fields: BodyMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BodyMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BodyMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BodyMetric model
   */ 
  interface BodyMetricFieldRefs {
    readonly id: FieldRef<"BodyMetric", 'String'>
    readonly userId: FieldRef<"BodyMetric", 'String'>
    readonly weight: FieldRef<"BodyMetric", 'Float'>
    readonly weightUnit: FieldRef<"BodyMetric", 'String'>
    readonly bodyFatPercentage: FieldRef<"BodyMetric", 'Float'>
    readonly chest: FieldRef<"BodyMetric", 'Float'>
    readonly waist: FieldRef<"BodyMetric", 'Float'>
    readonly hips: FieldRef<"BodyMetric", 'Float'>
    readonly arms: FieldRef<"BodyMetric", 'Float'>
    readonly thighs: FieldRef<"BodyMetric", 'Float'>
    readonly measurementUnit: FieldRef<"BodyMetric", 'String'>
    readonly measurementDate: FieldRef<"BodyMetric", 'DateTime'>
    readonly notes: FieldRef<"BodyMetric", 'String'>
    readonly createdAt: FieldRef<"BodyMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BodyMetric findUnique
   */
  export type BodyMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyMetric
     */
    select?: BodyMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyMetricInclude<ExtArgs> | null
    /**
     * Filter, which BodyMetric to fetch.
     */
    where: BodyMetricWhereUniqueInput
  }

  /**
   * BodyMetric findUniqueOrThrow
   */
  export type BodyMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyMetric
     */
    select?: BodyMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyMetricInclude<ExtArgs> | null
    /**
     * Filter, which BodyMetric to fetch.
     */
    where: BodyMetricWhereUniqueInput
  }

  /**
   * BodyMetric findFirst
   */
  export type BodyMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyMetric
     */
    select?: BodyMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyMetricInclude<ExtArgs> | null
    /**
     * Filter, which BodyMetric to fetch.
     */
    where?: BodyMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyMetrics to fetch.
     */
    orderBy?: BodyMetricOrderByWithRelationInput | BodyMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BodyMetrics.
     */
    cursor?: BodyMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BodyMetrics.
     */
    distinct?: BodyMetricScalarFieldEnum | BodyMetricScalarFieldEnum[]
  }

  /**
   * BodyMetric findFirstOrThrow
   */
  export type BodyMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyMetric
     */
    select?: BodyMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyMetricInclude<ExtArgs> | null
    /**
     * Filter, which BodyMetric to fetch.
     */
    where?: BodyMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyMetrics to fetch.
     */
    orderBy?: BodyMetricOrderByWithRelationInput | BodyMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BodyMetrics.
     */
    cursor?: BodyMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BodyMetrics.
     */
    distinct?: BodyMetricScalarFieldEnum | BodyMetricScalarFieldEnum[]
  }

  /**
   * BodyMetric findMany
   */
  export type BodyMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyMetric
     */
    select?: BodyMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyMetricInclude<ExtArgs> | null
    /**
     * Filter, which BodyMetrics to fetch.
     */
    where?: BodyMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyMetrics to fetch.
     */
    orderBy?: BodyMetricOrderByWithRelationInput | BodyMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BodyMetrics.
     */
    cursor?: BodyMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyMetrics.
     */
    skip?: number
    distinct?: BodyMetricScalarFieldEnum | BodyMetricScalarFieldEnum[]
  }

  /**
   * BodyMetric create
   */
  export type BodyMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyMetric
     */
    select?: BodyMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a BodyMetric.
     */
    data: XOR<BodyMetricCreateInput, BodyMetricUncheckedCreateInput>
  }

  /**
   * BodyMetric createMany
   */
  export type BodyMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BodyMetrics.
     */
    data: BodyMetricCreateManyInput | BodyMetricCreateManyInput[]
  }

  /**
   * BodyMetric createManyAndReturn
   */
  export type BodyMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyMetric
     */
    select?: BodyMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BodyMetrics.
     */
    data: BodyMetricCreateManyInput | BodyMetricCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BodyMetric update
   */
  export type BodyMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyMetric
     */
    select?: BodyMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a BodyMetric.
     */
    data: XOR<BodyMetricUpdateInput, BodyMetricUncheckedUpdateInput>
    /**
     * Choose, which BodyMetric to update.
     */
    where: BodyMetricWhereUniqueInput
  }

  /**
   * BodyMetric updateMany
   */
  export type BodyMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BodyMetrics.
     */
    data: XOR<BodyMetricUpdateManyMutationInput, BodyMetricUncheckedUpdateManyInput>
    /**
     * Filter which BodyMetrics to update
     */
    where?: BodyMetricWhereInput
  }

  /**
   * BodyMetric upsert
   */
  export type BodyMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyMetric
     */
    select?: BodyMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the BodyMetric to update in case it exists.
     */
    where: BodyMetricWhereUniqueInput
    /**
     * In case the BodyMetric found by the `where` argument doesn't exist, create a new BodyMetric with this data.
     */
    create: XOR<BodyMetricCreateInput, BodyMetricUncheckedCreateInput>
    /**
     * In case the BodyMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BodyMetricUpdateInput, BodyMetricUncheckedUpdateInput>
  }

  /**
   * BodyMetric delete
   */
  export type BodyMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyMetric
     */
    select?: BodyMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyMetricInclude<ExtArgs> | null
    /**
     * Filter which BodyMetric to delete.
     */
    where: BodyMetricWhereUniqueInput
  }

  /**
   * BodyMetric deleteMany
   */
  export type BodyMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BodyMetrics to delete
     */
    where?: BodyMetricWhereInput
  }

  /**
   * BodyMetric without action
   */
  export type BodyMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyMetric
     */
    select?: BodyMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyMetricInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationType: string | null
    title: string | null
    body: string | null
    actionType: string | null
    actionData: string | null
    sentAt: Date | null
    readAt: Date | null
    clickedAt: Date | null
    deliveryStatus: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationType: string | null
    title: string | null
    body: string | null
    actionType: string | null
    actionData: string | null
    sentAt: Date | null
    readAt: Date | null
    clickedAt: Date | null
    deliveryStatus: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    notificationType: number
    title: number
    body: number
    actionType: number
    actionData: number
    sentAt: number
    readAt: number
    clickedAt: number
    deliveryStatus: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    notificationType?: true
    title?: true
    body?: true
    actionType?: true
    actionData?: true
    sentAt?: true
    readAt?: true
    clickedAt?: true
    deliveryStatus?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    notificationType?: true
    title?: true
    body?: true
    actionType?: true
    actionData?: true
    sentAt?: true
    readAt?: true
    clickedAt?: true
    deliveryStatus?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    notificationType?: true
    title?: true
    body?: true
    actionType?: true
    actionData?: true
    sentAt?: true
    readAt?: true
    clickedAt?: true
    deliveryStatus?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    notificationType: string
    title: string
    body: string | null
    actionType: string | null
    actionData: string | null
    sentAt: Date | null
    readAt: Date | null
    clickedAt: Date | null
    deliveryStatus: string
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    title?: boolean
    body?: boolean
    actionType?: boolean
    actionData?: boolean
    sentAt?: boolean
    readAt?: boolean
    clickedAt?: boolean
    deliveryStatus?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    title?: boolean
    body?: boolean
    actionType?: boolean
    actionData?: boolean
    sentAt?: boolean
    readAt?: boolean
    clickedAt?: boolean
    deliveryStatus?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    notificationType?: boolean
    title?: boolean
    body?: boolean
    actionType?: boolean
    actionData?: boolean
    sentAt?: boolean
    readAt?: boolean
    clickedAt?: boolean
    deliveryStatus?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      notificationType: string
      title: string
      body: string | null
      actionType: string | null
      actionData: string | null
      sentAt: Date | null
      readAt: Date | null
      clickedAt: Date | null
      deliveryStatus: string
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly notificationType: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly actionType: FieldRef<"Notification", 'String'>
    readonly actionData: FieldRef<"Notification", 'String'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly clickedAt: FieldRef<"Notification", 'DateTime'>
    readonly deliveryStatus: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _avg: NotificationPreferenceAvgAggregateOutputType | null
    _sum: NotificationPreferenceSumAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceAvgAggregateOutputType = {
    maxDailyNotifications: number | null
  }

  export type NotificationPreferenceSumAggregateOutputType = {
    maxDailyNotifications: number | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationsEnabled: boolean | null
    stretchReminders: boolean | null
    workoutReminders: boolean | null
    streakNotifications: boolean | null
    goalNotifications: boolean | null
    socialNotifications: boolean | null
    recoverySuggestions: boolean | null
    inactivityNudges: boolean | null
    quietHoursEnabled: boolean | null
    quietHoursStart: string | null
    quietHoursEnd: string | null
    maxDailyNotifications: number | null
    stretchReminderTime: string | null
    workoutReminderTime: string | null
    reminderDays: string | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationsEnabled: boolean | null
    stretchReminders: boolean | null
    workoutReminders: boolean | null
    streakNotifications: boolean | null
    goalNotifications: boolean | null
    socialNotifications: boolean | null
    recoverySuggestions: boolean | null
    inactivityNudges: boolean | null
    quietHoursEnabled: boolean | null
    quietHoursStart: string | null
    quietHoursEnd: string | null
    maxDailyNotifications: number | null
    stretchReminderTime: string | null
    workoutReminderTime: string | null
    reminderDays: string | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    notificationsEnabled: number
    stretchReminders: number
    workoutReminders: number
    streakNotifications: number
    goalNotifications: number
    socialNotifications: number
    recoverySuggestions: number
    inactivityNudges: number
    quietHoursEnabled: number
    quietHoursStart: number
    quietHoursEnd: number
    maxDailyNotifications: number
    stretchReminderTime: number
    workoutReminderTime: number
    reminderDays: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceAvgAggregateInputType = {
    maxDailyNotifications?: true
  }

  export type NotificationPreferenceSumAggregateInputType = {
    maxDailyNotifications?: true
  }

  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    notificationsEnabled?: true
    stretchReminders?: true
    workoutReminders?: true
    streakNotifications?: true
    goalNotifications?: true
    socialNotifications?: true
    recoverySuggestions?: true
    inactivityNudges?: true
    quietHoursEnabled?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    maxDailyNotifications?: true
    stretchReminderTime?: true
    workoutReminderTime?: true
    reminderDays?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    notificationsEnabled?: true
    stretchReminders?: true
    workoutReminders?: true
    streakNotifications?: true
    goalNotifications?: true
    socialNotifications?: true
    recoverySuggestions?: true
    inactivityNudges?: true
    quietHoursEnabled?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    maxDailyNotifications?: true
    stretchReminderTime?: true
    workoutReminderTime?: true
    reminderDays?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    notificationsEnabled?: true
    stretchReminders?: true
    workoutReminders?: true
    streakNotifications?: true
    goalNotifications?: true
    socialNotifications?: true
    recoverySuggestions?: true
    inactivityNudges?: true
    quietHoursEnabled?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    maxDailyNotifications?: true
    stretchReminderTime?: true
    workoutReminderTime?: true
    reminderDays?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _avg?: NotificationPreferenceAvgAggregateInputType
    _sum?: NotificationPreferenceSumAggregateInputType
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    userId: string
    notificationsEnabled: boolean
    stretchReminders: boolean
    workoutReminders: boolean
    streakNotifications: boolean
    goalNotifications: boolean
    socialNotifications: boolean
    recoverySuggestions: boolean
    inactivityNudges: boolean
    quietHoursEnabled: boolean
    quietHoursStart: string
    quietHoursEnd: string
    maxDailyNotifications: number
    stretchReminderTime: string
    workoutReminderTime: string
    reminderDays: string
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _avg: NotificationPreferenceAvgAggregateOutputType | null
    _sum: NotificationPreferenceSumAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationsEnabled?: boolean
    stretchReminders?: boolean
    workoutReminders?: boolean
    streakNotifications?: boolean
    goalNotifications?: boolean
    socialNotifications?: boolean
    recoverySuggestions?: boolean
    inactivityNudges?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    maxDailyNotifications?: boolean
    stretchReminderTime?: boolean
    workoutReminderTime?: boolean
    reminderDays?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationsEnabled?: boolean
    stretchReminders?: boolean
    workoutReminders?: boolean
    streakNotifications?: boolean
    goalNotifications?: boolean
    socialNotifications?: boolean
    recoverySuggestions?: boolean
    inactivityNudges?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    maxDailyNotifications?: boolean
    stretchReminderTime?: boolean
    workoutReminderTime?: boolean
    reminderDays?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    notificationsEnabled?: boolean
    stretchReminders?: boolean
    workoutReminders?: boolean
    streakNotifications?: boolean
    goalNotifications?: boolean
    socialNotifications?: boolean
    recoverySuggestions?: boolean
    inactivityNudges?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    maxDailyNotifications?: boolean
    stretchReminderTime?: boolean
    workoutReminderTime?: boolean
    reminderDays?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      notificationsEnabled: boolean
      stretchReminders: boolean
      workoutReminders: boolean
      streakNotifications: boolean
      goalNotifications: boolean
      socialNotifications: boolean
      recoverySuggestions: boolean
      inactivityNudges: boolean
      quietHoursEnabled: boolean
      quietHoursStart: string
      quietHoursEnd: string
      maxDailyNotifications: number
      stretchReminderTime: string
      workoutReminderTime: string
      reminderDays: string
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */ 
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly notificationsEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly stretchReminders: FieldRef<"NotificationPreference", 'Boolean'>
    readonly workoutReminders: FieldRef<"NotificationPreference", 'Boolean'>
    readonly streakNotifications: FieldRef<"NotificationPreference", 'Boolean'>
    readonly goalNotifications: FieldRef<"NotificationPreference", 'Boolean'>
    readonly socialNotifications: FieldRef<"NotificationPreference", 'Boolean'>
    readonly recoverySuggestions: FieldRef<"NotificationPreference", 'Boolean'>
    readonly inactivityNudges: FieldRef<"NotificationPreference", 'Boolean'>
    readonly quietHoursEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly quietHoursStart: FieldRef<"NotificationPreference", 'String'>
    readonly quietHoursEnd: FieldRef<"NotificationPreference", 'String'>
    readonly maxDailyNotifications: FieldRef<"NotificationPreference", 'Int'>
    readonly stretchReminderTime: FieldRef<"NotificationPreference", 'String'>
    readonly workoutReminderTime: FieldRef<"NotificationPreference", 'String'>
    readonly reminderDays: FieldRef<"NotificationPreference", 'String'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    pricePaid: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    pricePaid: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    planType: string | null
    status: string | null
    pricePaid: number | null
    currency: string | null
    startedAt: Date | null
    expiresAt: Date | null
    cancelledAt: Date | null
    provider: string | null
    providerSubscriptionId: string | null
    providerCustomerId: string | null
    trialStartedAt: Date | null
    trialEndsAt: Date | null
    isTrial: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    planType: string | null
    status: string | null
    pricePaid: number | null
    currency: string | null
    startedAt: Date | null
    expiresAt: Date | null
    cancelledAt: Date | null
    provider: string | null
    providerSubscriptionId: string | null
    providerCustomerId: string | null
    trialStartedAt: Date | null
    trialEndsAt: Date | null
    isTrial: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    planType: number
    status: number
    pricePaid: number
    currency: number
    startedAt: number
    expiresAt: number
    cancelledAt: number
    provider: number
    providerSubscriptionId: number
    providerCustomerId: number
    trialStartedAt: number
    trialEndsAt: number
    isTrial: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    pricePaid?: true
  }

  export type SubscriptionSumAggregateInputType = {
    pricePaid?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    planType?: true
    status?: true
    pricePaid?: true
    currency?: true
    startedAt?: true
    expiresAt?: true
    cancelledAt?: true
    provider?: true
    providerSubscriptionId?: true
    providerCustomerId?: true
    trialStartedAt?: true
    trialEndsAt?: true
    isTrial?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    planType?: true
    status?: true
    pricePaid?: true
    currency?: true
    startedAt?: true
    expiresAt?: true
    cancelledAt?: true
    provider?: true
    providerSubscriptionId?: true
    providerCustomerId?: true
    trialStartedAt?: true
    trialEndsAt?: true
    isTrial?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    planType?: true
    status?: true
    pricePaid?: true
    currency?: true
    startedAt?: true
    expiresAt?: true
    cancelledAt?: true
    provider?: true
    providerSubscriptionId?: true
    providerCustomerId?: true
    trialStartedAt?: true
    trialEndsAt?: true
    isTrial?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    planType: string
    status: string
    pricePaid: number | null
    currency: string
    startedAt: Date
    expiresAt: Date | null
    cancelledAt: Date | null
    provider: string | null
    providerSubscriptionId: string | null
    providerCustomerId: string | null
    trialStartedAt: Date | null
    trialEndsAt: Date | null
    isTrial: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planType?: boolean
    status?: boolean
    pricePaid?: boolean
    currency?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    cancelledAt?: boolean
    provider?: boolean
    providerSubscriptionId?: boolean
    providerCustomerId?: boolean
    trialStartedAt?: boolean
    trialEndsAt?: boolean
    isTrial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planType?: boolean
    status?: boolean
    pricePaid?: boolean
    currency?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    cancelledAt?: boolean
    provider?: boolean
    providerSubscriptionId?: boolean
    providerCustomerId?: boolean
    trialStartedAt?: boolean
    trialEndsAt?: boolean
    isTrial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    planType?: boolean
    status?: boolean
    pricePaid?: boolean
    currency?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    cancelledAt?: boolean
    provider?: boolean
    providerSubscriptionId?: boolean
    providerCustomerId?: boolean
    trialStartedAt?: boolean
    trialEndsAt?: boolean
    isTrial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      planType: string
      status: string
      pricePaid: number | null
      currency: string
      startedAt: Date
      expiresAt: Date | null
      cancelledAt: Date | null
      provider: string | null
      providerSubscriptionId: string | null
      providerCustomerId: string | null
      trialStartedAt: Date | null
      trialEndsAt: Date | null
      isTrial: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly planType: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly pricePaid: FieldRef<"Subscription", 'Float'>
    readonly currency: FieldRef<"Subscription", 'String'>
    readonly startedAt: FieldRef<"Subscription", 'DateTime'>
    readonly expiresAt: FieldRef<"Subscription", 'DateTime'>
    readonly cancelledAt: FieldRef<"Subscription", 'DateTime'>
    readonly provider: FieldRef<"Subscription", 'String'>
    readonly providerSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly providerCustomerId: FieldRef<"Subscription", 'String'>
    readonly trialStartedAt: FieldRef<"Subscription", 'DateTime'>
    readonly trialEndsAt: FieldRef<"Subscription", 'DateTime'>
    readonly isTrial: FieldRef<"Subscription", 'Boolean'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model UserConsent
   */

  export type AggregateUserConsent = {
    _count: UserConsentCountAggregateOutputType | null
    _min: UserConsentMinAggregateOutputType | null
    _max: UserConsentMaxAggregateOutputType | null
  }

  export type UserConsentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    consentType: string | null
    version: string | null
    consented: boolean | null
    consentedAt: Date | null
    withdrawnAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type UserConsentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    consentType: string | null
    version: string | null
    consented: boolean | null
    consentedAt: Date | null
    withdrawnAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type UserConsentCountAggregateOutputType = {
    id: number
    userId: number
    consentType: number
    version: number
    consented: number
    consentedAt: number
    withdrawnAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type UserConsentMinAggregateInputType = {
    id?: true
    userId?: true
    consentType?: true
    version?: true
    consented?: true
    consentedAt?: true
    withdrawnAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type UserConsentMaxAggregateInputType = {
    id?: true
    userId?: true
    consentType?: true
    version?: true
    consented?: true
    consentedAt?: true
    withdrawnAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type UserConsentCountAggregateInputType = {
    id?: true
    userId?: true
    consentType?: true
    version?: true
    consented?: true
    consentedAt?: true
    withdrawnAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type UserConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConsent to aggregate.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserConsents
    **/
    _count?: true | UserConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserConsentMaxAggregateInputType
  }

  export type GetUserConsentAggregateType<T extends UserConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserConsent[P]>
      : GetScalarType<T[P], AggregateUserConsent[P]>
  }




  export type UserConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConsentWhereInput
    orderBy?: UserConsentOrderByWithAggregationInput | UserConsentOrderByWithAggregationInput[]
    by: UserConsentScalarFieldEnum[] | UserConsentScalarFieldEnum
    having?: UserConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserConsentCountAggregateInputType | true
    _min?: UserConsentMinAggregateInputType
    _max?: UserConsentMaxAggregateInputType
  }

  export type UserConsentGroupByOutputType = {
    id: string
    userId: string
    consentType: string
    version: string
    consented: boolean
    consentedAt: Date | null
    withdrawnAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: UserConsentCountAggregateOutputType | null
    _min: UserConsentMinAggregateOutputType | null
    _max: UserConsentMaxAggregateOutputType | null
  }

  type GetUserConsentGroupByPayload<T extends UserConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserConsentGroupByOutputType[P]>
            : GetScalarType<T[P], UserConsentGroupByOutputType[P]>
        }
      >
    >


  export type UserConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    consentType?: boolean
    version?: boolean
    consented?: boolean
    consentedAt?: boolean
    withdrawnAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    consentType?: boolean
    version?: boolean
    consented?: boolean
    consentedAt?: boolean
    withdrawnAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectScalar = {
    id?: boolean
    userId?: boolean
    consentType?: boolean
    version?: boolean
    consented?: boolean
    consentedAt?: boolean
    withdrawnAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type UserConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserConsent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      consentType: string
      version: string
      consented: boolean
      consentedAt: Date | null
      withdrawnAt: Date | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["userConsent"]>
    composites: {}
  }

  type UserConsentGetPayload<S extends boolean | null | undefined | UserConsentDefaultArgs> = $Result.GetResult<Prisma.$UserConsentPayload, S>

  type UserConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserConsentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserConsentCountAggregateInputType | true
    }

  export interface UserConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserConsent'], meta: { name: 'UserConsent' } }
    /**
     * Find zero or one UserConsent that matches the filter.
     * @param {UserConsentFindUniqueArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserConsentFindUniqueArgs>(args: SelectSubset<T, UserConsentFindUniqueArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserConsent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserConsentFindUniqueOrThrowArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindFirstArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserConsentFindFirstArgs>(args?: SelectSubset<T, UserConsentFindFirstArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindFirstOrThrowArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserConsents
     * const userConsents = await prisma.userConsent.findMany()
     * 
     * // Get first 10 UserConsents
     * const userConsents = await prisma.userConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userConsentWithIdOnly = await prisma.userConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserConsentFindManyArgs>(args?: SelectSubset<T, UserConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserConsent.
     * @param {UserConsentCreateArgs} args - Arguments to create a UserConsent.
     * @example
     * // Create one UserConsent
     * const UserConsent = await prisma.userConsent.create({
     *   data: {
     *     // ... data to create a UserConsent
     *   }
     * })
     * 
     */
    create<T extends UserConsentCreateArgs>(args: SelectSubset<T, UserConsentCreateArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserConsents.
     * @param {UserConsentCreateManyArgs} args - Arguments to create many UserConsents.
     * @example
     * // Create many UserConsents
     * const userConsent = await prisma.userConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserConsentCreateManyArgs>(args?: SelectSubset<T, UserConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserConsents and returns the data saved in the database.
     * @param {UserConsentCreateManyAndReturnArgs} args - Arguments to create many UserConsents.
     * @example
     * // Create many UserConsents
     * const userConsent = await prisma.userConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserConsents and only return the `id`
     * const userConsentWithIdOnly = await prisma.userConsent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, UserConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserConsent.
     * @param {UserConsentDeleteArgs} args - Arguments to delete one UserConsent.
     * @example
     * // Delete one UserConsent
     * const UserConsent = await prisma.userConsent.delete({
     *   where: {
     *     // ... filter to delete one UserConsent
     *   }
     * })
     * 
     */
    delete<T extends UserConsentDeleteArgs>(args: SelectSubset<T, UserConsentDeleteArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserConsent.
     * @param {UserConsentUpdateArgs} args - Arguments to update one UserConsent.
     * @example
     * // Update one UserConsent
     * const userConsent = await prisma.userConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserConsentUpdateArgs>(args: SelectSubset<T, UserConsentUpdateArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserConsents.
     * @param {UserConsentDeleteManyArgs} args - Arguments to filter UserConsents to delete.
     * @example
     * // Delete a few UserConsents
     * const { count } = await prisma.userConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserConsentDeleteManyArgs>(args?: SelectSubset<T, UserConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserConsents
     * const userConsent = await prisma.userConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserConsentUpdateManyArgs>(args: SelectSubset<T, UserConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserConsent.
     * @param {UserConsentUpsertArgs} args - Arguments to update or create a UserConsent.
     * @example
     * // Update or create a UserConsent
     * const userConsent = await prisma.userConsent.upsert({
     *   create: {
     *     // ... data to create a UserConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserConsent we want to update
     *   }
     * })
     */
    upsert<T extends UserConsentUpsertArgs>(args: SelectSubset<T, UserConsentUpsertArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentCountArgs} args - Arguments to filter UserConsents to count.
     * @example
     * // Count the number of UserConsents
     * const count = await prisma.userConsent.count({
     *   where: {
     *     // ... the filter for the UserConsents we want to count
     *   }
     * })
    **/
    count<T extends UserConsentCountArgs>(
      args?: Subset<T, UserConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserConsentAggregateArgs>(args: Subset<T, UserConsentAggregateArgs>): Prisma.PrismaPromise<GetUserConsentAggregateType<T>>

    /**
     * Group by UserConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserConsentGroupByArgs['orderBy'] }
        : { orderBy?: UserConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserConsent model
   */
  readonly fields: UserConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserConsent model
   */ 
  interface UserConsentFieldRefs {
    readonly id: FieldRef<"UserConsent", 'String'>
    readonly userId: FieldRef<"UserConsent", 'String'>
    readonly consentType: FieldRef<"UserConsent", 'String'>
    readonly version: FieldRef<"UserConsent", 'String'>
    readonly consented: FieldRef<"UserConsent", 'Boolean'>
    readonly consentedAt: FieldRef<"UserConsent", 'DateTime'>
    readonly withdrawnAt: FieldRef<"UserConsent", 'DateTime'>
    readonly ipAddress: FieldRef<"UserConsent", 'String'>
    readonly userAgent: FieldRef<"UserConsent", 'String'>
    readonly createdAt: FieldRef<"UserConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserConsent findUnique
   */
  export type UserConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent findUniqueOrThrow
   */
  export type UserConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent findFirst
   */
  export type UserConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConsents.
     */
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent findFirstOrThrow
   */
  export type UserConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConsents.
     */
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent findMany
   */
  export type UserConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsents to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent create
   */
  export type UserConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserConsent.
     */
    data: XOR<UserConsentCreateInput, UserConsentUncheckedCreateInput>
  }

  /**
   * UserConsent createMany
   */
  export type UserConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserConsents.
     */
    data: UserConsentCreateManyInput | UserConsentCreateManyInput[]
  }

  /**
   * UserConsent createManyAndReturn
   */
  export type UserConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserConsents.
     */
    data: UserConsentCreateManyInput | UserConsentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConsent update
   */
  export type UserConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserConsent.
     */
    data: XOR<UserConsentUpdateInput, UserConsentUncheckedUpdateInput>
    /**
     * Choose, which UserConsent to update.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent updateMany
   */
  export type UserConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserConsents.
     */
    data: XOR<UserConsentUpdateManyMutationInput, UserConsentUncheckedUpdateManyInput>
    /**
     * Filter which UserConsents to update
     */
    where?: UserConsentWhereInput
  }

  /**
   * UserConsent upsert
   */
  export type UserConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserConsent to update in case it exists.
     */
    where: UserConsentWhereUniqueInput
    /**
     * In case the UserConsent found by the `where` argument doesn't exist, create a new UserConsent with this data.
     */
    create: XOR<UserConsentCreateInput, UserConsentUncheckedCreateInput>
    /**
     * In case the UserConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserConsentUpdateInput, UserConsentUncheckedUpdateInput>
  }

  /**
   * UserConsent delete
   */
  export type UserConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter which UserConsent to delete.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent deleteMany
   */
  export type UserConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConsents to delete
     */
    where?: UserConsentWhereInput
  }

  /**
   * UserConsent without action
   */
  export type UserConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
  }


  /**
   * Model DataExportRequest
   */

  export type AggregateDataExportRequest = {
    _count: DataExportRequestCountAggregateOutputType | null
    _avg: DataExportRequestAvgAggregateOutputType | null
    _sum: DataExportRequestSumAggregateOutputType | null
    _min: DataExportRequestMinAggregateOutputType | null
    _max: DataExportRequestMaxAggregateOutputType | null
  }

  export type DataExportRequestAvgAggregateOutputType = {
    fileSizeBytes: number | null
  }

  export type DataExportRequestSumAggregateOutputType = {
    fileSizeBytes: number | null
  }

  export type DataExportRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    requestedAt: Date | null
    completedAt: Date | null
    expiresAt: Date | null
    downloadUrl: string | null
    fileSizeBytes: number | null
  }

  export type DataExportRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    requestedAt: Date | null
    completedAt: Date | null
    expiresAt: Date | null
    downloadUrl: string | null
    fileSizeBytes: number | null
  }

  export type DataExportRequestCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    requestedAt: number
    completedAt: number
    expiresAt: number
    downloadUrl: number
    fileSizeBytes: number
    _all: number
  }


  export type DataExportRequestAvgAggregateInputType = {
    fileSizeBytes?: true
  }

  export type DataExportRequestSumAggregateInputType = {
    fileSizeBytes?: true
  }

  export type DataExportRequestMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    requestedAt?: true
    completedAt?: true
    expiresAt?: true
    downloadUrl?: true
    fileSizeBytes?: true
  }

  export type DataExportRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    requestedAt?: true
    completedAt?: true
    expiresAt?: true
    downloadUrl?: true
    fileSizeBytes?: true
  }

  export type DataExportRequestCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    requestedAt?: true
    completedAt?: true
    expiresAt?: true
    downloadUrl?: true
    fileSizeBytes?: true
    _all?: true
  }

  export type DataExportRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataExportRequest to aggregate.
     */
    where?: DataExportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataExportRequests to fetch.
     */
    orderBy?: DataExportRequestOrderByWithRelationInput | DataExportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataExportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataExportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataExportRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataExportRequests
    **/
    _count?: true | DataExportRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataExportRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataExportRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataExportRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataExportRequestMaxAggregateInputType
  }

  export type GetDataExportRequestAggregateType<T extends DataExportRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateDataExportRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataExportRequest[P]>
      : GetScalarType<T[P], AggregateDataExportRequest[P]>
  }




  export type DataExportRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataExportRequestWhereInput
    orderBy?: DataExportRequestOrderByWithAggregationInput | DataExportRequestOrderByWithAggregationInput[]
    by: DataExportRequestScalarFieldEnum[] | DataExportRequestScalarFieldEnum
    having?: DataExportRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataExportRequestCountAggregateInputType | true
    _avg?: DataExportRequestAvgAggregateInputType
    _sum?: DataExportRequestSumAggregateInputType
    _min?: DataExportRequestMinAggregateInputType
    _max?: DataExportRequestMaxAggregateInputType
  }

  export type DataExportRequestGroupByOutputType = {
    id: string
    userId: string
    status: string
    requestedAt: Date
    completedAt: Date | null
    expiresAt: Date | null
    downloadUrl: string | null
    fileSizeBytes: number | null
    _count: DataExportRequestCountAggregateOutputType | null
    _avg: DataExportRequestAvgAggregateOutputType | null
    _sum: DataExportRequestSumAggregateOutputType | null
    _min: DataExportRequestMinAggregateOutputType | null
    _max: DataExportRequestMaxAggregateOutputType | null
  }

  type GetDataExportRequestGroupByPayload<T extends DataExportRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataExportRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataExportRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataExportRequestGroupByOutputType[P]>
            : GetScalarType<T[P], DataExportRequestGroupByOutputType[P]>
        }
      >
    >


  export type DataExportRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    downloadUrl?: boolean
    fileSizeBytes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataExportRequest"]>

  export type DataExportRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    downloadUrl?: boolean
    fileSizeBytes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataExportRequest"]>

  export type DataExportRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    expiresAt?: boolean
    downloadUrl?: boolean
    fileSizeBytes?: boolean
  }

  export type DataExportRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DataExportRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DataExportRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataExportRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: string
      requestedAt: Date
      completedAt: Date | null
      expiresAt: Date | null
      downloadUrl: string | null
      fileSizeBytes: number | null
    }, ExtArgs["result"]["dataExportRequest"]>
    composites: {}
  }

  type DataExportRequestGetPayload<S extends boolean | null | undefined | DataExportRequestDefaultArgs> = $Result.GetResult<Prisma.$DataExportRequestPayload, S>

  type DataExportRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DataExportRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DataExportRequestCountAggregateInputType | true
    }

  export interface DataExportRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataExportRequest'], meta: { name: 'DataExportRequest' } }
    /**
     * Find zero or one DataExportRequest that matches the filter.
     * @param {DataExportRequestFindUniqueArgs} args - Arguments to find a DataExportRequest
     * @example
     * // Get one DataExportRequest
     * const dataExportRequest = await prisma.dataExportRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataExportRequestFindUniqueArgs>(args: SelectSubset<T, DataExportRequestFindUniqueArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DataExportRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DataExportRequestFindUniqueOrThrowArgs} args - Arguments to find a DataExportRequest
     * @example
     * // Get one DataExportRequest
     * const dataExportRequest = await prisma.dataExportRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataExportRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, DataExportRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DataExportRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestFindFirstArgs} args - Arguments to find a DataExportRequest
     * @example
     * // Get one DataExportRequest
     * const dataExportRequest = await prisma.dataExportRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataExportRequestFindFirstArgs>(args?: SelectSubset<T, DataExportRequestFindFirstArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DataExportRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestFindFirstOrThrowArgs} args - Arguments to find a DataExportRequest
     * @example
     * // Get one DataExportRequest
     * const dataExportRequest = await prisma.dataExportRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataExportRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, DataExportRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DataExportRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataExportRequests
     * const dataExportRequests = await prisma.dataExportRequest.findMany()
     * 
     * // Get first 10 DataExportRequests
     * const dataExportRequests = await prisma.dataExportRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataExportRequestWithIdOnly = await prisma.dataExportRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataExportRequestFindManyArgs>(args?: SelectSubset<T, DataExportRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DataExportRequest.
     * @param {DataExportRequestCreateArgs} args - Arguments to create a DataExportRequest.
     * @example
     * // Create one DataExportRequest
     * const DataExportRequest = await prisma.dataExportRequest.create({
     *   data: {
     *     // ... data to create a DataExportRequest
     *   }
     * })
     * 
     */
    create<T extends DataExportRequestCreateArgs>(args: SelectSubset<T, DataExportRequestCreateArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DataExportRequests.
     * @param {DataExportRequestCreateManyArgs} args - Arguments to create many DataExportRequests.
     * @example
     * // Create many DataExportRequests
     * const dataExportRequest = await prisma.dataExportRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataExportRequestCreateManyArgs>(args?: SelectSubset<T, DataExportRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataExportRequests and returns the data saved in the database.
     * @param {DataExportRequestCreateManyAndReturnArgs} args - Arguments to create many DataExportRequests.
     * @example
     * // Create many DataExportRequests
     * const dataExportRequest = await prisma.dataExportRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataExportRequests and only return the `id`
     * const dataExportRequestWithIdOnly = await prisma.dataExportRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataExportRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, DataExportRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DataExportRequest.
     * @param {DataExportRequestDeleteArgs} args - Arguments to delete one DataExportRequest.
     * @example
     * // Delete one DataExportRequest
     * const DataExportRequest = await prisma.dataExportRequest.delete({
     *   where: {
     *     // ... filter to delete one DataExportRequest
     *   }
     * })
     * 
     */
    delete<T extends DataExportRequestDeleteArgs>(args: SelectSubset<T, DataExportRequestDeleteArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DataExportRequest.
     * @param {DataExportRequestUpdateArgs} args - Arguments to update one DataExportRequest.
     * @example
     * // Update one DataExportRequest
     * const dataExportRequest = await prisma.dataExportRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataExportRequestUpdateArgs>(args: SelectSubset<T, DataExportRequestUpdateArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DataExportRequests.
     * @param {DataExportRequestDeleteManyArgs} args - Arguments to filter DataExportRequests to delete.
     * @example
     * // Delete a few DataExportRequests
     * const { count } = await prisma.dataExportRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataExportRequestDeleteManyArgs>(args?: SelectSubset<T, DataExportRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataExportRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataExportRequests
     * const dataExportRequest = await prisma.dataExportRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataExportRequestUpdateManyArgs>(args: SelectSubset<T, DataExportRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataExportRequest.
     * @param {DataExportRequestUpsertArgs} args - Arguments to update or create a DataExportRequest.
     * @example
     * // Update or create a DataExportRequest
     * const dataExportRequest = await prisma.dataExportRequest.upsert({
     *   create: {
     *     // ... data to create a DataExportRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataExportRequest we want to update
     *   }
     * })
     */
    upsert<T extends DataExportRequestUpsertArgs>(args: SelectSubset<T, DataExportRequestUpsertArgs<ExtArgs>>): Prisma__DataExportRequestClient<$Result.GetResult<Prisma.$DataExportRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DataExportRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestCountArgs} args - Arguments to filter DataExportRequests to count.
     * @example
     * // Count the number of DataExportRequests
     * const count = await prisma.dataExportRequest.count({
     *   where: {
     *     // ... the filter for the DataExportRequests we want to count
     *   }
     * })
    **/
    count<T extends DataExportRequestCountArgs>(
      args?: Subset<T, DataExportRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataExportRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataExportRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataExportRequestAggregateArgs>(args: Subset<T, DataExportRequestAggregateArgs>): Prisma.PrismaPromise<GetDataExportRequestAggregateType<T>>

    /**
     * Group by DataExportRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataExportRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataExportRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataExportRequestGroupByArgs['orderBy'] }
        : { orderBy?: DataExportRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataExportRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataExportRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataExportRequest model
   */
  readonly fields: DataExportRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataExportRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataExportRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataExportRequest model
   */ 
  interface DataExportRequestFieldRefs {
    readonly id: FieldRef<"DataExportRequest", 'String'>
    readonly userId: FieldRef<"DataExportRequest", 'String'>
    readonly status: FieldRef<"DataExportRequest", 'String'>
    readonly requestedAt: FieldRef<"DataExportRequest", 'DateTime'>
    readonly completedAt: FieldRef<"DataExportRequest", 'DateTime'>
    readonly expiresAt: FieldRef<"DataExportRequest", 'DateTime'>
    readonly downloadUrl: FieldRef<"DataExportRequest", 'String'>
    readonly fileSizeBytes: FieldRef<"DataExportRequest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DataExportRequest findUnique
   */
  export type DataExportRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataExportRequest to fetch.
     */
    where: DataExportRequestWhereUniqueInput
  }

  /**
   * DataExportRequest findUniqueOrThrow
   */
  export type DataExportRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataExportRequest to fetch.
     */
    where: DataExportRequestWhereUniqueInput
  }

  /**
   * DataExportRequest findFirst
   */
  export type DataExportRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataExportRequest to fetch.
     */
    where?: DataExportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataExportRequests to fetch.
     */
    orderBy?: DataExportRequestOrderByWithRelationInput | DataExportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataExportRequests.
     */
    cursor?: DataExportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataExportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataExportRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataExportRequests.
     */
    distinct?: DataExportRequestScalarFieldEnum | DataExportRequestScalarFieldEnum[]
  }

  /**
   * DataExportRequest findFirstOrThrow
   */
  export type DataExportRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataExportRequest to fetch.
     */
    where?: DataExportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataExportRequests to fetch.
     */
    orderBy?: DataExportRequestOrderByWithRelationInput | DataExportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataExportRequests.
     */
    cursor?: DataExportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataExportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataExportRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataExportRequests.
     */
    distinct?: DataExportRequestScalarFieldEnum | DataExportRequestScalarFieldEnum[]
  }

  /**
   * DataExportRequest findMany
   */
  export type DataExportRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataExportRequests to fetch.
     */
    where?: DataExportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataExportRequests to fetch.
     */
    orderBy?: DataExportRequestOrderByWithRelationInput | DataExportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataExportRequests.
     */
    cursor?: DataExportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataExportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataExportRequests.
     */
    skip?: number
    distinct?: DataExportRequestScalarFieldEnum | DataExportRequestScalarFieldEnum[]
  }

  /**
   * DataExportRequest create
   */
  export type DataExportRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a DataExportRequest.
     */
    data: XOR<DataExportRequestCreateInput, DataExportRequestUncheckedCreateInput>
  }

  /**
   * DataExportRequest createMany
   */
  export type DataExportRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataExportRequests.
     */
    data: DataExportRequestCreateManyInput | DataExportRequestCreateManyInput[]
  }

  /**
   * DataExportRequest createManyAndReturn
   */
  export type DataExportRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DataExportRequests.
     */
    data: DataExportRequestCreateManyInput | DataExportRequestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataExportRequest update
   */
  export type DataExportRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a DataExportRequest.
     */
    data: XOR<DataExportRequestUpdateInput, DataExportRequestUncheckedUpdateInput>
    /**
     * Choose, which DataExportRequest to update.
     */
    where: DataExportRequestWhereUniqueInput
  }

  /**
   * DataExportRequest updateMany
   */
  export type DataExportRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataExportRequests.
     */
    data: XOR<DataExportRequestUpdateManyMutationInput, DataExportRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataExportRequests to update
     */
    where?: DataExportRequestWhereInput
  }

  /**
   * DataExportRequest upsert
   */
  export type DataExportRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the DataExportRequest to update in case it exists.
     */
    where: DataExportRequestWhereUniqueInput
    /**
     * In case the DataExportRequest found by the `where` argument doesn't exist, create a new DataExportRequest with this data.
     */
    create: XOR<DataExportRequestCreateInput, DataExportRequestUncheckedCreateInput>
    /**
     * In case the DataExportRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataExportRequestUpdateInput, DataExportRequestUncheckedUpdateInput>
  }

  /**
   * DataExportRequest delete
   */
  export type DataExportRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
    /**
     * Filter which DataExportRequest to delete.
     */
    where: DataExportRequestWhereUniqueInput
  }

  /**
   * DataExportRequest deleteMany
   */
  export type DataExportRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataExportRequests to delete
     */
    where?: DataExportRequestWhereInput
  }

  /**
   * DataExportRequest without action
   */
  export type DataExportRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataExportRequest
     */
    select?: DataExportRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataExportRequestInclude<ExtArgs> | null
  }


  /**
   * Model DeletionRequest
   */

  export type AggregateDeletionRequest = {
    _count: DeletionRequestCountAggregateOutputType | null
    _min: DeletionRequestMinAggregateOutputType | null
    _max: DeletionRequestMaxAggregateOutputType | null
  }

  export type DeletionRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    reason: string | null
    requestedAt: Date | null
    gracePeriodEndsAt: Date | null
    completedAt: Date | null
    cancelledAt: Date | null
  }

  export type DeletionRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    reason: string | null
    requestedAt: Date | null
    gracePeriodEndsAt: Date | null
    completedAt: Date | null
    cancelledAt: Date | null
  }

  export type DeletionRequestCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    reason: number
    requestedAt: number
    gracePeriodEndsAt: number
    completedAt: number
    cancelledAt: number
    _all: number
  }


  export type DeletionRequestMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    reason?: true
    requestedAt?: true
    gracePeriodEndsAt?: true
    completedAt?: true
    cancelledAt?: true
  }

  export type DeletionRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    reason?: true
    requestedAt?: true
    gracePeriodEndsAt?: true
    completedAt?: true
    cancelledAt?: true
  }

  export type DeletionRequestCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    reason?: true
    requestedAt?: true
    gracePeriodEndsAt?: true
    completedAt?: true
    cancelledAt?: true
    _all?: true
  }

  export type DeletionRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeletionRequest to aggregate.
     */
    where?: DeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletionRequests to fetch.
     */
    orderBy?: DeletionRequestOrderByWithRelationInput | DeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeletionRequests
    **/
    _count?: true | DeletionRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeletionRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeletionRequestMaxAggregateInputType
  }

  export type GetDeletionRequestAggregateType<T extends DeletionRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateDeletionRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeletionRequest[P]>
      : GetScalarType<T[P], AggregateDeletionRequest[P]>
  }




  export type DeletionRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeletionRequestWhereInput
    orderBy?: DeletionRequestOrderByWithAggregationInput | DeletionRequestOrderByWithAggregationInput[]
    by: DeletionRequestScalarFieldEnum[] | DeletionRequestScalarFieldEnum
    having?: DeletionRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeletionRequestCountAggregateInputType | true
    _min?: DeletionRequestMinAggregateInputType
    _max?: DeletionRequestMaxAggregateInputType
  }

  export type DeletionRequestGroupByOutputType = {
    id: string
    userId: string
    status: string
    reason: string | null
    requestedAt: Date
    gracePeriodEndsAt: Date | null
    completedAt: Date | null
    cancelledAt: Date | null
    _count: DeletionRequestCountAggregateOutputType | null
    _min: DeletionRequestMinAggregateOutputType | null
    _max: DeletionRequestMaxAggregateOutputType | null
  }

  type GetDeletionRequestGroupByPayload<T extends DeletionRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeletionRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeletionRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeletionRequestGroupByOutputType[P]>
            : GetScalarType<T[P], DeletionRequestGroupByOutputType[P]>
        }
      >
    >


  export type DeletionRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    reason?: boolean
    requestedAt?: boolean
    gracePeriodEndsAt?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deletionRequest"]>

  export type DeletionRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    reason?: boolean
    requestedAt?: boolean
    gracePeriodEndsAt?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deletionRequest"]>

  export type DeletionRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    reason?: boolean
    requestedAt?: boolean
    gracePeriodEndsAt?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
  }

  export type DeletionRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeletionRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeletionRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeletionRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: string
      reason: string | null
      requestedAt: Date
      gracePeriodEndsAt: Date | null
      completedAt: Date | null
      cancelledAt: Date | null
    }, ExtArgs["result"]["deletionRequest"]>
    composites: {}
  }

  type DeletionRequestGetPayload<S extends boolean | null | undefined | DeletionRequestDefaultArgs> = $Result.GetResult<Prisma.$DeletionRequestPayload, S>

  type DeletionRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeletionRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeletionRequestCountAggregateInputType | true
    }

  export interface DeletionRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeletionRequest'], meta: { name: 'DeletionRequest' } }
    /**
     * Find zero or one DeletionRequest that matches the filter.
     * @param {DeletionRequestFindUniqueArgs} args - Arguments to find a DeletionRequest
     * @example
     * // Get one DeletionRequest
     * const deletionRequest = await prisma.deletionRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeletionRequestFindUniqueArgs>(args: SelectSubset<T, DeletionRequestFindUniqueArgs<ExtArgs>>): Prisma__DeletionRequestClient<$Result.GetResult<Prisma.$DeletionRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeletionRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeletionRequestFindUniqueOrThrowArgs} args - Arguments to find a DeletionRequest
     * @example
     * // Get one DeletionRequest
     * const deletionRequest = await prisma.deletionRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeletionRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, DeletionRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeletionRequestClient<$Result.GetResult<Prisma.$DeletionRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeletionRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletionRequestFindFirstArgs} args - Arguments to find a DeletionRequest
     * @example
     * // Get one DeletionRequest
     * const deletionRequest = await prisma.deletionRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeletionRequestFindFirstArgs>(args?: SelectSubset<T, DeletionRequestFindFirstArgs<ExtArgs>>): Prisma__DeletionRequestClient<$Result.GetResult<Prisma.$DeletionRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeletionRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletionRequestFindFirstOrThrowArgs} args - Arguments to find a DeletionRequest
     * @example
     * // Get one DeletionRequest
     * const deletionRequest = await prisma.deletionRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeletionRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, DeletionRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeletionRequestClient<$Result.GetResult<Prisma.$DeletionRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeletionRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletionRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeletionRequests
     * const deletionRequests = await prisma.deletionRequest.findMany()
     * 
     * // Get first 10 DeletionRequests
     * const deletionRequests = await prisma.deletionRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deletionRequestWithIdOnly = await prisma.deletionRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeletionRequestFindManyArgs>(args?: SelectSubset<T, DeletionRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeletionRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeletionRequest.
     * @param {DeletionRequestCreateArgs} args - Arguments to create a DeletionRequest.
     * @example
     * // Create one DeletionRequest
     * const DeletionRequest = await prisma.deletionRequest.create({
     *   data: {
     *     // ... data to create a DeletionRequest
     *   }
     * })
     * 
     */
    create<T extends DeletionRequestCreateArgs>(args: SelectSubset<T, DeletionRequestCreateArgs<ExtArgs>>): Prisma__DeletionRequestClient<$Result.GetResult<Prisma.$DeletionRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeletionRequests.
     * @param {DeletionRequestCreateManyArgs} args - Arguments to create many DeletionRequests.
     * @example
     * // Create many DeletionRequests
     * const deletionRequest = await prisma.deletionRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeletionRequestCreateManyArgs>(args?: SelectSubset<T, DeletionRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeletionRequests and returns the data saved in the database.
     * @param {DeletionRequestCreateManyAndReturnArgs} args - Arguments to create many DeletionRequests.
     * @example
     * // Create many DeletionRequests
     * const deletionRequest = await prisma.deletionRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeletionRequests and only return the `id`
     * const deletionRequestWithIdOnly = await prisma.deletionRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeletionRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, DeletionRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeletionRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeletionRequest.
     * @param {DeletionRequestDeleteArgs} args - Arguments to delete one DeletionRequest.
     * @example
     * // Delete one DeletionRequest
     * const DeletionRequest = await prisma.deletionRequest.delete({
     *   where: {
     *     // ... filter to delete one DeletionRequest
     *   }
     * })
     * 
     */
    delete<T extends DeletionRequestDeleteArgs>(args: SelectSubset<T, DeletionRequestDeleteArgs<ExtArgs>>): Prisma__DeletionRequestClient<$Result.GetResult<Prisma.$DeletionRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeletionRequest.
     * @param {DeletionRequestUpdateArgs} args - Arguments to update one DeletionRequest.
     * @example
     * // Update one DeletionRequest
     * const deletionRequest = await prisma.deletionRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeletionRequestUpdateArgs>(args: SelectSubset<T, DeletionRequestUpdateArgs<ExtArgs>>): Prisma__DeletionRequestClient<$Result.GetResult<Prisma.$DeletionRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeletionRequests.
     * @param {DeletionRequestDeleteManyArgs} args - Arguments to filter DeletionRequests to delete.
     * @example
     * // Delete a few DeletionRequests
     * const { count } = await prisma.deletionRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeletionRequestDeleteManyArgs>(args?: SelectSubset<T, DeletionRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeletionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletionRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeletionRequests
     * const deletionRequest = await prisma.deletionRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeletionRequestUpdateManyArgs>(args: SelectSubset<T, DeletionRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeletionRequest.
     * @param {DeletionRequestUpsertArgs} args - Arguments to update or create a DeletionRequest.
     * @example
     * // Update or create a DeletionRequest
     * const deletionRequest = await prisma.deletionRequest.upsert({
     *   create: {
     *     // ... data to create a DeletionRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeletionRequest we want to update
     *   }
     * })
     */
    upsert<T extends DeletionRequestUpsertArgs>(args: SelectSubset<T, DeletionRequestUpsertArgs<ExtArgs>>): Prisma__DeletionRequestClient<$Result.GetResult<Prisma.$DeletionRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeletionRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletionRequestCountArgs} args - Arguments to filter DeletionRequests to count.
     * @example
     * // Count the number of DeletionRequests
     * const count = await prisma.deletionRequest.count({
     *   where: {
     *     // ... the filter for the DeletionRequests we want to count
     *   }
     * })
    **/
    count<T extends DeletionRequestCountArgs>(
      args?: Subset<T, DeletionRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeletionRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeletionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletionRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeletionRequestAggregateArgs>(args: Subset<T, DeletionRequestAggregateArgs>): Prisma.PrismaPromise<GetDeletionRequestAggregateType<T>>

    /**
     * Group by DeletionRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletionRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeletionRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeletionRequestGroupByArgs['orderBy'] }
        : { orderBy?: DeletionRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeletionRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeletionRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeletionRequest model
   */
  readonly fields: DeletionRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeletionRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeletionRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeletionRequest model
   */ 
  interface DeletionRequestFieldRefs {
    readonly id: FieldRef<"DeletionRequest", 'String'>
    readonly userId: FieldRef<"DeletionRequest", 'String'>
    readonly status: FieldRef<"DeletionRequest", 'String'>
    readonly reason: FieldRef<"DeletionRequest", 'String'>
    readonly requestedAt: FieldRef<"DeletionRequest", 'DateTime'>
    readonly gracePeriodEndsAt: FieldRef<"DeletionRequest", 'DateTime'>
    readonly completedAt: FieldRef<"DeletionRequest", 'DateTime'>
    readonly cancelledAt: FieldRef<"DeletionRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeletionRequest findUnique
   */
  export type DeletionRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletionRequest
     */
    select?: DeletionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DeletionRequest to fetch.
     */
    where: DeletionRequestWhereUniqueInput
  }

  /**
   * DeletionRequest findUniqueOrThrow
   */
  export type DeletionRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletionRequest
     */
    select?: DeletionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DeletionRequest to fetch.
     */
    where: DeletionRequestWhereUniqueInput
  }

  /**
   * DeletionRequest findFirst
   */
  export type DeletionRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletionRequest
     */
    select?: DeletionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DeletionRequest to fetch.
     */
    where?: DeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletionRequests to fetch.
     */
    orderBy?: DeletionRequestOrderByWithRelationInput | DeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeletionRequests.
     */
    cursor?: DeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeletionRequests.
     */
    distinct?: DeletionRequestScalarFieldEnum | DeletionRequestScalarFieldEnum[]
  }

  /**
   * DeletionRequest findFirstOrThrow
   */
  export type DeletionRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletionRequest
     */
    select?: DeletionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DeletionRequest to fetch.
     */
    where?: DeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletionRequests to fetch.
     */
    orderBy?: DeletionRequestOrderByWithRelationInput | DeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeletionRequests.
     */
    cursor?: DeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletionRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeletionRequests.
     */
    distinct?: DeletionRequestScalarFieldEnum | DeletionRequestScalarFieldEnum[]
  }

  /**
   * DeletionRequest findMany
   */
  export type DeletionRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletionRequest
     */
    select?: DeletionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletionRequestInclude<ExtArgs> | null
    /**
     * Filter, which DeletionRequests to fetch.
     */
    where?: DeletionRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletionRequests to fetch.
     */
    orderBy?: DeletionRequestOrderByWithRelationInput | DeletionRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeletionRequests.
     */
    cursor?: DeletionRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletionRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletionRequests.
     */
    skip?: number
    distinct?: DeletionRequestScalarFieldEnum | DeletionRequestScalarFieldEnum[]
  }

  /**
   * DeletionRequest create
   */
  export type DeletionRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletionRequest
     */
    select?: DeletionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletionRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a DeletionRequest.
     */
    data: XOR<DeletionRequestCreateInput, DeletionRequestUncheckedCreateInput>
  }

  /**
   * DeletionRequest createMany
   */
  export type DeletionRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeletionRequests.
     */
    data: DeletionRequestCreateManyInput | DeletionRequestCreateManyInput[]
  }

  /**
   * DeletionRequest createManyAndReturn
   */
  export type DeletionRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletionRequest
     */
    select?: DeletionRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeletionRequests.
     */
    data: DeletionRequestCreateManyInput | DeletionRequestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletionRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeletionRequest update
   */
  export type DeletionRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletionRequest
     */
    select?: DeletionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletionRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a DeletionRequest.
     */
    data: XOR<DeletionRequestUpdateInput, DeletionRequestUncheckedUpdateInput>
    /**
     * Choose, which DeletionRequest to update.
     */
    where: DeletionRequestWhereUniqueInput
  }

  /**
   * DeletionRequest updateMany
   */
  export type DeletionRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeletionRequests.
     */
    data: XOR<DeletionRequestUpdateManyMutationInput, DeletionRequestUncheckedUpdateManyInput>
    /**
     * Filter which DeletionRequests to update
     */
    where?: DeletionRequestWhereInput
  }

  /**
   * DeletionRequest upsert
   */
  export type DeletionRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletionRequest
     */
    select?: DeletionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletionRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the DeletionRequest to update in case it exists.
     */
    where: DeletionRequestWhereUniqueInput
    /**
     * In case the DeletionRequest found by the `where` argument doesn't exist, create a new DeletionRequest with this data.
     */
    create: XOR<DeletionRequestCreateInput, DeletionRequestUncheckedCreateInput>
    /**
     * In case the DeletionRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeletionRequestUpdateInput, DeletionRequestUncheckedUpdateInput>
  }

  /**
   * DeletionRequest delete
   */
  export type DeletionRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletionRequest
     */
    select?: DeletionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletionRequestInclude<ExtArgs> | null
    /**
     * Filter which DeletionRequest to delete.
     */
    where: DeletionRequestWhereUniqueInput
  }

  /**
   * DeletionRequest deleteMany
   */
  export type DeletionRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeletionRequests to delete
     */
    where?: DeletionRequestWhereInput
  }

  /**
   * DeletionRequest without action
   */
  export type DeletionRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletionRequest
     */
    select?: DeletionRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletionRequestInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserOnboardingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    completedAt: 'completedAt',
    skipped: 'skipped',
    primaryGoal: 'primaryGoal',
    experienceLevel: 'experienceLevel',
    toeTouchScore: 'toeTouchScore',
    shoulderReachScore: 'shoulderReachScore',
    hipFlexibilityScore: 'hipFlexibilityScore',
    overallFlexibilityScore: 'overallFlexibilityScore',
    flexibilityLevel: 'flexibilityLevel',
    workoutDays: 'workoutDays',
    preferredWorkoutTime: 'preferredWorkoutTime',
    stretchingPreference: 'stretchingPreference',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserOnboardingScalarFieldEnum = (typeof UserOnboardingScalarFieldEnum)[keyof typeof UserOnboardingScalarFieldEnum]


  export const UserFollowScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    followingUserId: 'followingUserId',
    createdAt: 'createdAt'
  };

  export type UserFollowScalarFieldEnum = (typeof UserFollowScalarFieldEnum)[keyof typeof UserFollowScalarFieldEnum]


  export const StretchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    durationSeconds: 'durationSeconds',
    videoUrl: 'videoUrl',
    thumbnailUrl: 'thumbnailUrl',
    animationUrl: 'animationUrl',
    difficulty: 'difficulty',
    primaryMuscles: 'primaryMuscles',
    secondaryMuscles: 'secondaryMuscles',
    instructions: 'instructions',
    tips: 'tips',
    commonMistakes: 'commonMistakes',
    equipment: 'equipment',
    tags: 'tags',
    createdAt: 'createdAt'
  };

  export type StretchScalarFieldEnum = (typeof StretchScalarFieldEnum)[keyof typeof StretchScalarFieldEnum]


  export const StretchingRoutineScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    difficulty: 'difficulty',
    durationSeconds: 'durationSeconds',
    targetAreas: 'targetAreas',
    tags: 'tags',
    isPublic: 'isPublic',
    isSystem: 'isSystem',
    usesCount: 'usesCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StretchingRoutineScalarFieldEnum = (typeof StretchingRoutineScalarFieldEnum)[keyof typeof StretchingRoutineScalarFieldEnum]


  export const RoutineStretchScalarFieldEnum: {
    id: 'id',
    routineId: 'routineId',
    stretchId: 'stretchId',
    positionOrder: 'positionOrder',
    customDurationSeconds: 'customDurationSeconds'
  };

  export type RoutineStretchScalarFieldEnum = (typeof RoutineStretchScalarFieldEnum)[keyof typeof RoutineStretchScalarFieldEnum]


  export const StretchingSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    routineId: 'routineId',
    routineName: 'routineName',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    durationSeconds: 'durationSeconds',
    completed: 'completed',
    linkedWorkoutId: 'linkedWorkoutId',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type StretchingSessionScalarFieldEnum = (typeof StretchingSessionScalarFieldEnum)[keyof typeof StretchingSessionScalarFieldEnum]


  export const SessionStretchScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    stretchId: 'stretchId',
    heldDurationSeconds: 'heldDurationSeconds',
    feltTight: 'feltTight',
    positionInRoutine: 'positionInRoutine',
    completedAt: 'completedAt'
  };

  export type SessionStretchScalarFieldEnum = (typeof SessionStretchScalarFieldEnum)[keyof typeof SessionStretchScalarFieldEnum]


  export const FlexibilityGoalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    goalType: 'goalType',
    description: 'description',
    targetArea: 'targetArea',
    baselineRom: 'baselineRom',
    targetRom: 'targetRom',
    targetDate: 'targetDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FlexibilityGoalScalarFieldEnum = (typeof FlexibilityGoalScalarFieldEnum)[keyof typeof FlexibilityGoalScalarFieldEnum]


  export const RomMeasurementScalarFieldEnum: {
    id: 'id',
    goalId: 'goalId',
    romDegrees: 'romDegrees',
    measurementDate: 'measurementDate',
    measurementMethod: 'measurementMethod',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type RomMeasurementScalarFieldEnum = (typeof RomMeasurementScalarFieldEnum)[keyof typeof RomMeasurementScalarFieldEnum]


  export const ProgressVideoScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    goalId: 'goalId',
    videoUrl: 'videoUrl',
    uploadedAt: 'uploadedAt'
  };

  export type ProgressVideoScalarFieldEnum = (typeof ProgressVideoScalarFieldEnum)[keyof typeof ProgressVideoScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    equipmentNeeded: 'equipmentNeeded',
    videoUrl: 'videoUrl',
    thumbnailUrl: 'thumbnailUrl',
    primaryMuscles: 'primaryMuscles',
    secondaryMuscles: 'secondaryMuscles',
    difficulty: 'difficulty',
    instructions: 'instructions',
    tips: 'tips',
    commonMistakes: 'commonMistakes',
    isCompound: 'isCompound',
    isUnilateral: 'isUnilateral',
    forceType: 'forceType',
    mechanic: 'mechanic',
    metValue: 'metValue',
    is1RMEligible: 'is1RMEligible',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const StrengthWorkoutScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    durationSeconds: 'durationSeconds',
    sessionIntensityRpe: 'sessionIntensityRpe',
    notes: 'notes',
    totalVolume: 'totalVolume',
    createdAt: 'createdAt'
  };

  export type StrengthWorkoutScalarFieldEnum = (typeof StrengthWorkoutScalarFieldEnum)[keyof typeof StrengthWorkoutScalarFieldEnum]


  export const WorkoutExerciseScalarFieldEnum: {
    id: 'id',
    workoutId: 'workoutId',
    exerciseId: 'exerciseId',
    positionOrder: 'positionOrder',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type WorkoutExerciseScalarFieldEnum = (typeof WorkoutExerciseScalarFieldEnum)[keyof typeof WorkoutExerciseScalarFieldEnum]


  export const WorkoutSetScalarFieldEnum: {
    id: 'id',
    workoutExerciseId: 'workoutExerciseId',
    setNumber: 'setNumber',
    reps: 'reps',
    weight: 'weight',
    weightUnit: 'weightUnit',
    setType: 'setType',
    rpe: 'rpe',
    isPr: 'isPr',
    completed: 'completed',
    restSeconds: 'restSeconds',
    durationSeconds: 'durationSeconds',
    distanceMeters: 'distanceMeters',
    createdAt: 'createdAt'
  };

  export type WorkoutSetScalarFieldEnum = (typeof WorkoutSetScalarFieldEnum)[keyof typeof WorkoutSetScalarFieldEnum]


  export const PersonalRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    exerciseId: 'exerciseId',
    recordType: 'recordType',
    value: 'value',
    weightUnit: 'weightUnit',
    achievedAt: 'achievedAt',
    workoutId: 'workoutId'
  };

  export type PersonalRecordScalarFieldEnum = (typeof PersonalRecordScalarFieldEnum)[keyof typeof PersonalRecordScalarFieldEnum]


  export const BodyMetricScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    weight: 'weight',
    weightUnit: 'weightUnit',
    bodyFatPercentage: 'bodyFatPercentage',
    chest: 'chest',
    waist: 'waist',
    hips: 'hips',
    arms: 'arms',
    thighs: 'thighs',
    measurementUnit: 'measurementUnit',
    measurementDate: 'measurementDate',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type BodyMetricScalarFieldEnum = (typeof BodyMetricScalarFieldEnum)[keyof typeof BodyMetricScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    notificationType: 'notificationType',
    title: 'title',
    body: 'body',
    actionType: 'actionType',
    actionData: 'actionData',
    sentAt: 'sentAt',
    readAt: 'readAt',
    clickedAt: 'clickedAt',
    deliveryStatus: 'deliveryStatus',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    notificationsEnabled: 'notificationsEnabled',
    stretchReminders: 'stretchReminders',
    workoutReminders: 'workoutReminders',
    streakNotifications: 'streakNotifications',
    goalNotifications: 'goalNotifications',
    socialNotifications: 'socialNotifications',
    recoverySuggestions: 'recoverySuggestions',
    inactivityNudges: 'inactivityNudges',
    quietHoursEnabled: 'quietHoursEnabled',
    quietHoursStart: 'quietHoursStart',
    quietHoursEnd: 'quietHoursEnd',
    maxDailyNotifications: 'maxDailyNotifications',
    stretchReminderTime: 'stretchReminderTime',
    workoutReminderTime: 'workoutReminderTime',
    reminderDays: 'reminderDays',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planType: 'planType',
    status: 'status',
    pricePaid: 'pricePaid',
    currency: 'currency',
    startedAt: 'startedAt',
    expiresAt: 'expiresAt',
    cancelledAt: 'cancelledAt',
    provider: 'provider',
    providerSubscriptionId: 'providerSubscriptionId',
    providerCustomerId: 'providerCustomerId',
    trialStartedAt: 'trialStartedAt',
    trialEndsAt: 'trialEndsAt',
    isTrial: 'isTrial',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const UserConsentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    consentType: 'consentType',
    version: 'version',
    consented: 'consented',
    consentedAt: 'consentedAt',
    withdrawnAt: 'withdrawnAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type UserConsentScalarFieldEnum = (typeof UserConsentScalarFieldEnum)[keyof typeof UserConsentScalarFieldEnum]


  export const DataExportRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    requestedAt: 'requestedAt',
    completedAt: 'completedAt',
    expiresAt: 'expiresAt',
    downloadUrl: 'downloadUrl',
    fileSizeBytes: 'fileSizeBytes'
  };

  export type DataExportRequestScalarFieldEnum = (typeof DataExportRequestScalarFieldEnum)[keyof typeof DataExportRequestScalarFieldEnum]


  export const DeletionRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    reason: 'reason',
    requestedAt: 'requestedAt',
    gracePeriodEndsAt: 'gracePeriodEndsAt',
    completedAt: 'completedAt',
    cancelledAt: 'cancelledAt'
  };

  export type DeletionRequestScalarFieldEnum = (typeof DeletionRequestScalarFieldEnum)[keyof typeof DeletionRequestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    onboarding?: XOR<UserOnboardingNullableRelationFilter, UserOnboardingWhereInput> | null
    notificationPrefs?: XOR<NotificationPreferenceNullableRelationFilter, NotificationPreferenceWhereInput> | null
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    stretchingRoutines?: StretchingRoutineListRelationFilter
    stretchingSessions?: StretchingSessionListRelationFilter
    flexibilityGoals?: FlexibilityGoalListRelationFilter
    bodyMetrics?: BodyMetricListRelationFilter
    strengthWorkouts?: StrengthWorkoutListRelationFilter
    personalRecords?: PersonalRecordListRelationFilter
    notifications?: NotificationListRelationFilter
    consents?: UserConsentListRelationFilter
    following?: UserFollowListRelationFilter
    followers?: UserFollowListRelationFilter
    progressVideos?: ProgressVideoListRelationFilter
    dataExportRequests?: DataExportRequestListRelationFilter
    deletionRequests?: DeletionRequestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    onboarding?: UserOnboardingOrderByWithRelationInput
    notificationPrefs?: NotificationPreferenceOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
    stretchingRoutines?: StretchingRoutineOrderByRelationAggregateInput
    stretchingSessions?: StretchingSessionOrderByRelationAggregateInput
    flexibilityGoals?: FlexibilityGoalOrderByRelationAggregateInput
    bodyMetrics?: BodyMetricOrderByRelationAggregateInput
    strengthWorkouts?: StrengthWorkoutOrderByRelationAggregateInput
    personalRecords?: PersonalRecordOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    consents?: UserConsentOrderByRelationAggregateInput
    following?: UserFollowOrderByRelationAggregateInput
    followers?: UserFollowOrderByRelationAggregateInput
    progressVideos?: ProgressVideoOrderByRelationAggregateInput
    dataExportRequests?: DataExportRequestOrderByRelationAggregateInput
    deletionRequests?: DeletionRequestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    onboarding?: XOR<UserOnboardingNullableRelationFilter, UserOnboardingWhereInput> | null
    notificationPrefs?: XOR<NotificationPreferenceNullableRelationFilter, NotificationPreferenceWhereInput> | null
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    stretchingRoutines?: StretchingRoutineListRelationFilter
    stretchingSessions?: StretchingSessionListRelationFilter
    flexibilityGoals?: FlexibilityGoalListRelationFilter
    bodyMetrics?: BodyMetricListRelationFilter
    strengthWorkouts?: StrengthWorkoutListRelationFilter
    personalRecords?: PersonalRecordListRelationFilter
    notifications?: NotificationListRelationFilter
    consents?: UserConsentListRelationFilter
    following?: UserFollowListRelationFilter
    followers?: UserFollowListRelationFilter
    progressVideos?: ProgressVideoListRelationFilter
    dataExportRequests?: DataExportRequestListRelationFilter
    deletionRequests?: DeletionRequestListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserOnboardingWhereInput = {
    AND?: UserOnboardingWhereInput | UserOnboardingWhereInput[]
    OR?: UserOnboardingWhereInput[]
    NOT?: UserOnboardingWhereInput | UserOnboardingWhereInput[]
    id?: StringFilter<"UserOnboarding"> | string
    userId?: StringFilter<"UserOnboarding"> | string
    completedAt?: DateTimeNullableFilter<"UserOnboarding"> | Date | string | null
    skipped?: BoolFilter<"UserOnboarding"> | boolean
    primaryGoal?: StringNullableFilter<"UserOnboarding"> | string | null
    experienceLevel?: StringNullableFilter<"UserOnboarding"> | string | null
    toeTouchScore?: IntNullableFilter<"UserOnboarding"> | number | null
    shoulderReachScore?: IntNullableFilter<"UserOnboarding"> | number | null
    hipFlexibilityScore?: IntNullableFilter<"UserOnboarding"> | number | null
    overallFlexibilityScore?: IntNullableFilter<"UserOnboarding"> | number | null
    flexibilityLevel?: StringNullableFilter<"UserOnboarding"> | string | null
    workoutDays?: StringNullableFilter<"UserOnboarding"> | string | null
    preferredWorkoutTime?: StringNullableFilter<"UserOnboarding"> | string | null
    stretchingPreference?: StringNullableFilter<"UserOnboarding"> | string | null
    createdAt?: DateTimeFilter<"UserOnboarding"> | Date | string
    updatedAt?: DateTimeFilter<"UserOnboarding"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserOnboardingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    skipped?: SortOrder
    primaryGoal?: SortOrderInput | SortOrder
    experienceLevel?: SortOrderInput | SortOrder
    toeTouchScore?: SortOrderInput | SortOrder
    shoulderReachScore?: SortOrderInput | SortOrder
    hipFlexibilityScore?: SortOrderInput | SortOrder
    overallFlexibilityScore?: SortOrderInput | SortOrder
    flexibilityLevel?: SortOrderInput | SortOrder
    workoutDays?: SortOrderInput | SortOrder
    preferredWorkoutTime?: SortOrderInput | SortOrder
    stretchingPreference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserOnboardingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserOnboardingWhereInput | UserOnboardingWhereInput[]
    OR?: UserOnboardingWhereInput[]
    NOT?: UserOnboardingWhereInput | UserOnboardingWhereInput[]
    completedAt?: DateTimeNullableFilter<"UserOnboarding"> | Date | string | null
    skipped?: BoolFilter<"UserOnboarding"> | boolean
    primaryGoal?: StringNullableFilter<"UserOnboarding"> | string | null
    experienceLevel?: StringNullableFilter<"UserOnboarding"> | string | null
    toeTouchScore?: IntNullableFilter<"UserOnboarding"> | number | null
    shoulderReachScore?: IntNullableFilter<"UserOnboarding"> | number | null
    hipFlexibilityScore?: IntNullableFilter<"UserOnboarding"> | number | null
    overallFlexibilityScore?: IntNullableFilter<"UserOnboarding"> | number | null
    flexibilityLevel?: StringNullableFilter<"UserOnboarding"> | string | null
    workoutDays?: StringNullableFilter<"UserOnboarding"> | string | null
    preferredWorkoutTime?: StringNullableFilter<"UserOnboarding"> | string | null
    stretchingPreference?: StringNullableFilter<"UserOnboarding"> | string | null
    createdAt?: DateTimeFilter<"UserOnboarding"> | Date | string
    updatedAt?: DateTimeFilter<"UserOnboarding"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserOnboardingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    skipped?: SortOrder
    primaryGoal?: SortOrderInput | SortOrder
    experienceLevel?: SortOrderInput | SortOrder
    toeTouchScore?: SortOrderInput | SortOrder
    shoulderReachScore?: SortOrderInput | SortOrder
    hipFlexibilityScore?: SortOrderInput | SortOrder
    overallFlexibilityScore?: SortOrderInput | SortOrder
    flexibilityLevel?: SortOrderInput | SortOrder
    workoutDays?: SortOrderInput | SortOrder
    preferredWorkoutTime?: SortOrderInput | SortOrder
    stretchingPreference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserOnboardingCountOrderByAggregateInput
    _avg?: UserOnboardingAvgOrderByAggregateInput
    _max?: UserOnboardingMaxOrderByAggregateInput
    _min?: UserOnboardingMinOrderByAggregateInput
    _sum?: UserOnboardingSumOrderByAggregateInput
  }

  export type UserOnboardingScalarWhereWithAggregatesInput = {
    AND?: UserOnboardingScalarWhereWithAggregatesInput | UserOnboardingScalarWhereWithAggregatesInput[]
    OR?: UserOnboardingScalarWhereWithAggregatesInput[]
    NOT?: UserOnboardingScalarWhereWithAggregatesInput | UserOnboardingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserOnboarding"> | string
    userId?: StringWithAggregatesFilter<"UserOnboarding"> | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserOnboarding"> | Date | string | null
    skipped?: BoolWithAggregatesFilter<"UserOnboarding"> | boolean
    primaryGoal?: StringNullableWithAggregatesFilter<"UserOnboarding"> | string | null
    experienceLevel?: StringNullableWithAggregatesFilter<"UserOnboarding"> | string | null
    toeTouchScore?: IntNullableWithAggregatesFilter<"UserOnboarding"> | number | null
    shoulderReachScore?: IntNullableWithAggregatesFilter<"UserOnboarding"> | number | null
    hipFlexibilityScore?: IntNullableWithAggregatesFilter<"UserOnboarding"> | number | null
    overallFlexibilityScore?: IntNullableWithAggregatesFilter<"UserOnboarding"> | number | null
    flexibilityLevel?: StringNullableWithAggregatesFilter<"UserOnboarding"> | string | null
    workoutDays?: StringNullableWithAggregatesFilter<"UserOnboarding"> | string | null
    preferredWorkoutTime?: StringNullableWithAggregatesFilter<"UserOnboarding"> | string | null
    stretchingPreference?: StringNullableWithAggregatesFilter<"UserOnboarding"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserOnboarding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserOnboarding"> | Date | string
  }

  export type UserFollowWhereInput = {
    AND?: UserFollowWhereInput | UserFollowWhereInput[]
    OR?: UserFollowWhereInput[]
    NOT?: UserFollowWhereInput | UserFollowWhereInput[]
    id?: StringFilter<"UserFollow"> | string
    userId?: StringFilter<"UserFollow"> | string
    followingUserId?: StringFilter<"UserFollow"> | string
    createdAt?: DateTimeFilter<"UserFollow"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    following?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserFollowOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    followingUserId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type UserFollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_followingUserId?: UserFollowUserIdFollowingUserIdCompoundUniqueInput
    AND?: UserFollowWhereInput | UserFollowWhereInput[]
    OR?: UserFollowWhereInput[]
    NOT?: UserFollowWhereInput | UserFollowWhereInput[]
    userId?: StringFilter<"UserFollow"> | string
    followingUserId?: StringFilter<"UserFollow"> | string
    createdAt?: DateTimeFilter<"UserFollow"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    following?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_followingUserId">

  export type UserFollowOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    followingUserId?: SortOrder
    createdAt?: SortOrder
    _count?: UserFollowCountOrderByAggregateInput
    _max?: UserFollowMaxOrderByAggregateInput
    _min?: UserFollowMinOrderByAggregateInput
  }

  export type UserFollowScalarWhereWithAggregatesInput = {
    AND?: UserFollowScalarWhereWithAggregatesInput | UserFollowScalarWhereWithAggregatesInput[]
    OR?: UserFollowScalarWhereWithAggregatesInput[]
    NOT?: UserFollowScalarWhereWithAggregatesInput | UserFollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFollow"> | string
    userId?: StringWithAggregatesFilter<"UserFollow"> | string
    followingUserId?: StringWithAggregatesFilter<"UserFollow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserFollow"> | Date | string
  }

  export type StretchWhereInput = {
    AND?: StretchWhereInput | StretchWhereInput[]
    OR?: StretchWhereInput[]
    NOT?: StretchWhereInput | StretchWhereInput[]
    id?: StringFilter<"Stretch"> | string
    name?: StringFilter<"Stretch"> | string
    description?: StringNullableFilter<"Stretch"> | string | null
    durationSeconds?: IntFilter<"Stretch"> | number
    videoUrl?: StringNullableFilter<"Stretch"> | string | null
    thumbnailUrl?: StringNullableFilter<"Stretch"> | string | null
    animationUrl?: StringNullableFilter<"Stretch"> | string | null
    difficulty?: StringFilter<"Stretch"> | string
    primaryMuscles?: StringFilter<"Stretch"> | string
    secondaryMuscles?: StringNullableFilter<"Stretch"> | string | null
    instructions?: StringNullableFilter<"Stretch"> | string | null
    tips?: StringNullableFilter<"Stretch"> | string | null
    commonMistakes?: StringNullableFilter<"Stretch"> | string | null
    equipment?: StringNullableFilter<"Stretch"> | string | null
    tags?: StringNullableFilter<"Stretch"> | string | null
    createdAt?: DateTimeFilter<"Stretch"> | Date | string
    routineStretches?: RoutineStretchListRelationFilter
    sessionStretches?: SessionStretchListRelationFilter
  }

  export type StretchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    durationSeconds?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    animationUrl?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    tips?: SortOrderInput | SortOrder
    commonMistakes?: SortOrderInput | SortOrder
    equipment?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    routineStretches?: RoutineStretchOrderByRelationAggregateInput
    sessionStretches?: SessionStretchOrderByRelationAggregateInput
  }

  export type StretchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StretchWhereInput | StretchWhereInput[]
    OR?: StretchWhereInput[]
    NOT?: StretchWhereInput | StretchWhereInput[]
    name?: StringFilter<"Stretch"> | string
    description?: StringNullableFilter<"Stretch"> | string | null
    durationSeconds?: IntFilter<"Stretch"> | number
    videoUrl?: StringNullableFilter<"Stretch"> | string | null
    thumbnailUrl?: StringNullableFilter<"Stretch"> | string | null
    animationUrl?: StringNullableFilter<"Stretch"> | string | null
    difficulty?: StringFilter<"Stretch"> | string
    primaryMuscles?: StringFilter<"Stretch"> | string
    secondaryMuscles?: StringNullableFilter<"Stretch"> | string | null
    instructions?: StringNullableFilter<"Stretch"> | string | null
    tips?: StringNullableFilter<"Stretch"> | string | null
    commonMistakes?: StringNullableFilter<"Stretch"> | string | null
    equipment?: StringNullableFilter<"Stretch"> | string | null
    tags?: StringNullableFilter<"Stretch"> | string | null
    createdAt?: DateTimeFilter<"Stretch"> | Date | string
    routineStretches?: RoutineStretchListRelationFilter
    sessionStretches?: SessionStretchListRelationFilter
  }, "id">

  export type StretchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    durationSeconds?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    animationUrl?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    tips?: SortOrderInput | SortOrder
    commonMistakes?: SortOrderInput | SortOrder
    equipment?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StretchCountOrderByAggregateInput
    _avg?: StretchAvgOrderByAggregateInput
    _max?: StretchMaxOrderByAggregateInput
    _min?: StretchMinOrderByAggregateInput
    _sum?: StretchSumOrderByAggregateInput
  }

  export type StretchScalarWhereWithAggregatesInput = {
    AND?: StretchScalarWhereWithAggregatesInput | StretchScalarWhereWithAggregatesInput[]
    OR?: StretchScalarWhereWithAggregatesInput[]
    NOT?: StretchScalarWhereWithAggregatesInput | StretchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stretch"> | string
    name?: StringWithAggregatesFilter<"Stretch"> | string
    description?: StringNullableWithAggregatesFilter<"Stretch"> | string | null
    durationSeconds?: IntWithAggregatesFilter<"Stretch"> | number
    videoUrl?: StringNullableWithAggregatesFilter<"Stretch"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Stretch"> | string | null
    animationUrl?: StringNullableWithAggregatesFilter<"Stretch"> | string | null
    difficulty?: StringWithAggregatesFilter<"Stretch"> | string
    primaryMuscles?: StringWithAggregatesFilter<"Stretch"> | string
    secondaryMuscles?: StringNullableWithAggregatesFilter<"Stretch"> | string | null
    instructions?: StringNullableWithAggregatesFilter<"Stretch"> | string | null
    tips?: StringNullableWithAggregatesFilter<"Stretch"> | string | null
    commonMistakes?: StringNullableWithAggregatesFilter<"Stretch"> | string | null
    equipment?: StringNullableWithAggregatesFilter<"Stretch"> | string | null
    tags?: StringNullableWithAggregatesFilter<"Stretch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Stretch"> | Date | string
  }

  export type StretchingRoutineWhereInput = {
    AND?: StretchingRoutineWhereInput | StretchingRoutineWhereInput[]
    OR?: StretchingRoutineWhereInput[]
    NOT?: StretchingRoutineWhereInput | StretchingRoutineWhereInput[]
    id?: StringFilter<"StretchingRoutine"> | string
    userId?: StringNullableFilter<"StretchingRoutine"> | string | null
    name?: StringFilter<"StretchingRoutine"> | string
    description?: StringNullableFilter<"StretchingRoutine"> | string | null
    difficulty?: StringFilter<"StretchingRoutine"> | string
    durationSeconds?: IntFilter<"StretchingRoutine"> | number
    targetAreas?: StringNullableFilter<"StretchingRoutine"> | string | null
    tags?: StringNullableFilter<"StretchingRoutine"> | string | null
    isPublic?: BoolFilter<"StretchingRoutine"> | boolean
    isSystem?: BoolFilter<"StretchingRoutine"> | boolean
    usesCount?: IntFilter<"StretchingRoutine"> | number
    createdAt?: DateTimeFilter<"StretchingRoutine"> | Date | string
    updatedAt?: DateTimeFilter<"StretchingRoutine"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    stretches?: RoutineStretchListRelationFilter
    sessions?: StretchingSessionListRelationFilter
  }

  export type StretchingRoutineOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    durationSeconds?: SortOrder
    targetAreas?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isSystem?: SortOrder
    usesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    stretches?: RoutineStretchOrderByRelationAggregateInput
    sessions?: StretchingSessionOrderByRelationAggregateInput
  }

  export type StretchingRoutineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StretchingRoutineWhereInput | StretchingRoutineWhereInput[]
    OR?: StretchingRoutineWhereInput[]
    NOT?: StretchingRoutineWhereInput | StretchingRoutineWhereInput[]
    userId?: StringNullableFilter<"StretchingRoutine"> | string | null
    name?: StringFilter<"StretchingRoutine"> | string
    description?: StringNullableFilter<"StretchingRoutine"> | string | null
    difficulty?: StringFilter<"StretchingRoutine"> | string
    durationSeconds?: IntFilter<"StretchingRoutine"> | number
    targetAreas?: StringNullableFilter<"StretchingRoutine"> | string | null
    tags?: StringNullableFilter<"StretchingRoutine"> | string | null
    isPublic?: BoolFilter<"StretchingRoutine"> | boolean
    isSystem?: BoolFilter<"StretchingRoutine"> | boolean
    usesCount?: IntFilter<"StretchingRoutine"> | number
    createdAt?: DateTimeFilter<"StretchingRoutine"> | Date | string
    updatedAt?: DateTimeFilter<"StretchingRoutine"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    stretches?: RoutineStretchListRelationFilter
    sessions?: StretchingSessionListRelationFilter
  }, "id">

  export type StretchingRoutineOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    durationSeconds?: SortOrder
    targetAreas?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isSystem?: SortOrder
    usesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StretchingRoutineCountOrderByAggregateInput
    _avg?: StretchingRoutineAvgOrderByAggregateInput
    _max?: StretchingRoutineMaxOrderByAggregateInput
    _min?: StretchingRoutineMinOrderByAggregateInput
    _sum?: StretchingRoutineSumOrderByAggregateInput
  }

  export type StretchingRoutineScalarWhereWithAggregatesInput = {
    AND?: StretchingRoutineScalarWhereWithAggregatesInput | StretchingRoutineScalarWhereWithAggregatesInput[]
    OR?: StretchingRoutineScalarWhereWithAggregatesInput[]
    NOT?: StretchingRoutineScalarWhereWithAggregatesInput | StretchingRoutineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StretchingRoutine"> | string
    userId?: StringNullableWithAggregatesFilter<"StretchingRoutine"> | string | null
    name?: StringWithAggregatesFilter<"StretchingRoutine"> | string
    description?: StringNullableWithAggregatesFilter<"StretchingRoutine"> | string | null
    difficulty?: StringWithAggregatesFilter<"StretchingRoutine"> | string
    durationSeconds?: IntWithAggregatesFilter<"StretchingRoutine"> | number
    targetAreas?: StringNullableWithAggregatesFilter<"StretchingRoutine"> | string | null
    tags?: StringNullableWithAggregatesFilter<"StretchingRoutine"> | string | null
    isPublic?: BoolWithAggregatesFilter<"StretchingRoutine"> | boolean
    isSystem?: BoolWithAggregatesFilter<"StretchingRoutine"> | boolean
    usesCount?: IntWithAggregatesFilter<"StretchingRoutine"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StretchingRoutine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StretchingRoutine"> | Date | string
  }

  export type RoutineStretchWhereInput = {
    AND?: RoutineStretchWhereInput | RoutineStretchWhereInput[]
    OR?: RoutineStretchWhereInput[]
    NOT?: RoutineStretchWhereInput | RoutineStretchWhereInput[]
    id?: StringFilter<"RoutineStretch"> | string
    routineId?: StringFilter<"RoutineStretch"> | string
    stretchId?: StringFilter<"RoutineStretch"> | string
    positionOrder?: IntFilter<"RoutineStretch"> | number
    customDurationSeconds?: IntNullableFilter<"RoutineStretch"> | number | null
    routine?: XOR<StretchingRoutineRelationFilter, StretchingRoutineWhereInput>
    stretch?: XOR<StretchRelationFilter, StretchWhereInput>
  }

  export type RoutineStretchOrderByWithRelationInput = {
    id?: SortOrder
    routineId?: SortOrder
    stretchId?: SortOrder
    positionOrder?: SortOrder
    customDurationSeconds?: SortOrderInput | SortOrder
    routine?: StretchingRoutineOrderByWithRelationInput
    stretch?: StretchOrderByWithRelationInput
  }

  export type RoutineStretchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoutineStretchWhereInput | RoutineStretchWhereInput[]
    OR?: RoutineStretchWhereInput[]
    NOT?: RoutineStretchWhereInput | RoutineStretchWhereInput[]
    routineId?: StringFilter<"RoutineStretch"> | string
    stretchId?: StringFilter<"RoutineStretch"> | string
    positionOrder?: IntFilter<"RoutineStretch"> | number
    customDurationSeconds?: IntNullableFilter<"RoutineStretch"> | number | null
    routine?: XOR<StretchingRoutineRelationFilter, StretchingRoutineWhereInput>
    stretch?: XOR<StretchRelationFilter, StretchWhereInput>
  }, "id">

  export type RoutineStretchOrderByWithAggregationInput = {
    id?: SortOrder
    routineId?: SortOrder
    stretchId?: SortOrder
    positionOrder?: SortOrder
    customDurationSeconds?: SortOrderInput | SortOrder
    _count?: RoutineStretchCountOrderByAggregateInput
    _avg?: RoutineStretchAvgOrderByAggregateInput
    _max?: RoutineStretchMaxOrderByAggregateInput
    _min?: RoutineStretchMinOrderByAggregateInput
    _sum?: RoutineStretchSumOrderByAggregateInput
  }

  export type RoutineStretchScalarWhereWithAggregatesInput = {
    AND?: RoutineStretchScalarWhereWithAggregatesInput | RoutineStretchScalarWhereWithAggregatesInput[]
    OR?: RoutineStretchScalarWhereWithAggregatesInput[]
    NOT?: RoutineStretchScalarWhereWithAggregatesInput | RoutineStretchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoutineStretch"> | string
    routineId?: StringWithAggregatesFilter<"RoutineStretch"> | string
    stretchId?: StringWithAggregatesFilter<"RoutineStretch"> | string
    positionOrder?: IntWithAggregatesFilter<"RoutineStretch"> | number
    customDurationSeconds?: IntNullableWithAggregatesFilter<"RoutineStretch"> | number | null
  }

  export type StretchingSessionWhereInput = {
    AND?: StretchingSessionWhereInput | StretchingSessionWhereInput[]
    OR?: StretchingSessionWhereInput[]
    NOT?: StretchingSessionWhereInput | StretchingSessionWhereInput[]
    id?: StringFilter<"StretchingSession"> | string
    userId?: StringFilter<"StretchingSession"> | string
    routineId?: StringNullableFilter<"StretchingSession"> | string | null
    routineName?: StringNullableFilter<"StretchingSession"> | string | null
    startedAt?: DateTimeFilter<"StretchingSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"StretchingSession"> | Date | string | null
    durationSeconds?: IntNullableFilter<"StretchingSession"> | number | null
    completed?: BoolFilter<"StretchingSession"> | boolean
    linkedWorkoutId?: StringNullableFilter<"StretchingSession"> | string | null
    notes?: StringNullableFilter<"StretchingSession"> | string | null
    createdAt?: DateTimeFilter<"StretchingSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    routine?: XOR<StretchingRoutineNullableRelationFilter, StretchingRoutineWhereInput> | null
    stretches?: SessionStretchListRelationFilter
  }

  export type StretchingSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    routineId?: SortOrderInput | SortOrder
    routineName?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    completed?: SortOrder
    linkedWorkoutId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    routine?: StretchingRoutineOrderByWithRelationInput
    stretches?: SessionStretchOrderByRelationAggregateInput
  }

  export type StretchingSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StretchingSessionWhereInput | StretchingSessionWhereInput[]
    OR?: StretchingSessionWhereInput[]
    NOT?: StretchingSessionWhereInput | StretchingSessionWhereInput[]
    userId?: StringFilter<"StretchingSession"> | string
    routineId?: StringNullableFilter<"StretchingSession"> | string | null
    routineName?: StringNullableFilter<"StretchingSession"> | string | null
    startedAt?: DateTimeFilter<"StretchingSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"StretchingSession"> | Date | string | null
    durationSeconds?: IntNullableFilter<"StretchingSession"> | number | null
    completed?: BoolFilter<"StretchingSession"> | boolean
    linkedWorkoutId?: StringNullableFilter<"StretchingSession"> | string | null
    notes?: StringNullableFilter<"StretchingSession"> | string | null
    createdAt?: DateTimeFilter<"StretchingSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    routine?: XOR<StretchingRoutineNullableRelationFilter, StretchingRoutineWhereInput> | null
    stretches?: SessionStretchListRelationFilter
  }, "id">

  export type StretchingSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    routineId?: SortOrderInput | SortOrder
    routineName?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    completed?: SortOrder
    linkedWorkoutId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StretchingSessionCountOrderByAggregateInput
    _avg?: StretchingSessionAvgOrderByAggregateInput
    _max?: StretchingSessionMaxOrderByAggregateInput
    _min?: StretchingSessionMinOrderByAggregateInput
    _sum?: StretchingSessionSumOrderByAggregateInput
  }

  export type StretchingSessionScalarWhereWithAggregatesInput = {
    AND?: StretchingSessionScalarWhereWithAggregatesInput | StretchingSessionScalarWhereWithAggregatesInput[]
    OR?: StretchingSessionScalarWhereWithAggregatesInput[]
    NOT?: StretchingSessionScalarWhereWithAggregatesInput | StretchingSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StretchingSession"> | string
    userId?: StringWithAggregatesFilter<"StretchingSession"> | string
    routineId?: StringNullableWithAggregatesFilter<"StretchingSession"> | string | null
    routineName?: StringNullableWithAggregatesFilter<"StretchingSession"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"StretchingSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"StretchingSession"> | Date | string | null
    durationSeconds?: IntNullableWithAggregatesFilter<"StretchingSession"> | number | null
    completed?: BoolWithAggregatesFilter<"StretchingSession"> | boolean
    linkedWorkoutId?: StringNullableWithAggregatesFilter<"StretchingSession"> | string | null
    notes?: StringNullableWithAggregatesFilter<"StretchingSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StretchingSession"> | Date | string
  }

  export type SessionStretchWhereInput = {
    AND?: SessionStretchWhereInput | SessionStretchWhereInput[]
    OR?: SessionStretchWhereInput[]
    NOT?: SessionStretchWhereInput | SessionStretchWhereInput[]
    id?: StringFilter<"SessionStretch"> | string
    sessionId?: StringFilter<"SessionStretch"> | string
    stretchId?: StringFilter<"SessionStretch"> | string
    heldDurationSeconds?: IntFilter<"SessionStretch"> | number
    feltTight?: BoolFilter<"SessionStretch"> | boolean
    positionInRoutine?: IntFilter<"SessionStretch"> | number
    completedAt?: DateTimeFilter<"SessionStretch"> | Date | string
    session?: XOR<StretchingSessionRelationFilter, StretchingSessionWhereInput>
    stretch?: XOR<StretchRelationFilter, StretchWhereInput>
  }

  export type SessionStretchOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    stretchId?: SortOrder
    heldDurationSeconds?: SortOrder
    feltTight?: SortOrder
    positionInRoutine?: SortOrder
    completedAt?: SortOrder
    session?: StretchingSessionOrderByWithRelationInput
    stretch?: StretchOrderByWithRelationInput
  }

  export type SessionStretchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionStretchWhereInput | SessionStretchWhereInput[]
    OR?: SessionStretchWhereInput[]
    NOT?: SessionStretchWhereInput | SessionStretchWhereInput[]
    sessionId?: StringFilter<"SessionStretch"> | string
    stretchId?: StringFilter<"SessionStretch"> | string
    heldDurationSeconds?: IntFilter<"SessionStretch"> | number
    feltTight?: BoolFilter<"SessionStretch"> | boolean
    positionInRoutine?: IntFilter<"SessionStretch"> | number
    completedAt?: DateTimeFilter<"SessionStretch"> | Date | string
    session?: XOR<StretchingSessionRelationFilter, StretchingSessionWhereInput>
    stretch?: XOR<StretchRelationFilter, StretchWhereInput>
  }, "id">

  export type SessionStretchOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    stretchId?: SortOrder
    heldDurationSeconds?: SortOrder
    feltTight?: SortOrder
    positionInRoutine?: SortOrder
    completedAt?: SortOrder
    _count?: SessionStretchCountOrderByAggregateInput
    _avg?: SessionStretchAvgOrderByAggregateInput
    _max?: SessionStretchMaxOrderByAggregateInput
    _min?: SessionStretchMinOrderByAggregateInput
    _sum?: SessionStretchSumOrderByAggregateInput
  }

  export type SessionStretchScalarWhereWithAggregatesInput = {
    AND?: SessionStretchScalarWhereWithAggregatesInput | SessionStretchScalarWhereWithAggregatesInput[]
    OR?: SessionStretchScalarWhereWithAggregatesInput[]
    NOT?: SessionStretchScalarWhereWithAggregatesInput | SessionStretchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionStretch"> | string
    sessionId?: StringWithAggregatesFilter<"SessionStretch"> | string
    stretchId?: StringWithAggregatesFilter<"SessionStretch"> | string
    heldDurationSeconds?: IntWithAggregatesFilter<"SessionStretch"> | number
    feltTight?: BoolWithAggregatesFilter<"SessionStretch"> | boolean
    positionInRoutine?: IntWithAggregatesFilter<"SessionStretch"> | number
    completedAt?: DateTimeWithAggregatesFilter<"SessionStretch"> | Date | string
  }

  export type FlexibilityGoalWhereInput = {
    AND?: FlexibilityGoalWhereInput | FlexibilityGoalWhereInput[]
    OR?: FlexibilityGoalWhereInput[]
    NOT?: FlexibilityGoalWhereInput | FlexibilityGoalWhereInput[]
    id?: StringFilter<"FlexibilityGoal"> | string
    userId?: StringFilter<"FlexibilityGoal"> | string
    goalType?: StringFilter<"FlexibilityGoal"> | string
    description?: StringNullableFilter<"FlexibilityGoal"> | string | null
    targetArea?: StringFilter<"FlexibilityGoal"> | string
    baselineRom?: FloatNullableFilter<"FlexibilityGoal"> | number | null
    targetRom?: FloatNullableFilter<"FlexibilityGoal"> | number | null
    targetDate?: DateTimeNullableFilter<"FlexibilityGoal"> | Date | string | null
    status?: StringFilter<"FlexibilityGoal"> | string
    createdAt?: DateTimeFilter<"FlexibilityGoal"> | Date | string
    updatedAt?: DateTimeFilter<"FlexibilityGoal"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    measurements?: RomMeasurementListRelationFilter
    progressVideos?: ProgressVideoListRelationFilter
  }

  export type FlexibilityGoalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    description?: SortOrderInput | SortOrder
    targetArea?: SortOrder
    baselineRom?: SortOrderInput | SortOrder
    targetRom?: SortOrderInput | SortOrder
    targetDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    measurements?: RomMeasurementOrderByRelationAggregateInput
    progressVideos?: ProgressVideoOrderByRelationAggregateInput
  }

  export type FlexibilityGoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlexibilityGoalWhereInput | FlexibilityGoalWhereInput[]
    OR?: FlexibilityGoalWhereInput[]
    NOT?: FlexibilityGoalWhereInput | FlexibilityGoalWhereInput[]
    userId?: StringFilter<"FlexibilityGoal"> | string
    goalType?: StringFilter<"FlexibilityGoal"> | string
    description?: StringNullableFilter<"FlexibilityGoal"> | string | null
    targetArea?: StringFilter<"FlexibilityGoal"> | string
    baselineRom?: FloatNullableFilter<"FlexibilityGoal"> | number | null
    targetRom?: FloatNullableFilter<"FlexibilityGoal"> | number | null
    targetDate?: DateTimeNullableFilter<"FlexibilityGoal"> | Date | string | null
    status?: StringFilter<"FlexibilityGoal"> | string
    createdAt?: DateTimeFilter<"FlexibilityGoal"> | Date | string
    updatedAt?: DateTimeFilter<"FlexibilityGoal"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    measurements?: RomMeasurementListRelationFilter
    progressVideos?: ProgressVideoListRelationFilter
  }, "id">

  export type FlexibilityGoalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    description?: SortOrderInput | SortOrder
    targetArea?: SortOrder
    baselineRom?: SortOrderInput | SortOrder
    targetRom?: SortOrderInput | SortOrder
    targetDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FlexibilityGoalCountOrderByAggregateInput
    _avg?: FlexibilityGoalAvgOrderByAggregateInput
    _max?: FlexibilityGoalMaxOrderByAggregateInput
    _min?: FlexibilityGoalMinOrderByAggregateInput
    _sum?: FlexibilityGoalSumOrderByAggregateInput
  }

  export type FlexibilityGoalScalarWhereWithAggregatesInput = {
    AND?: FlexibilityGoalScalarWhereWithAggregatesInput | FlexibilityGoalScalarWhereWithAggregatesInput[]
    OR?: FlexibilityGoalScalarWhereWithAggregatesInput[]
    NOT?: FlexibilityGoalScalarWhereWithAggregatesInput | FlexibilityGoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlexibilityGoal"> | string
    userId?: StringWithAggregatesFilter<"FlexibilityGoal"> | string
    goalType?: StringWithAggregatesFilter<"FlexibilityGoal"> | string
    description?: StringNullableWithAggregatesFilter<"FlexibilityGoal"> | string | null
    targetArea?: StringWithAggregatesFilter<"FlexibilityGoal"> | string
    baselineRom?: FloatNullableWithAggregatesFilter<"FlexibilityGoal"> | number | null
    targetRom?: FloatNullableWithAggregatesFilter<"FlexibilityGoal"> | number | null
    targetDate?: DateTimeNullableWithAggregatesFilter<"FlexibilityGoal"> | Date | string | null
    status?: StringWithAggregatesFilter<"FlexibilityGoal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FlexibilityGoal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FlexibilityGoal"> | Date | string
  }

  export type RomMeasurementWhereInput = {
    AND?: RomMeasurementWhereInput | RomMeasurementWhereInput[]
    OR?: RomMeasurementWhereInput[]
    NOT?: RomMeasurementWhereInput | RomMeasurementWhereInput[]
    id?: StringFilter<"RomMeasurement"> | string
    goalId?: StringFilter<"RomMeasurement"> | string
    romDegrees?: FloatFilter<"RomMeasurement"> | number
    measurementDate?: DateTimeFilter<"RomMeasurement"> | Date | string
    measurementMethod?: StringNullableFilter<"RomMeasurement"> | string | null
    notes?: StringNullableFilter<"RomMeasurement"> | string | null
    createdAt?: DateTimeFilter<"RomMeasurement"> | Date | string
    goal?: XOR<FlexibilityGoalRelationFilter, FlexibilityGoalWhereInput>
  }

  export type RomMeasurementOrderByWithRelationInput = {
    id?: SortOrder
    goalId?: SortOrder
    romDegrees?: SortOrder
    measurementDate?: SortOrder
    measurementMethod?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    goal?: FlexibilityGoalOrderByWithRelationInput
  }

  export type RomMeasurementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RomMeasurementWhereInput | RomMeasurementWhereInput[]
    OR?: RomMeasurementWhereInput[]
    NOT?: RomMeasurementWhereInput | RomMeasurementWhereInput[]
    goalId?: StringFilter<"RomMeasurement"> | string
    romDegrees?: FloatFilter<"RomMeasurement"> | number
    measurementDate?: DateTimeFilter<"RomMeasurement"> | Date | string
    measurementMethod?: StringNullableFilter<"RomMeasurement"> | string | null
    notes?: StringNullableFilter<"RomMeasurement"> | string | null
    createdAt?: DateTimeFilter<"RomMeasurement"> | Date | string
    goal?: XOR<FlexibilityGoalRelationFilter, FlexibilityGoalWhereInput>
  }, "id">

  export type RomMeasurementOrderByWithAggregationInput = {
    id?: SortOrder
    goalId?: SortOrder
    romDegrees?: SortOrder
    measurementDate?: SortOrder
    measurementMethod?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RomMeasurementCountOrderByAggregateInput
    _avg?: RomMeasurementAvgOrderByAggregateInput
    _max?: RomMeasurementMaxOrderByAggregateInput
    _min?: RomMeasurementMinOrderByAggregateInput
    _sum?: RomMeasurementSumOrderByAggregateInput
  }

  export type RomMeasurementScalarWhereWithAggregatesInput = {
    AND?: RomMeasurementScalarWhereWithAggregatesInput | RomMeasurementScalarWhereWithAggregatesInput[]
    OR?: RomMeasurementScalarWhereWithAggregatesInput[]
    NOT?: RomMeasurementScalarWhereWithAggregatesInput | RomMeasurementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RomMeasurement"> | string
    goalId?: StringWithAggregatesFilter<"RomMeasurement"> | string
    romDegrees?: FloatWithAggregatesFilter<"RomMeasurement"> | number
    measurementDate?: DateTimeWithAggregatesFilter<"RomMeasurement"> | Date | string
    measurementMethod?: StringNullableWithAggregatesFilter<"RomMeasurement"> | string | null
    notes?: StringNullableWithAggregatesFilter<"RomMeasurement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RomMeasurement"> | Date | string
  }

  export type ProgressVideoWhereInput = {
    AND?: ProgressVideoWhereInput | ProgressVideoWhereInput[]
    OR?: ProgressVideoWhereInput[]
    NOT?: ProgressVideoWhereInput | ProgressVideoWhereInput[]
    id?: StringFilter<"ProgressVideo"> | string
    userId?: StringFilter<"ProgressVideo"> | string
    goalId?: StringNullableFilter<"ProgressVideo"> | string | null
    videoUrl?: StringFilter<"ProgressVideo"> | string
    uploadedAt?: DateTimeFilter<"ProgressVideo"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    goal?: XOR<FlexibilityGoalNullableRelationFilter, FlexibilityGoalWhereInput> | null
  }

  export type ProgressVideoOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    goalId?: SortOrderInput | SortOrder
    videoUrl?: SortOrder
    uploadedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    goal?: FlexibilityGoalOrderByWithRelationInput
  }

  export type ProgressVideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgressVideoWhereInput | ProgressVideoWhereInput[]
    OR?: ProgressVideoWhereInput[]
    NOT?: ProgressVideoWhereInput | ProgressVideoWhereInput[]
    userId?: StringFilter<"ProgressVideo"> | string
    goalId?: StringNullableFilter<"ProgressVideo"> | string | null
    videoUrl?: StringFilter<"ProgressVideo"> | string
    uploadedAt?: DateTimeFilter<"ProgressVideo"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    goal?: XOR<FlexibilityGoalNullableRelationFilter, FlexibilityGoalWhereInput> | null
  }, "id">

  export type ProgressVideoOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    goalId?: SortOrderInput | SortOrder
    videoUrl?: SortOrder
    uploadedAt?: SortOrder
    _count?: ProgressVideoCountOrderByAggregateInput
    _max?: ProgressVideoMaxOrderByAggregateInput
    _min?: ProgressVideoMinOrderByAggregateInput
  }

  export type ProgressVideoScalarWhereWithAggregatesInput = {
    AND?: ProgressVideoScalarWhereWithAggregatesInput | ProgressVideoScalarWhereWithAggregatesInput[]
    OR?: ProgressVideoScalarWhereWithAggregatesInput[]
    NOT?: ProgressVideoScalarWhereWithAggregatesInput | ProgressVideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgressVideo"> | string
    userId?: StringWithAggregatesFilter<"ProgressVideo"> | string
    goalId?: StringNullableWithAggregatesFilter<"ProgressVideo"> | string | null
    videoUrl?: StringWithAggregatesFilter<"ProgressVideo"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"ProgressVideo"> | Date | string
  }

  export type ExerciseWhereInput = {
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    id?: StringFilter<"Exercise"> | string
    name?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    category?: StringFilter<"Exercise"> | string
    equipmentNeeded?: StringNullableFilter<"Exercise"> | string | null
    videoUrl?: StringNullableFilter<"Exercise"> | string | null
    thumbnailUrl?: StringNullableFilter<"Exercise"> | string | null
    primaryMuscles?: StringFilter<"Exercise"> | string
    secondaryMuscles?: StringNullableFilter<"Exercise"> | string | null
    difficulty?: StringFilter<"Exercise"> | string
    instructions?: StringNullableFilter<"Exercise"> | string | null
    tips?: StringNullableFilter<"Exercise"> | string | null
    commonMistakes?: StringNullableFilter<"Exercise"> | string | null
    isCompound?: BoolFilter<"Exercise"> | boolean
    isUnilateral?: BoolFilter<"Exercise"> | boolean
    forceType?: StringNullableFilter<"Exercise"> | string | null
    mechanic?: StringNullableFilter<"Exercise"> | string | null
    metValue?: FloatNullableFilter<"Exercise"> | number | null
    is1RMEligible?: BoolFilter<"Exercise"> | boolean
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    workoutExercises?: WorkoutExerciseListRelationFilter
    personalRecords?: PersonalRecordListRelationFilter
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    equipmentNeeded?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    instructions?: SortOrderInput | SortOrder
    tips?: SortOrderInput | SortOrder
    commonMistakes?: SortOrderInput | SortOrder
    isCompound?: SortOrder
    isUnilateral?: SortOrder
    forceType?: SortOrderInput | SortOrder
    mechanic?: SortOrderInput | SortOrder
    metValue?: SortOrderInput | SortOrder
    is1RMEligible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workoutExercises?: WorkoutExerciseOrderByRelationAggregateInput
    personalRecords?: PersonalRecordOrderByRelationAggregateInput
  }

  export type ExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    name?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    category?: StringFilter<"Exercise"> | string
    equipmentNeeded?: StringNullableFilter<"Exercise"> | string | null
    videoUrl?: StringNullableFilter<"Exercise"> | string | null
    thumbnailUrl?: StringNullableFilter<"Exercise"> | string | null
    primaryMuscles?: StringFilter<"Exercise"> | string
    secondaryMuscles?: StringNullableFilter<"Exercise"> | string | null
    difficulty?: StringFilter<"Exercise"> | string
    instructions?: StringNullableFilter<"Exercise"> | string | null
    tips?: StringNullableFilter<"Exercise"> | string | null
    commonMistakes?: StringNullableFilter<"Exercise"> | string | null
    isCompound?: BoolFilter<"Exercise"> | boolean
    isUnilateral?: BoolFilter<"Exercise"> | boolean
    forceType?: StringNullableFilter<"Exercise"> | string | null
    mechanic?: StringNullableFilter<"Exercise"> | string | null
    metValue?: FloatNullableFilter<"Exercise"> | number | null
    is1RMEligible?: BoolFilter<"Exercise"> | boolean
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    workoutExercises?: WorkoutExerciseListRelationFilter
    personalRecords?: PersonalRecordListRelationFilter
  }, "id">

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    equipmentNeeded?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    instructions?: SortOrderInput | SortOrder
    tips?: SortOrderInput | SortOrder
    commonMistakes?: SortOrderInput | SortOrder
    isCompound?: SortOrder
    isUnilateral?: SortOrder
    forceType?: SortOrderInput | SortOrder
    mechanic?: SortOrderInput | SortOrder
    metValue?: SortOrderInput | SortOrder
    is1RMEligible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _avg?: ExerciseAvgOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
    _sum?: ExerciseSumOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    OR?: ExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exercise"> | string
    name?: StringWithAggregatesFilter<"Exercise"> | string
    description?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    category?: StringWithAggregatesFilter<"Exercise"> | string
    equipmentNeeded?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    primaryMuscles?: StringWithAggregatesFilter<"Exercise"> | string
    secondaryMuscles?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    difficulty?: StringWithAggregatesFilter<"Exercise"> | string
    instructions?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    tips?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    commonMistakes?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    isCompound?: BoolWithAggregatesFilter<"Exercise"> | boolean
    isUnilateral?: BoolWithAggregatesFilter<"Exercise"> | boolean
    forceType?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    mechanic?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    metValue?: FloatNullableWithAggregatesFilter<"Exercise"> | number | null
    is1RMEligible?: BoolWithAggregatesFilter<"Exercise"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
  }

  export type StrengthWorkoutWhereInput = {
    AND?: StrengthWorkoutWhereInput | StrengthWorkoutWhereInput[]
    OR?: StrengthWorkoutWhereInput[]
    NOT?: StrengthWorkoutWhereInput | StrengthWorkoutWhereInput[]
    id?: StringFilter<"StrengthWorkout"> | string
    userId?: StringFilter<"StrengthWorkout"> | string
    name?: StringNullableFilter<"StrengthWorkout"> | string | null
    startedAt?: DateTimeFilter<"StrengthWorkout"> | Date | string
    completedAt?: DateTimeNullableFilter<"StrengthWorkout"> | Date | string | null
    durationSeconds?: IntNullableFilter<"StrengthWorkout"> | number | null
    sessionIntensityRpe?: IntNullableFilter<"StrengthWorkout"> | number | null
    notes?: StringNullableFilter<"StrengthWorkout"> | string | null
    totalVolume?: FloatNullableFilter<"StrengthWorkout"> | number | null
    createdAt?: DateTimeFilter<"StrengthWorkout"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    exercises?: WorkoutExerciseListRelationFilter
  }

  export type StrengthWorkoutOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    sessionIntensityRpe?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    totalVolume?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    exercises?: WorkoutExerciseOrderByRelationAggregateInput
  }

  export type StrengthWorkoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StrengthWorkoutWhereInput | StrengthWorkoutWhereInput[]
    OR?: StrengthWorkoutWhereInput[]
    NOT?: StrengthWorkoutWhereInput | StrengthWorkoutWhereInput[]
    userId?: StringFilter<"StrengthWorkout"> | string
    name?: StringNullableFilter<"StrengthWorkout"> | string | null
    startedAt?: DateTimeFilter<"StrengthWorkout"> | Date | string
    completedAt?: DateTimeNullableFilter<"StrengthWorkout"> | Date | string | null
    durationSeconds?: IntNullableFilter<"StrengthWorkout"> | number | null
    sessionIntensityRpe?: IntNullableFilter<"StrengthWorkout"> | number | null
    notes?: StringNullableFilter<"StrengthWorkout"> | string | null
    totalVolume?: FloatNullableFilter<"StrengthWorkout"> | number | null
    createdAt?: DateTimeFilter<"StrengthWorkout"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    exercises?: WorkoutExerciseListRelationFilter
  }, "id">

  export type StrengthWorkoutOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    sessionIntensityRpe?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    totalVolume?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StrengthWorkoutCountOrderByAggregateInput
    _avg?: StrengthWorkoutAvgOrderByAggregateInput
    _max?: StrengthWorkoutMaxOrderByAggregateInput
    _min?: StrengthWorkoutMinOrderByAggregateInput
    _sum?: StrengthWorkoutSumOrderByAggregateInput
  }

  export type StrengthWorkoutScalarWhereWithAggregatesInput = {
    AND?: StrengthWorkoutScalarWhereWithAggregatesInput | StrengthWorkoutScalarWhereWithAggregatesInput[]
    OR?: StrengthWorkoutScalarWhereWithAggregatesInput[]
    NOT?: StrengthWorkoutScalarWhereWithAggregatesInput | StrengthWorkoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StrengthWorkout"> | string
    userId?: StringWithAggregatesFilter<"StrengthWorkout"> | string
    name?: StringNullableWithAggregatesFilter<"StrengthWorkout"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"StrengthWorkout"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"StrengthWorkout"> | Date | string | null
    durationSeconds?: IntNullableWithAggregatesFilter<"StrengthWorkout"> | number | null
    sessionIntensityRpe?: IntNullableWithAggregatesFilter<"StrengthWorkout"> | number | null
    notes?: StringNullableWithAggregatesFilter<"StrengthWorkout"> | string | null
    totalVolume?: FloatNullableWithAggregatesFilter<"StrengthWorkout"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"StrengthWorkout"> | Date | string
  }

  export type WorkoutExerciseWhereInput = {
    AND?: WorkoutExerciseWhereInput | WorkoutExerciseWhereInput[]
    OR?: WorkoutExerciseWhereInput[]
    NOT?: WorkoutExerciseWhereInput | WorkoutExerciseWhereInput[]
    id?: StringFilter<"WorkoutExercise"> | string
    workoutId?: StringFilter<"WorkoutExercise"> | string
    exerciseId?: StringFilter<"WorkoutExercise"> | string
    positionOrder?: IntFilter<"WorkoutExercise"> | number
    notes?: StringNullableFilter<"WorkoutExercise"> | string | null
    createdAt?: DateTimeFilter<"WorkoutExercise"> | Date | string
    workout?: XOR<StrengthWorkoutRelationFilter, StrengthWorkoutWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
    sets?: WorkoutSetListRelationFilter
  }

  export type WorkoutExerciseOrderByWithRelationInput = {
    id?: SortOrder
    workoutId?: SortOrder
    exerciseId?: SortOrder
    positionOrder?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    workout?: StrengthWorkoutOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
    sets?: WorkoutSetOrderByRelationAggregateInput
  }

  export type WorkoutExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkoutExerciseWhereInput | WorkoutExerciseWhereInput[]
    OR?: WorkoutExerciseWhereInput[]
    NOT?: WorkoutExerciseWhereInput | WorkoutExerciseWhereInput[]
    workoutId?: StringFilter<"WorkoutExercise"> | string
    exerciseId?: StringFilter<"WorkoutExercise"> | string
    positionOrder?: IntFilter<"WorkoutExercise"> | number
    notes?: StringNullableFilter<"WorkoutExercise"> | string | null
    createdAt?: DateTimeFilter<"WorkoutExercise"> | Date | string
    workout?: XOR<StrengthWorkoutRelationFilter, StrengthWorkoutWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
    sets?: WorkoutSetListRelationFilter
  }, "id">

  export type WorkoutExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    workoutId?: SortOrder
    exerciseId?: SortOrder
    positionOrder?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WorkoutExerciseCountOrderByAggregateInput
    _avg?: WorkoutExerciseAvgOrderByAggregateInput
    _max?: WorkoutExerciseMaxOrderByAggregateInput
    _min?: WorkoutExerciseMinOrderByAggregateInput
    _sum?: WorkoutExerciseSumOrderByAggregateInput
  }

  export type WorkoutExerciseScalarWhereWithAggregatesInput = {
    AND?: WorkoutExerciseScalarWhereWithAggregatesInput | WorkoutExerciseScalarWhereWithAggregatesInput[]
    OR?: WorkoutExerciseScalarWhereWithAggregatesInput[]
    NOT?: WorkoutExerciseScalarWhereWithAggregatesInput | WorkoutExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkoutExercise"> | string
    workoutId?: StringWithAggregatesFilter<"WorkoutExercise"> | string
    exerciseId?: StringWithAggregatesFilter<"WorkoutExercise"> | string
    positionOrder?: IntWithAggregatesFilter<"WorkoutExercise"> | number
    notes?: StringNullableWithAggregatesFilter<"WorkoutExercise"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkoutExercise"> | Date | string
  }

  export type WorkoutSetWhereInput = {
    AND?: WorkoutSetWhereInput | WorkoutSetWhereInput[]
    OR?: WorkoutSetWhereInput[]
    NOT?: WorkoutSetWhereInput | WorkoutSetWhereInput[]
    id?: StringFilter<"WorkoutSet"> | string
    workoutExerciseId?: StringFilter<"WorkoutSet"> | string
    setNumber?: IntFilter<"WorkoutSet"> | number
    reps?: IntNullableFilter<"WorkoutSet"> | number | null
    weight?: FloatNullableFilter<"WorkoutSet"> | number | null
    weightUnit?: StringFilter<"WorkoutSet"> | string
    setType?: StringFilter<"WorkoutSet"> | string
    rpe?: IntNullableFilter<"WorkoutSet"> | number | null
    isPr?: BoolFilter<"WorkoutSet"> | boolean
    completed?: BoolFilter<"WorkoutSet"> | boolean
    restSeconds?: IntNullableFilter<"WorkoutSet"> | number | null
    durationSeconds?: IntNullableFilter<"WorkoutSet"> | number | null
    distanceMeters?: FloatNullableFilter<"WorkoutSet"> | number | null
    createdAt?: DateTimeFilter<"WorkoutSet"> | Date | string
    workoutExercise?: XOR<WorkoutExerciseRelationFilter, WorkoutExerciseWhereInput>
  }

  export type WorkoutSetOrderByWithRelationInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    setNumber?: SortOrder
    reps?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    weightUnit?: SortOrder
    setType?: SortOrder
    rpe?: SortOrderInput | SortOrder
    isPr?: SortOrder
    completed?: SortOrder
    restSeconds?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    distanceMeters?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    workoutExercise?: WorkoutExerciseOrderByWithRelationInput
  }

  export type WorkoutSetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkoutSetWhereInput | WorkoutSetWhereInput[]
    OR?: WorkoutSetWhereInput[]
    NOT?: WorkoutSetWhereInput | WorkoutSetWhereInput[]
    workoutExerciseId?: StringFilter<"WorkoutSet"> | string
    setNumber?: IntFilter<"WorkoutSet"> | number
    reps?: IntNullableFilter<"WorkoutSet"> | number | null
    weight?: FloatNullableFilter<"WorkoutSet"> | number | null
    weightUnit?: StringFilter<"WorkoutSet"> | string
    setType?: StringFilter<"WorkoutSet"> | string
    rpe?: IntNullableFilter<"WorkoutSet"> | number | null
    isPr?: BoolFilter<"WorkoutSet"> | boolean
    completed?: BoolFilter<"WorkoutSet"> | boolean
    restSeconds?: IntNullableFilter<"WorkoutSet"> | number | null
    durationSeconds?: IntNullableFilter<"WorkoutSet"> | number | null
    distanceMeters?: FloatNullableFilter<"WorkoutSet"> | number | null
    createdAt?: DateTimeFilter<"WorkoutSet"> | Date | string
    workoutExercise?: XOR<WorkoutExerciseRelationFilter, WorkoutExerciseWhereInput>
  }, "id">

  export type WorkoutSetOrderByWithAggregationInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    setNumber?: SortOrder
    reps?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    weightUnit?: SortOrder
    setType?: SortOrder
    rpe?: SortOrderInput | SortOrder
    isPr?: SortOrder
    completed?: SortOrder
    restSeconds?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    distanceMeters?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WorkoutSetCountOrderByAggregateInput
    _avg?: WorkoutSetAvgOrderByAggregateInput
    _max?: WorkoutSetMaxOrderByAggregateInput
    _min?: WorkoutSetMinOrderByAggregateInput
    _sum?: WorkoutSetSumOrderByAggregateInput
  }

  export type WorkoutSetScalarWhereWithAggregatesInput = {
    AND?: WorkoutSetScalarWhereWithAggregatesInput | WorkoutSetScalarWhereWithAggregatesInput[]
    OR?: WorkoutSetScalarWhereWithAggregatesInput[]
    NOT?: WorkoutSetScalarWhereWithAggregatesInput | WorkoutSetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkoutSet"> | string
    workoutExerciseId?: StringWithAggregatesFilter<"WorkoutSet"> | string
    setNumber?: IntWithAggregatesFilter<"WorkoutSet"> | number
    reps?: IntNullableWithAggregatesFilter<"WorkoutSet"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"WorkoutSet"> | number | null
    weightUnit?: StringWithAggregatesFilter<"WorkoutSet"> | string
    setType?: StringWithAggregatesFilter<"WorkoutSet"> | string
    rpe?: IntNullableWithAggregatesFilter<"WorkoutSet"> | number | null
    isPr?: BoolWithAggregatesFilter<"WorkoutSet"> | boolean
    completed?: BoolWithAggregatesFilter<"WorkoutSet"> | boolean
    restSeconds?: IntNullableWithAggregatesFilter<"WorkoutSet"> | number | null
    durationSeconds?: IntNullableWithAggregatesFilter<"WorkoutSet"> | number | null
    distanceMeters?: FloatNullableWithAggregatesFilter<"WorkoutSet"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkoutSet"> | Date | string
  }

  export type PersonalRecordWhereInput = {
    AND?: PersonalRecordWhereInput | PersonalRecordWhereInput[]
    OR?: PersonalRecordWhereInput[]
    NOT?: PersonalRecordWhereInput | PersonalRecordWhereInput[]
    id?: StringFilter<"PersonalRecord"> | string
    userId?: StringFilter<"PersonalRecord"> | string
    exerciseId?: StringFilter<"PersonalRecord"> | string
    recordType?: StringFilter<"PersonalRecord"> | string
    value?: FloatFilter<"PersonalRecord"> | number
    weightUnit?: StringFilter<"PersonalRecord"> | string
    achievedAt?: DateTimeFilter<"PersonalRecord"> | Date | string
    workoutId?: StringNullableFilter<"PersonalRecord"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }

  export type PersonalRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    recordType?: SortOrder
    value?: SortOrder
    weightUnit?: SortOrder
    achievedAt?: SortOrder
    workoutId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
  }

  export type PersonalRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_exerciseId_recordType?: PersonalRecordUserIdExerciseIdRecordTypeCompoundUniqueInput
    AND?: PersonalRecordWhereInput | PersonalRecordWhereInput[]
    OR?: PersonalRecordWhereInput[]
    NOT?: PersonalRecordWhereInput | PersonalRecordWhereInput[]
    userId?: StringFilter<"PersonalRecord"> | string
    exerciseId?: StringFilter<"PersonalRecord"> | string
    recordType?: StringFilter<"PersonalRecord"> | string
    value?: FloatFilter<"PersonalRecord"> | number
    weightUnit?: StringFilter<"PersonalRecord"> | string
    achievedAt?: DateTimeFilter<"PersonalRecord"> | Date | string
    workoutId?: StringNullableFilter<"PersonalRecord"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }, "id" | "userId_exerciseId_recordType">

  export type PersonalRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    recordType?: SortOrder
    value?: SortOrder
    weightUnit?: SortOrder
    achievedAt?: SortOrder
    workoutId?: SortOrderInput | SortOrder
    _count?: PersonalRecordCountOrderByAggregateInput
    _avg?: PersonalRecordAvgOrderByAggregateInput
    _max?: PersonalRecordMaxOrderByAggregateInput
    _min?: PersonalRecordMinOrderByAggregateInput
    _sum?: PersonalRecordSumOrderByAggregateInput
  }

  export type PersonalRecordScalarWhereWithAggregatesInput = {
    AND?: PersonalRecordScalarWhereWithAggregatesInput | PersonalRecordScalarWhereWithAggregatesInput[]
    OR?: PersonalRecordScalarWhereWithAggregatesInput[]
    NOT?: PersonalRecordScalarWhereWithAggregatesInput | PersonalRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonalRecord"> | string
    userId?: StringWithAggregatesFilter<"PersonalRecord"> | string
    exerciseId?: StringWithAggregatesFilter<"PersonalRecord"> | string
    recordType?: StringWithAggregatesFilter<"PersonalRecord"> | string
    value?: FloatWithAggregatesFilter<"PersonalRecord"> | number
    weightUnit?: StringWithAggregatesFilter<"PersonalRecord"> | string
    achievedAt?: DateTimeWithAggregatesFilter<"PersonalRecord"> | Date | string
    workoutId?: StringNullableWithAggregatesFilter<"PersonalRecord"> | string | null
  }

  export type BodyMetricWhereInput = {
    AND?: BodyMetricWhereInput | BodyMetricWhereInput[]
    OR?: BodyMetricWhereInput[]
    NOT?: BodyMetricWhereInput | BodyMetricWhereInput[]
    id?: StringFilter<"BodyMetric"> | string
    userId?: StringFilter<"BodyMetric"> | string
    weight?: FloatNullableFilter<"BodyMetric"> | number | null
    weightUnit?: StringFilter<"BodyMetric"> | string
    bodyFatPercentage?: FloatNullableFilter<"BodyMetric"> | number | null
    chest?: FloatNullableFilter<"BodyMetric"> | number | null
    waist?: FloatNullableFilter<"BodyMetric"> | number | null
    hips?: FloatNullableFilter<"BodyMetric"> | number | null
    arms?: FloatNullableFilter<"BodyMetric"> | number | null
    thighs?: FloatNullableFilter<"BodyMetric"> | number | null
    measurementUnit?: StringFilter<"BodyMetric"> | string
    measurementDate?: DateTimeFilter<"BodyMetric"> | Date | string
    notes?: StringNullableFilter<"BodyMetric"> | string | null
    createdAt?: DateTimeFilter<"BodyMetric"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BodyMetricOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    weight?: SortOrderInput | SortOrder
    weightUnit?: SortOrder
    bodyFatPercentage?: SortOrderInput | SortOrder
    chest?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    hips?: SortOrderInput | SortOrder
    arms?: SortOrderInput | SortOrder
    thighs?: SortOrderInput | SortOrder
    measurementUnit?: SortOrder
    measurementDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BodyMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BodyMetricWhereInput | BodyMetricWhereInput[]
    OR?: BodyMetricWhereInput[]
    NOT?: BodyMetricWhereInput | BodyMetricWhereInput[]
    userId?: StringFilter<"BodyMetric"> | string
    weight?: FloatNullableFilter<"BodyMetric"> | number | null
    weightUnit?: StringFilter<"BodyMetric"> | string
    bodyFatPercentage?: FloatNullableFilter<"BodyMetric"> | number | null
    chest?: FloatNullableFilter<"BodyMetric"> | number | null
    waist?: FloatNullableFilter<"BodyMetric"> | number | null
    hips?: FloatNullableFilter<"BodyMetric"> | number | null
    arms?: FloatNullableFilter<"BodyMetric"> | number | null
    thighs?: FloatNullableFilter<"BodyMetric"> | number | null
    measurementUnit?: StringFilter<"BodyMetric"> | string
    measurementDate?: DateTimeFilter<"BodyMetric"> | Date | string
    notes?: StringNullableFilter<"BodyMetric"> | string | null
    createdAt?: DateTimeFilter<"BodyMetric"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type BodyMetricOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    weight?: SortOrderInput | SortOrder
    weightUnit?: SortOrder
    bodyFatPercentage?: SortOrderInput | SortOrder
    chest?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    hips?: SortOrderInput | SortOrder
    arms?: SortOrderInput | SortOrder
    thighs?: SortOrderInput | SortOrder
    measurementUnit?: SortOrder
    measurementDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BodyMetricCountOrderByAggregateInput
    _avg?: BodyMetricAvgOrderByAggregateInput
    _max?: BodyMetricMaxOrderByAggregateInput
    _min?: BodyMetricMinOrderByAggregateInput
    _sum?: BodyMetricSumOrderByAggregateInput
  }

  export type BodyMetricScalarWhereWithAggregatesInput = {
    AND?: BodyMetricScalarWhereWithAggregatesInput | BodyMetricScalarWhereWithAggregatesInput[]
    OR?: BodyMetricScalarWhereWithAggregatesInput[]
    NOT?: BodyMetricScalarWhereWithAggregatesInput | BodyMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BodyMetric"> | string
    userId?: StringWithAggregatesFilter<"BodyMetric"> | string
    weight?: FloatNullableWithAggregatesFilter<"BodyMetric"> | number | null
    weightUnit?: StringWithAggregatesFilter<"BodyMetric"> | string
    bodyFatPercentage?: FloatNullableWithAggregatesFilter<"BodyMetric"> | number | null
    chest?: FloatNullableWithAggregatesFilter<"BodyMetric"> | number | null
    waist?: FloatNullableWithAggregatesFilter<"BodyMetric"> | number | null
    hips?: FloatNullableWithAggregatesFilter<"BodyMetric"> | number | null
    arms?: FloatNullableWithAggregatesFilter<"BodyMetric"> | number | null
    thighs?: FloatNullableWithAggregatesFilter<"BodyMetric"> | number | null
    measurementUnit?: StringWithAggregatesFilter<"BodyMetric"> | string
    measurementDate?: DateTimeWithAggregatesFilter<"BodyMetric"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"BodyMetric"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BodyMetric"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    notificationType?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringNullableFilter<"Notification"> | string | null
    actionType?: StringNullableFilter<"Notification"> | string | null
    actionData?: StringNullableFilter<"Notification"> | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    deliveryStatus?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    body?: SortOrderInput | SortOrder
    actionType?: SortOrderInput | SortOrder
    actionData?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    deliveryStatus?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    notificationType?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringNullableFilter<"Notification"> | string | null
    actionType?: StringNullableFilter<"Notification"> | string | null
    actionData?: StringNullableFilter<"Notification"> | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    deliveryStatus?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    body?: SortOrderInput | SortOrder
    actionType?: SortOrderInput | SortOrder
    actionData?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    clickedAt?: SortOrderInput | SortOrder
    deliveryStatus?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    notificationType?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    actionType?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    actionData?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    clickedAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    deliveryStatus?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    notificationsEnabled?: BoolFilter<"NotificationPreference"> | boolean
    stretchReminders?: BoolFilter<"NotificationPreference"> | boolean
    workoutReminders?: BoolFilter<"NotificationPreference"> | boolean
    streakNotifications?: BoolFilter<"NotificationPreference"> | boolean
    goalNotifications?: BoolFilter<"NotificationPreference"> | boolean
    socialNotifications?: BoolFilter<"NotificationPreference"> | boolean
    recoverySuggestions?: BoolFilter<"NotificationPreference"> | boolean
    inactivityNudges?: BoolFilter<"NotificationPreference"> | boolean
    quietHoursEnabled?: BoolFilter<"NotificationPreference"> | boolean
    quietHoursStart?: StringFilter<"NotificationPreference"> | string
    quietHoursEnd?: StringFilter<"NotificationPreference"> | string
    maxDailyNotifications?: IntFilter<"NotificationPreference"> | number
    stretchReminderTime?: StringFilter<"NotificationPreference"> | string
    workoutReminderTime?: StringFilter<"NotificationPreference"> | string
    reminderDays?: StringFilter<"NotificationPreference"> | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationsEnabled?: SortOrder
    stretchReminders?: SortOrder
    workoutReminders?: SortOrder
    streakNotifications?: SortOrder
    goalNotifications?: SortOrder
    socialNotifications?: SortOrder
    recoverySuggestions?: SortOrder
    inactivityNudges?: SortOrder
    quietHoursEnabled?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    maxDailyNotifications?: SortOrder
    stretchReminderTime?: SortOrder
    workoutReminderTime?: SortOrder
    reminderDays?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    notificationsEnabled?: BoolFilter<"NotificationPreference"> | boolean
    stretchReminders?: BoolFilter<"NotificationPreference"> | boolean
    workoutReminders?: BoolFilter<"NotificationPreference"> | boolean
    streakNotifications?: BoolFilter<"NotificationPreference"> | boolean
    goalNotifications?: BoolFilter<"NotificationPreference"> | boolean
    socialNotifications?: BoolFilter<"NotificationPreference"> | boolean
    recoverySuggestions?: BoolFilter<"NotificationPreference"> | boolean
    inactivityNudges?: BoolFilter<"NotificationPreference"> | boolean
    quietHoursEnabled?: BoolFilter<"NotificationPreference"> | boolean
    quietHoursStart?: StringFilter<"NotificationPreference"> | string
    quietHoursEnd?: StringFilter<"NotificationPreference"> | string
    maxDailyNotifications?: IntFilter<"NotificationPreference"> | number
    stretchReminderTime?: StringFilter<"NotificationPreference"> | string
    workoutReminderTime?: StringFilter<"NotificationPreference"> | string
    reminderDays?: StringFilter<"NotificationPreference"> | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationsEnabled?: SortOrder
    stretchReminders?: SortOrder
    workoutReminders?: SortOrder
    streakNotifications?: SortOrder
    goalNotifications?: SortOrder
    socialNotifications?: SortOrder
    recoverySuggestions?: SortOrder
    inactivityNudges?: SortOrder
    quietHoursEnabled?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    maxDailyNotifications?: SortOrder
    stretchReminderTime?: SortOrder
    workoutReminderTime?: SortOrder
    reminderDays?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _avg?: NotificationPreferenceAvgOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
    _sum?: NotificationPreferenceSumOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    userId?: StringWithAggregatesFilter<"NotificationPreference"> | string
    notificationsEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    stretchReminders?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    workoutReminders?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    streakNotifications?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    goalNotifications?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    socialNotifications?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    recoverySuggestions?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    inactivityNudges?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    quietHoursEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    quietHoursStart?: StringWithAggregatesFilter<"NotificationPreference"> | string
    quietHoursEnd?: StringWithAggregatesFilter<"NotificationPreference"> | string
    maxDailyNotifications?: IntWithAggregatesFilter<"NotificationPreference"> | number
    stretchReminderTime?: StringWithAggregatesFilter<"NotificationPreference"> | string
    workoutReminderTime?: StringWithAggregatesFilter<"NotificationPreference"> | string
    reminderDays?: StringWithAggregatesFilter<"NotificationPreference"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    planType?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    pricePaid?: FloatNullableFilter<"Subscription"> | number | null
    currency?: StringFilter<"Subscription"> | string
    startedAt?: DateTimeFilter<"Subscription"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    provider?: StringNullableFilter<"Subscription"> | string | null
    providerSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    providerCustomerId?: StringNullableFilter<"Subscription"> | string | null
    trialStartedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    isTrial?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planType?: SortOrder
    status?: SortOrder
    pricePaid?: SortOrderInput | SortOrder
    currency?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    providerSubscriptionId?: SortOrderInput | SortOrder
    providerCustomerId?: SortOrderInput | SortOrder
    trialStartedAt?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    isTrial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    planType?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    pricePaid?: FloatNullableFilter<"Subscription"> | number | null
    currency?: StringFilter<"Subscription"> | string
    startedAt?: DateTimeFilter<"Subscription"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    provider?: StringNullableFilter<"Subscription"> | string | null
    providerSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    providerCustomerId?: StringNullableFilter<"Subscription"> | string | null
    trialStartedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    isTrial?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planType?: SortOrder
    status?: SortOrder
    pricePaid?: SortOrderInput | SortOrder
    currency?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    providerSubscriptionId?: SortOrderInput | SortOrder
    providerCustomerId?: SortOrderInput | SortOrder
    trialStartedAt?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    isTrial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    planType?: StringWithAggregatesFilter<"Subscription"> | string
    status?: StringWithAggregatesFilter<"Subscription"> | string
    pricePaid?: FloatNullableWithAggregatesFilter<"Subscription"> | number | null
    currency?: StringWithAggregatesFilter<"Subscription"> | string
    startedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    provider?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    providerSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    providerCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    trialStartedAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    isTrial?: BoolWithAggregatesFilter<"Subscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type UserConsentWhereInput = {
    AND?: UserConsentWhereInput | UserConsentWhereInput[]
    OR?: UserConsentWhereInput[]
    NOT?: UserConsentWhereInput | UserConsentWhereInput[]
    id?: StringFilter<"UserConsent"> | string
    userId?: StringFilter<"UserConsent"> | string
    consentType?: StringFilter<"UserConsent"> | string
    version?: StringFilter<"UserConsent"> | string
    consented?: BoolFilter<"UserConsent"> | boolean
    consentedAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    withdrawnAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    ipAddress?: StringNullableFilter<"UserConsent"> | string | null
    userAgent?: StringNullableFilter<"UserConsent"> | string | null
    createdAt?: DateTimeFilter<"UserConsent"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserConsentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    version?: SortOrder
    consented?: SortOrder
    consentedAt?: SortOrderInput | SortOrder
    withdrawnAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserConsentWhereInput | UserConsentWhereInput[]
    OR?: UserConsentWhereInput[]
    NOT?: UserConsentWhereInput | UserConsentWhereInput[]
    userId?: StringFilter<"UserConsent"> | string
    consentType?: StringFilter<"UserConsent"> | string
    version?: StringFilter<"UserConsent"> | string
    consented?: BoolFilter<"UserConsent"> | boolean
    consentedAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    withdrawnAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    ipAddress?: StringNullableFilter<"UserConsent"> | string | null
    userAgent?: StringNullableFilter<"UserConsent"> | string | null
    createdAt?: DateTimeFilter<"UserConsent"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserConsentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    version?: SortOrder
    consented?: SortOrder
    consentedAt?: SortOrderInput | SortOrder
    withdrawnAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserConsentCountOrderByAggregateInput
    _max?: UserConsentMaxOrderByAggregateInput
    _min?: UserConsentMinOrderByAggregateInput
  }

  export type UserConsentScalarWhereWithAggregatesInput = {
    AND?: UserConsentScalarWhereWithAggregatesInput | UserConsentScalarWhereWithAggregatesInput[]
    OR?: UserConsentScalarWhereWithAggregatesInput[]
    NOT?: UserConsentScalarWhereWithAggregatesInput | UserConsentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserConsent"> | string
    userId?: StringWithAggregatesFilter<"UserConsent"> | string
    consentType?: StringWithAggregatesFilter<"UserConsent"> | string
    version?: StringWithAggregatesFilter<"UserConsent"> | string
    consented?: BoolWithAggregatesFilter<"UserConsent"> | boolean
    consentedAt?: DateTimeNullableWithAggregatesFilter<"UserConsent"> | Date | string | null
    withdrawnAt?: DateTimeNullableWithAggregatesFilter<"UserConsent"> | Date | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"UserConsent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"UserConsent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserConsent"> | Date | string
  }

  export type DataExportRequestWhereInput = {
    AND?: DataExportRequestWhereInput | DataExportRequestWhereInput[]
    OR?: DataExportRequestWhereInput[]
    NOT?: DataExportRequestWhereInput | DataExportRequestWhereInput[]
    id?: StringFilter<"DataExportRequest"> | string
    userId?: StringFilter<"DataExportRequest"> | string
    status?: StringFilter<"DataExportRequest"> | string
    requestedAt?: DateTimeFilter<"DataExportRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"DataExportRequest"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"DataExportRequest"> | Date | string | null
    downloadUrl?: StringNullableFilter<"DataExportRequest"> | string | null
    fileSizeBytes?: IntNullableFilter<"DataExportRequest"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DataExportRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    fileSizeBytes?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DataExportRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DataExportRequestWhereInput | DataExportRequestWhereInput[]
    OR?: DataExportRequestWhereInput[]
    NOT?: DataExportRequestWhereInput | DataExportRequestWhereInput[]
    userId?: StringFilter<"DataExportRequest"> | string
    status?: StringFilter<"DataExportRequest"> | string
    requestedAt?: DateTimeFilter<"DataExportRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"DataExportRequest"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"DataExportRequest"> | Date | string | null
    downloadUrl?: StringNullableFilter<"DataExportRequest"> | string | null
    fileSizeBytes?: IntNullableFilter<"DataExportRequest"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DataExportRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    fileSizeBytes?: SortOrderInput | SortOrder
    _count?: DataExportRequestCountOrderByAggregateInput
    _avg?: DataExportRequestAvgOrderByAggregateInput
    _max?: DataExportRequestMaxOrderByAggregateInput
    _min?: DataExportRequestMinOrderByAggregateInput
    _sum?: DataExportRequestSumOrderByAggregateInput
  }

  export type DataExportRequestScalarWhereWithAggregatesInput = {
    AND?: DataExportRequestScalarWhereWithAggregatesInput | DataExportRequestScalarWhereWithAggregatesInput[]
    OR?: DataExportRequestScalarWhereWithAggregatesInput[]
    NOT?: DataExportRequestScalarWhereWithAggregatesInput | DataExportRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataExportRequest"> | string
    userId?: StringWithAggregatesFilter<"DataExportRequest"> | string
    status?: StringWithAggregatesFilter<"DataExportRequest"> | string
    requestedAt?: DateTimeWithAggregatesFilter<"DataExportRequest"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"DataExportRequest"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"DataExportRequest"> | Date | string | null
    downloadUrl?: StringNullableWithAggregatesFilter<"DataExportRequest"> | string | null
    fileSizeBytes?: IntNullableWithAggregatesFilter<"DataExportRequest"> | number | null
  }

  export type DeletionRequestWhereInput = {
    AND?: DeletionRequestWhereInput | DeletionRequestWhereInput[]
    OR?: DeletionRequestWhereInput[]
    NOT?: DeletionRequestWhereInput | DeletionRequestWhereInput[]
    id?: StringFilter<"DeletionRequest"> | string
    userId?: StringFilter<"DeletionRequest"> | string
    status?: StringFilter<"DeletionRequest"> | string
    reason?: StringNullableFilter<"DeletionRequest"> | string | null
    requestedAt?: DateTimeFilter<"DeletionRequest"> | Date | string
    gracePeriodEndsAt?: DateTimeNullableFilter<"DeletionRequest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeletionRequest"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"DeletionRequest"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DeletionRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    gracePeriodEndsAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeletionRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeletionRequestWhereInput | DeletionRequestWhereInput[]
    OR?: DeletionRequestWhereInput[]
    NOT?: DeletionRequestWhereInput | DeletionRequestWhereInput[]
    userId?: StringFilter<"DeletionRequest"> | string
    status?: StringFilter<"DeletionRequest"> | string
    reason?: StringNullableFilter<"DeletionRequest"> | string | null
    requestedAt?: DateTimeFilter<"DeletionRequest"> | Date | string
    gracePeriodEndsAt?: DateTimeNullableFilter<"DeletionRequest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeletionRequest"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"DeletionRequest"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DeletionRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    gracePeriodEndsAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    _count?: DeletionRequestCountOrderByAggregateInput
    _max?: DeletionRequestMaxOrderByAggregateInput
    _min?: DeletionRequestMinOrderByAggregateInput
  }

  export type DeletionRequestScalarWhereWithAggregatesInput = {
    AND?: DeletionRequestScalarWhereWithAggregatesInput | DeletionRequestScalarWhereWithAggregatesInput[]
    OR?: DeletionRequestScalarWhereWithAggregatesInput[]
    NOT?: DeletionRequestScalarWhereWithAggregatesInput | DeletionRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeletionRequest"> | string
    userId?: StringWithAggregatesFilter<"DeletionRequest"> | string
    status?: StringWithAggregatesFilter<"DeletionRequest"> | string
    reason?: StringNullableWithAggregatesFilter<"DeletionRequest"> | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"DeletionRequest"> | Date | string
    gracePeriodEndsAt?: DateTimeNullableWithAggregatesFilter<"DeletionRequest"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"DeletionRequest"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"DeletionRequest"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOnboardingCreateInput = {
    id?: string
    completedAt?: Date | string | null
    skipped?: boolean
    primaryGoal?: string | null
    experienceLevel?: string | null
    toeTouchScore?: number | null
    shoulderReachScore?: number | null
    hipFlexibilityScore?: number | null
    overallFlexibilityScore?: number | null
    flexibilityLevel?: string | null
    workoutDays?: string | null
    preferredWorkoutTime?: string | null
    stretchingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOnboardingInput
  }

  export type UserOnboardingUncheckedCreateInput = {
    id?: string
    userId: string
    completedAt?: Date | string | null
    skipped?: boolean
    primaryGoal?: string | null
    experienceLevel?: string | null
    toeTouchScore?: number | null
    shoulderReachScore?: number | null
    hipFlexibilityScore?: number | null
    overallFlexibilityScore?: number | null
    flexibilityLevel?: string | null
    workoutDays?: string | null
    preferredWorkoutTime?: string | null
    stretchingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserOnboardingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    primaryGoal?: NullableStringFieldUpdateOperationsInput | string | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    toeTouchScore?: NullableIntFieldUpdateOperationsInput | number | null
    shoulderReachScore?: NullableIntFieldUpdateOperationsInput | number | null
    hipFlexibilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    overallFlexibilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    flexibilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    workoutDays?: NullableStringFieldUpdateOperationsInput | string | null
    preferredWorkoutTime?: NullableStringFieldUpdateOperationsInput | string | null
    stretchingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOnboardingNestedInput
  }

  export type UserOnboardingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    primaryGoal?: NullableStringFieldUpdateOperationsInput | string | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    toeTouchScore?: NullableIntFieldUpdateOperationsInput | number | null
    shoulderReachScore?: NullableIntFieldUpdateOperationsInput | number | null
    hipFlexibilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    overallFlexibilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    flexibilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    workoutDays?: NullableStringFieldUpdateOperationsInput | string | null
    preferredWorkoutTime?: NullableStringFieldUpdateOperationsInput | string | null
    stretchingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOnboardingCreateManyInput = {
    id?: string
    userId: string
    completedAt?: Date | string | null
    skipped?: boolean
    primaryGoal?: string | null
    experienceLevel?: string | null
    toeTouchScore?: number | null
    shoulderReachScore?: number | null
    hipFlexibilityScore?: number | null
    overallFlexibilityScore?: number | null
    flexibilityLevel?: string | null
    workoutDays?: string | null
    preferredWorkoutTime?: string | null
    stretchingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserOnboardingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    primaryGoal?: NullableStringFieldUpdateOperationsInput | string | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    toeTouchScore?: NullableIntFieldUpdateOperationsInput | number | null
    shoulderReachScore?: NullableIntFieldUpdateOperationsInput | number | null
    hipFlexibilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    overallFlexibilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    flexibilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    workoutDays?: NullableStringFieldUpdateOperationsInput | string | null
    preferredWorkoutTime?: NullableStringFieldUpdateOperationsInput | string | null
    stretchingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOnboardingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    primaryGoal?: NullableStringFieldUpdateOperationsInput | string | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    toeTouchScore?: NullableIntFieldUpdateOperationsInput | number | null
    shoulderReachScore?: NullableIntFieldUpdateOperationsInput | number | null
    hipFlexibilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    overallFlexibilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    flexibilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    workoutDays?: NullableStringFieldUpdateOperationsInput | string | null
    preferredWorkoutTime?: NullableStringFieldUpdateOperationsInput | string | null
    stretchingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFollowingInput
    following: UserCreateNestedOneWithoutFollowersInput
  }

  export type UserFollowUncheckedCreateInput = {
    id?: string
    userId: string
    followingUserId: string
    createdAt?: Date | string
  }

  export type UserFollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFollowingNestedInput
    following?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type UserFollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    followingUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowCreateManyInput = {
    id?: string
    userId: string
    followingUserId: string
    createdAt?: Date | string
  }

  export type UserFollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    followingUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StretchCreateInput = {
    id?: string
    name: string
    description?: string | null
    durationSeconds: number
    videoUrl?: string | null
    thumbnailUrl?: string | null
    animationUrl?: string | null
    difficulty?: string
    primaryMuscles: string
    secondaryMuscles?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    equipment?: string | null
    tags?: string | null
    createdAt?: Date | string
    routineStretches?: RoutineStretchCreateNestedManyWithoutStretchInput
    sessionStretches?: SessionStretchCreateNestedManyWithoutStretchInput
  }

  export type StretchUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    durationSeconds: number
    videoUrl?: string | null
    thumbnailUrl?: string | null
    animationUrl?: string | null
    difficulty?: string
    primaryMuscles: string
    secondaryMuscles?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    equipment?: string | null
    tags?: string | null
    createdAt?: Date | string
    routineStretches?: RoutineStretchUncheckedCreateNestedManyWithoutStretchInput
    sessionStretches?: SessionStretchUncheckedCreateNestedManyWithoutStretchInput
  }

  export type StretchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routineStretches?: RoutineStretchUpdateManyWithoutStretchNestedInput
    sessionStretches?: SessionStretchUpdateManyWithoutStretchNestedInput
  }

  export type StretchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routineStretches?: RoutineStretchUncheckedUpdateManyWithoutStretchNestedInput
    sessionStretches?: SessionStretchUncheckedUpdateManyWithoutStretchNestedInput
  }

  export type StretchCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    durationSeconds: number
    videoUrl?: string | null
    thumbnailUrl?: string | null
    animationUrl?: string | null
    difficulty?: string
    primaryMuscles: string
    secondaryMuscles?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    equipment?: string | null
    tags?: string | null
    createdAt?: Date | string
  }

  export type StretchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StretchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StretchingRoutineCreateInput = {
    id?: string
    name: string
    description?: string | null
    difficulty?: string
    durationSeconds: number
    targetAreas?: string | null
    tags?: string | null
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStretchingRoutinesInput
    stretches?: RoutineStretchCreateNestedManyWithoutRoutineInput
    sessions?: StretchingSessionCreateNestedManyWithoutRoutineInput
  }

  export type StretchingRoutineUncheckedCreateInput = {
    id?: string
    userId?: string | null
    name: string
    description?: string | null
    difficulty?: string
    durationSeconds: number
    targetAreas?: string | null
    tags?: string | null
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stretches?: RoutineStretchUncheckedCreateNestedManyWithoutRoutineInput
    sessions?: StretchingSessionUncheckedCreateNestedManyWithoutRoutineInput
  }

  export type StretchingRoutineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    targetAreas?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    usesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStretchingRoutinesNestedInput
    stretches?: RoutineStretchUpdateManyWithoutRoutineNestedInput
    sessions?: StretchingSessionUpdateManyWithoutRoutineNestedInput
  }

  export type StretchingRoutineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    targetAreas?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    usesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stretches?: RoutineStretchUncheckedUpdateManyWithoutRoutineNestedInput
    sessions?: StretchingSessionUncheckedUpdateManyWithoutRoutineNestedInput
  }

  export type StretchingRoutineCreateManyInput = {
    id?: string
    userId?: string | null
    name: string
    description?: string | null
    difficulty?: string
    durationSeconds: number
    targetAreas?: string | null
    tags?: string | null
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StretchingRoutineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    targetAreas?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    usesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StretchingRoutineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    targetAreas?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    usesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutineStretchCreateInput = {
    id?: string
    positionOrder: number
    customDurationSeconds?: number | null
    routine: StretchingRoutineCreateNestedOneWithoutStretchesInput
    stretch: StretchCreateNestedOneWithoutRoutineStretchesInput
  }

  export type RoutineStretchUncheckedCreateInput = {
    id?: string
    routineId: string
    stretchId: string
    positionOrder: number
    customDurationSeconds?: number | null
  }

  export type RoutineStretchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    customDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    routine?: StretchingRoutineUpdateOneRequiredWithoutStretchesNestedInput
    stretch?: StretchUpdateOneRequiredWithoutRoutineStretchesNestedInput
  }

  export type RoutineStretchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineId?: StringFieldUpdateOperationsInput | string
    stretchId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    customDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoutineStretchCreateManyInput = {
    id?: string
    routineId: string
    stretchId: string
    positionOrder: number
    customDurationSeconds?: number | null
  }

  export type RoutineStretchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    customDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoutineStretchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineId?: StringFieldUpdateOperationsInput | string
    stretchId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    customDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StretchingSessionCreateInput = {
    id?: string
    routineName?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    completed?: boolean
    linkedWorkoutId?: string | null
    notes?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStretchingSessionsInput
    routine?: StretchingRoutineCreateNestedOneWithoutSessionsInput
    stretches?: SessionStretchCreateNestedManyWithoutSessionInput
  }

  export type StretchingSessionUncheckedCreateInput = {
    id?: string
    userId: string
    routineId?: string | null
    routineName?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    completed?: boolean
    linkedWorkoutId?: string | null
    notes?: string | null
    createdAt?: Date | string
    stretches?: SessionStretchUncheckedCreateNestedManyWithoutSessionInput
  }

  export type StretchingSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineName?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    linkedWorkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStretchingSessionsNestedInput
    routine?: StretchingRoutineUpdateOneWithoutSessionsNestedInput
    stretches?: SessionStretchUpdateManyWithoutSessionNestedInput
  }

  export type StretchingSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    routineId?: NullableStringFieldUpdateOperationsInput | string | null
    routineName?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    linkedWorkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stretches?: SessionStretchUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type StretchingSessionCreateManyInput = {
    id?: string
    userId: string
    routineId?: string | null
    routineName?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    completed?: boolean
    linkedWorkoutId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type StretchingSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineName?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    linkedWorkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StretchingSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    routineId?: NullableStringFieldUpdateOperationsInput | string | null
    routineName?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    linkedWorkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionStretchCreateInput = {
    id?: string
    heldDurationSeconds: number
    feltTight?: boolean
    positionInRoutine: number
    completedAt?: Date | string
    session: StretchingSessionCreateNestedOneWithoutStretchesInput
    stretch: StretchCreateNestedOneWithoutSessionStretchesInput
  }

  export type SessionStretchUncheckedCreateInput = {
    id?: string
    sessionId: string
    stretchId: string
    heldDurationSeconds: number
    feltTight?: boolean
    positionInRoutine: number
    completedAt?: Date | string
  }

  export type SessionStretchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    heldDurationSeconds?: IntFieldUpdateOperationsInput | number
    feltTight?: BoolFieldUpdateOperationsInput | boolean
    positionInRoutine?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StretchingSessionUpdateOneRequiredWithoutStretchesNestedInput
    stretch?: StretchUpdateOneRequiredWithoutSessionStretchesNestedInput
  }

  export type SessionStretchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    stretchId?: StringFieldUpdateOperationsInput | string
    heldDurationSeconds?: IntFieldUpdateOperationsInput | number
    feltTight?: BoolFieldUpdateOperationsInput | boolean
    positionInRoutine?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionStretchCreateManyInput = {
    id?: string
    sessionId: string
    stretchId: string
    heldDurationSeconds: number
    feltTight?: boolean
    positionInRoutine: number
    completedAt?: Date | string
  }

  export type SessionStretchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    heldDurationSeconds?: IntFieldUpdateOperationsInput | number
    feltTight?: BoolFieldUpdateOperationsInput | boolean
    positionInRoutine?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionStretchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    stretchId?: StringFieldUpdateOperationsInput | string
    heldDurationSeconds?: IntFieldUpdateOperationsInput | number
    feltTight?: BoolFieldUpdateOperationsInput | boolean
    positionInRoutine?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlexibilityGoalCreateInput = {
    id?: string
    goalType: string
    description?: string | null
    targetArea: string
    baselineRom?: number | null
    targetRom?: number | null
    targetDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFlexibilityGoalsInput
    measurements?: RomMeasurementCreateNestedManyWithoutGoalInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutGoalInput
  }

  export type FlexibilityGoalUncheckedCreateInput = {
    id?: string
    userId: string
    goalType: string
    description?: string | null
    targetArea: string
    baselineRom?: number | null
    targetRom?: number | null
    targetDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    measurements?: RomMeasurementUncheckedCreateNestedManyWithoutGoalInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutGoalInput
  }

  export type FlexibilityGoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetArea?: StringFieldUpdateOperationsInput | string
    baselineRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFlexibilityGoalsNestedInput
    measurements?: RomMeasurementUpdateManyWithoutGoalNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutGoalNestedInput
  }

  export type FlexibilityGoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetArea?: StringFieldUpdateOperationsInput | string
    baselineRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measurements?: RomMeasurementUncheckedUpdateManyWithoutGoalNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type FlexibilityGoalCreateManyInput = {
    id?: string
    userId: string
    goalType: string
    description?: string | null
    targetArea: string
    baselineRom?: number | null
    targetRom?: number | null
    targetDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlexibilityGoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetArea?: StringFieldUpdateOperationsInput | string
    baselineRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlexibilityGoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetArea?: StringFieldUpdateOperationsInput | string
    baselineRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RomMeasurementCreateInput = {
    id?: string
    romDegrees: number
    measurementDate?: Date | string
    measurementMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
    goal: FlexibilityGoalCreateNestedOneWithoutMeasurementsInput
  }

  export type RomMeasurementUncheckedCreateInput = {
    id?: string
    goalId: string
    romDegrees: number
    measurementDate?: Date | string
    measurementMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type RomMeasurementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    romDegrees?: FloatFieldUpdateOperationsInput | number
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: FlexibilityGoalUpdateOneRequiredWithoutMeasurementsNestedInput
  }

  export type RomMeasurementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    romDegrees?: FloatFieldUpdateOperationsInput | number
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RomMeasurementCreateManyInput = {
    id?: string
    goalId: string
    romDegrees: number
    measurementDate?: Date | string
    measurementMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type RomMeasurementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    romDegrees?: FloatFieldUpdateOperationsInput | number
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RomMeasurementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    romDegrees?: FloatFieldUpdateOperationsInput | number
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressVideoCreateInput = {
    id?: string
    videoUrl: string
    uploadedAt?: Date | string
    user: UserCreateNestedOneWithoutProgressVideosInput
    goal?: FlexibilityGoalCreateNestedOneWithoutProgressVideosInput
  }

  export type ProgressVideoUncheckedCreateInput = {
    id?: string
    userId: string
    goalId?: string | null
    videoUrl: string
    uploadedAt?: Date | string
  }

  export type ProgressVideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProgressVideosNestedInput
    goal?: FlexibilityGoalUpdateOneWithoutProgressVideosNestedInput
  }

  export type ProgressVideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressVideoCreateManyInput = {
    id?: string
    userId: string
    goalId?: string | null
    videoUrl: string
    uploadedAt?: Date | string
  }

  export type ProgressVideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressVideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    equipmentNeeded?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    primaryMuscles: string
    secondaryMuscles?: string | null
    difficulty?: string
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    isCompound?: boolean
    isUnilateral?: boolean
    forceType?: string | null
    mechanic?: string | null
    metValue?: number | null
    is1RMEligible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workoutExercises?: WorkoutExerciseCreateNestedManyWithoutExerciseInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    equipmentNeeded?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    primaryMuscles: string
    secondaryMuscles?: string | null
    difficulty?: string
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    isCompound?: boolean
    isUnilateral?: boolean
    forceType?: string | null
    mechanic?: string | null
    metValue?: number | null
    is1RMEligible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workoutExercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutExerciseInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    equipmentNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompound?: BoolFieldUpdateOperationsInput | boolean
    isUnilateral?: BoolFieldUpdateOperationsInput | boolean
    forceType?: NullableStringFieldUpdateOperationsInput | string | null
    mechanic?: NullableStringFieldUpdateOperationsInput | string | null
    metValue?: NullableFloatFieldUpdateOperationsInput | number | null
    is1RMEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutExercises?: WorkoutExerciseUpdateManyWithoutExerciseNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    equipmentNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompound?: BoolFieldUpdateOperationsInput | boolean
    isUnilateral?: BoolFieldUpdateOperationsInput | boolean
    forceType?: NullableStringFieldUpdateOperationsInput | string | null
    mechanic?: NullableStringFieldUpdateOperationsInput | string | null
    metValue?: NullableFloatFieldUpdateOperationsInput | number | null
    is1RMEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutExercises?: WorkoutExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    equipmentNeeded?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    primaryMuscles: string
    secondaryMuscles?: string | null
    difficulty?: string
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    isCompound?: boolean
    isUnilateral?: boolean
    forceType?: string | null
    mechanic?: string | null
    metValue?: number | null
    is1RMEligible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    equipmentNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompound?: BoolFieldUpdateOperationsInput | boolean
    isUnilateral?: BoolFieldUpdateOperationsInput | boolean
    forceType?: NullableStringFieldUpdateOperationsInput | string | null
    mechanic?: NullableStringFieldUpdateOperationsInput | string | null
    metValue?: NullableFloatFieldUpdateOperationsInput | number | null
    is1RMEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    equipmentNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompound?: BoolFieldUpdateOperationsInput | boolean
    isUnilateral?: BoolFieldUpdateOperationsInput | boolean
    forceType?: NullableStringFieldUpdateOperationsInput | string | null
    mechanic?: NullableStringFieldUpdateOperationsInput | string | null
    metValue?: NullableFloatFieldUpdateOperationsInput | number | null
    is1RMEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrengthWorkoutCreateInput = {
    id?: string
    name?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    sessionIntensityRpe?: number | null
    notes?: string | null
    totalVolume?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStrengthWorkoutsInput
    exercises?: WorkoutExerciseCreateNestedManyWithoutWorkoutInput
  }

  export type StrengthWorkoutUncheckedCreateInput = {
    id?: string
    userId: string
    name?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    sessionIntensityRpe?: number | null
    notes?: string | null
    totalVolume?: number | null
    createdAt?: Date | string
    exercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type StrengthWorkoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    sessionIntensityRpe?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStrengthWorkoutsNestedInput
    exercises?: WorkoutExerciseUpdateManyWithoutWorkoutNestedInput
  }

  export type StrengthWorkoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    sessionIntensityRpe?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: WorkoutExerciseUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type StrengthWorkoutCreateManyInput = {
    id?: string
    userId: string
    name?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    sessionIntensityRpe?: number | null
    notes?: string | null
    totalVolume?: number | null
    createdAt?: Date | string
  }

  export type StrengthWorkoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    sessionIntensityRpe?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrengthWorkoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    sessionIntensityRpe?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutExerciseCreateInput = {
    id?: string
    positionOrder: number
    notes?: string | null
    createdAt?: Date | string
    workout: StrengthWorkoutCreateNestedOneWithoutExercisesInput
    exercise: ExerciseCreateNestedOneWithoutWorkoutExercisesInput
    sets?: WorkoutSetCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUncheckedCreateInput = {
    id?: string
    workoutId: string
    exerciseId: string
    positionOrder: number
    notes?: string | null
    createdAt?: Date | string
    sets?: WorkoutSetUncheckedCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workout?: StrengthWorkoutUpdateOneRequiredWithoutExercisesNestedInput
    exercise?: ExerciseUpdateOneRequiredWithoutWorkoutExercisesNestedInput
    sets?: WorkoutSetUpdateManyWithoutWorkoutExerciseNestedInput
  }

  export type WorkoutExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sets?: WorkoutSetUncheckedUpdateManyWithoutWorkoutExerciseNestedInput
  }

  export type WorkoutExerciseCreateManyInput = {
    id?: string
    workoutId: string
    exerciseId: string
    positionOrder: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type WorkoutExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetCreateInput = {
    id?: string
    setNumber: number
    reps?: number | null
    weight?: number | null
    weightUnit?: string
    setType?: string
    rpe?: number | null
    isPr?: boolean
    completed?: boolean
    restSeconds?: number | null
    durationSeconds?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
    workoutExercise: WorkoutExerciseCreateNestedOneWithoutSetsInput
  }

  export type WorkoutSetUncheckedCreateInput = {
    id?: string
    workoutExerciseId: string
    setNumber: number
    reps?: number | null
    weight?: number | null
    weightUnit?: string
    setType?: string
    rpe?: number | null
    isPr?: boolean
    completed?: boolean
    restSeconds?: number | null
    durationSeconds?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
  }

  export type WorkoutSetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    setType?: StringFieldUpdateOperationsInput | string
    rpe?: NullableIntFieldUpdateOperationsInput | number | null
    isPr?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutExercise?: WorkoutExerciseUpdateOneRequiredWithoutSetsNestedInput
  }

  export type WorkoutSetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutExerciseId?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    setType?: StringFieldUpdateOperationsInput | string
    rpe?: NullableIntFieldUpdateOperationsInput | number | null
    isPr?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetCreateManyInput = {
    id?: string
    workoutExerciseId: string
    setNumber: number
    reps?: number | null
    weight?: number | null
    weightUnit?: string
    setType?: string
    rpe?: number | null
    isPr?: boolean
    completed?: boolean
    restSeconds?: number | null
    durationSeconds?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
  }

  export type WorkoutSetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    setType?: StringFieldUpdateOperationsInput | string
    rpe?: NullableIntFieldUpdateOperationsInput | number | null
    isPr?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutExerciseId?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    setType?: StringFieldUpdateOperationsInput | string
    rpe?: NullableIntFieldUpdateOperationsInput | number | null
    isPr?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalRecordCreateInput = {
    id?: string
    recordType: string
    value: number
    weightUnit?: string
    achievedAt?: Date | string
    workoutId?: string | null
    user: UserCreateNestedOneWithoutPersonalRecordsInput
    exercise: ExerciseCreateNestedOneWithoutPersonalRecordsInput
  }

  export type PersonalRecordUncheckedCreateInput = {
    id?: string
    userId: string
    exerciseId: string
    recordType: string
    value: number
    weightUnit?: string
    achievedAt?: Date | string
    workoutId?: string | null
  }

  export type PersonalRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    weightUnit?: StringFieldUpdateOperationsInput | string
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPersonalRecordsNestedInput
    exercise?: ExerciseUpdateOneRequiredWithoutPersonalRecordsNestedInput
  }

  export type PersonalRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    weightUnit?: StringFieldUpdateOperationsInput | string
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalRecordCreateManyInput = {
    id?: string
    userId: string
    exerciseId: string
    recordType: string
    value: number
    weightUnit?: string
    achievedAt?: Date | string
    workoutId?: string | null
  }

  export type PersonalRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    weightUnit?: StringFieldUpdateOperationsInput | string
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    weightUnit?: StringFieldUpdateOperationsInput | string
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BodyMetricCreateInput = {
    id?: string
    weight?: number | null
    weightUnit?: string
    bodyFatPercentage?: number | null
    chest?: number | null
    waist?: number | null
    hips?: number | null
    arms?: number | null
    thighs?: number | null
    measurementUnit?: string
    measurementDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBodyMetricsInput
  }

  export type BodyMetricUncheckedCreateInput = {
    id?: string
    userId: string
    weight?: number | null
    weightUnit?: string
    bodyFatPercentage?: number | null
    chest?: number | null
    waist?: number | null
    hips?: number | null
    arms?: number | null
    thighs?: number | null
    measurementUnit?: string
    measurementDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type BodyMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    bodyFatPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    chest?: NullableFloatFieldUpdateOperationsInput | number | null
    waist?: NullableFloatFieldUpdateOperationsInput | number | null
    hips?: NullableFloatFieldUpdateOperationsInput | number | null
    arms?: NullableFloatFieldUpdateOperationsInput | number | null
    thighs?: NullableFloatFieldUpdateOperationsInput | number | null
    measurementUnit?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBodyMetricsNestedInput
  }

  export type BodyMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    bodyFatPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    chest?: NullableFloatFieldUpdateOperationsInput | number | null
    waist?: NullableFloatFieldUpdateOperationsInput | number | null
    hips?: NullableFloatFieldUpdateOperationsInput | number | null
    arms?: NullableFloatFieldUpdateOperationsInput | number | null
    thighs?: NullableFloatFieldUpdateOperationsInput | number | null
    measurementUnit?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BodyMetricCreateManyInput = {
    id?: string
    userId: string
    weight?: number | null
    weightUnit?: string
    bodyFatPercentage?: number | null
    chest?: number | null
    waist?: number | null
    hips?: number | null
    arms?: number | null
    thighs?: number | null
    measurementUnit?: string
    measurementDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type BodyMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    bodyFatPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    chest?: NullableFloatFieldUpdateOperationsInput | number | null
    waist?: NullableFloatFieldUpdateOperationsInput | number | null
    hips?: NullableFloatFieldUpdateOperationsInput | number | null
    arms?: NullableFloatFieldUpdateOperationsInput | number | null
    thighs?: NullableFloatFieldUpdateOperationsInput | number | null
    measurementUnit?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BodyMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    bodyFatPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    chest?: NullableFloatFieldUpdateOperationsInput | number | null
    waist?: NullableFloatFieldUpdateOperationsInput | number | null
    hips?: NullableFloatFieldUpdateOperationsInput | number | null
    arms?: NullableFloatFieldUpdateOperationsInput | number | null
    thighs?: NullableFloatFieldUpdateOperationsInput | number | null
    measurementUnit?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    notificationType: string
    title: string
    body?: string | null
    actionType?: string | null
    actionData?: string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    clickedAt?: Date | string | null
    deliveryStatus?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    notificationType: string
    title: string
    body?: string | null
    actionType?: string | null
    actionData?: string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    clickedAt?: Date | string | null
    deliveryStatus?: string
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionData?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionData?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    notificationType: string
    title: string
    body?: string | null
    actionType?: string | null
    actionData?: string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    clickedAt?: Date | string | null
    deliveryStatus?: string
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionData?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionData?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    notificationsEnabled?: boolean
    stretchReminders?: boolean
    workoutReminders?: boolean
    streakNotifications?: boolean
    goalNotifications?: boolean
    socialNotifications?: boolean
    recoverySuggestions?: boolean
    inactivityNudges?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: string
    quietHoursEnd?: string
    maxDailyNotifications?: number
    stretchReminderTime?: string
    workoutReminderTime?: string
    reminderDays?: string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationPrefsInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    notificationsEnabled?: boolean
    stretchReminders?: boolean
    workoutReminders?: boolean
    streakNotifications?: boolean
    goalNotifications?: boolean
    socialNotifications?: boolean
    recoverySuggestions?: boolean
    inactivityNudges?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: string
    quietHoursEnd?: string
    maxDailyNotifications?: number
    stretchReminderTime?: string
    workoutReminderTime?: string
    reminderDays?: string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    stretchReminders?: BoolFieldUpdateOperationsInput | boolean
    workoutReminders?: BoolFieldUpdateOperationsInput | boolean
    streakNotifications?: BoolFieldUpdateOperationsInput | boolean
    goalNotifications?: BoolFieldUpdateOperationsInput | boolean
    socialNotifications?: BoolFieldUpdateOperationsInput | boolean
    recoverySuggestions?: BoolFieldUpdateOperationsInput | boolean
    inactivityNudges?: BoolFieldUpdateOperationsInput | boolean
    quietHoursEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: StringFieldUpdateOperationsInput | string
    quietHoursEnd?: StringFieldUpdateOperationsInput | string
    maxDailyNotifications?: IntFieldUpdateOperationsInput | number
    stretchReminderTime?: StringFieldUpdateOperationsInput | string
    workoutReminderTime?: StringFieldUpdateOperationsInput | string
    reminderDays?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationPrefsNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    stretchReminders?: BoolFieldUpdateOperationsInput | boolean
    workoutReminders?: BoolFieldUpdateOperationsInput | boolean
    streakNotifications?: BoolFieldUpdateOperationsInput | boolean
    goalNotifications?: BoolFieldUpdateOperationsInput | boolean
    socialNotifications?: BoolFieldUpdateOperationsInput | boolean
    recoverySuggestions?: BoolFieldUpdateOperationsInput | boolean
    inactivityNudges?: BoolFieldUpdateOperationsInput | boolean
    quietHoursEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: StringFieldUpdateOperationsInput | string
    quietHoursEnd?: StringFieldUpdateOperationsInput | string
    maxDailyNotifications?: IntFieldUpdateOperationsInput | number
    stretchReminderTime?: StringFieldUpdateOperationsInput | string
    workoutReminderTime?: StringFieldUpdateOperationsInput | string
    reminderDays?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    userId: string
    notificationsEnabled?: boolean
    stretchReminders?: boolean
    workoutReminders?: boolean
    streakNotifications?: boolean
    goalNotifications?: boolean
    socialNotifications?: boolean
    recoverySuggestions?: boolean
    inactivityNudges?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: string
    quietHoursEnd?: string
    maxDailyNotifications?: number
    stretchReminderTime?: string
    workoutReminderTime?: string
    reminderDays?: string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    stretchReminders?: BoolFieldUpdateOperationsInput | boolean
    workoutReminders?: BoolFieldUpdateOperationsInput | boolean
    streakNotifications?: BoolFieldUpdateOperationsInput | boolean
    goalNotifications?: BoolFieldUpdateOperationsInput | boolean
    socialNotifications?: BoolFieldUpdateOperationsInput | boolean
    recoverySuggestions?: BoolFieldUpdateOperationsInput | boolean
    inactivityNudges?: BoolFieldUpdateOperationsInput | boolean
    quietHoursEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: StringFieldUpdateOperationsInput | string
    quietHoursEnd?: StringFieldUpdateOperationsInput | string
    maxDailyNotifications?: IntFieldUpdateOperationsInput | number
    stretchReminderTime?: StringFieldUpdateOperationsInput | string
    workoutReminderTime?: StringFieldUpdateOperationsInput | string
    reminderDays?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    stretchReminders?: BoolFieldUpdateOperationsInput | boolean
    workoutReminders?: BoolFieldUpdateOperationsInput | boolean
    streakNotifications?: BoolFieldUpdateOperationsInput | boolean
    goalNotifications?: BoolFieldUpdateOperationsInput | boolean
    socialNotifications?: BoolFieldUpdateOperationsInput | boolean
    recoverySuggestions?: BoolFieldUpdateOperationsInput | boolean
    inactivityNudges?: BoolFieldUpdateOperationsInput | boolean
    quietHoursEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: StringFieldUpdateOperationsInput | string
    quietHoursEnd?: StringFieldUpdateOperationsInput | string
    maxDailyNotifications?: IntFieldUpdateOperationsInput | number
    stretchReminderTime?: StringFieldUpdateOperationsInput | string
    workoutReminderTime?: StringFieldUpdateOperationsInput | string
    reminderDays?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    planType?: string
    status?: string
    pricePaid?: number | null
    currency?: string
    startedAt?: Date | string
    expiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    provider?: string | null
    providerSubscriptionId?: string | null
    providerCustomerId?: string | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    isTrial?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    planType?: string
    status?: string
    pricePaid?: number | null
    currency?: string
    startedAt?: Date | string
    expiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    provider?: string | null
    providerSubscriptionId?: string | null
    providerCustomerId?: string | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    isTrial?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pricePaid?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pricePaid?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    planType?: string
    status?: string
    pricePaid?: number | null
    currency?: string
    startedAt?: Date | string
    expiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    provider?: string | null
    providerSubscriptionId?: string | null
    providerCustomerId?: string | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    isTrial?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pricePaid?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pricePaid?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentCreateInput = {
    id?: string
    consentType: string
    version: string
    consented: boolean
    consentedAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutConsentsInput
  }

  export type UserConsentUncheckedCreateInput = {
    id?: string
    userId: string
    consentType: string
    version: string
    consented: boolean
    consentedAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type UserConsentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    consented?: BoolFieldUpdateOperationsInput | boolean
    consentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConsentsNestedInput
  }

  export type UserConsentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    consented?: BoolFieldUpdateOperationsInput | boolean
    consentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentCreateManyInput = {
    id?: string
    userId: string
    consentType: string
    version: string
    consented: boolean
    consentedAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type UserConsentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    consented?: BoolFieldUpdateOperationsInput | boolean
    consentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    consented?: BoolFieldUpdateOperationsInput | boolean
    consentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataExportRequestCreateInput = {
    id?: string
    status?: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    downloadUrl?: string | null
    fileSizeBytes?: number | null
    user: UserCreateNestedOneWithoutDataExportRequestsInput
  }

  export type DataExportRequestUncheckedCreateInput = {
    id?: string
    userId: string
    status?: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    downloadUrl?: string | null
    fileSizeBytes?: number | null
  }

  export type DataExportRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutDataExportRequestsNestedInput
  }

  export type DataExportRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DataExportRequestCreateManyInput = {
    id?: string
    userId: string
    status?: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    downloadUrl?: string | null
    fileSizeBytes?: number | null
  }

  export type DataExportRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DataExportRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeletionRequestCreateInput = {
    id?: string
    status?: string
    reason?: string | null
    requestedAt?: Date | string
    gracePeriodEndsAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    user: UserCreateNestedOneWithoutDeletionRequestsInput
  }

  export type DeletionRequestUncheckedCreateInput = {
    id?: string
    userId: string
    status?: string
    reason?: string | null
    requestedAt?: Date | string
    gracePeriodEndsAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type DeletionRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gracePeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutDeletionRequestsNestedInput
  }

  export type DeletionRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gracePeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeletionRequestCreateManyInput = {
    id?: string
    userId: string
    status?: string
    reason?: string | null
    requestedAt?: Date | string
    gracePeriodEndsAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type DeletionRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gracePeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeletionRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gracePeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserOnboardingNullableRelationFilter = {
    is?: UserOnboardingWhereInput | null
    isNot?: UserOnboardingWhereInput | null
  }

  export type NotificationPreferenceNullableRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type StretchingRoutineListRelationFilter = {
    every?: StretchingRoutineWhereInput
    some?: StretchingRoutineWhereInput
    none?: StretchingRoutineWhereInput
  }

  export type StretchingSessionListRelationFilter = {
    every?: StretchingSessionWhereInput
    some?: StretchingSessionWhereInput
    none?: StretchingSessionWhereInput
  }

  export type FlexibilityGoalListRelationFilter = {
    every?: FlexibilityGoalWhereInput
    some?: FlexibilityGoalWhereInput
    none?: FlexibilityGoalWhereInput
  }

  export type BodyMetricListRelationFilter = {
    every?: BodyMetricWhereInput
    some?: BodyMetricWhereInput
    none?: BodyMetricWhereInput
  }

  export type StrengthWorkoutListRelationFilter = {
    every?: StrengthWorkoutWhereInput
    some?: StrengthWorkoutWhereInput
    none?: StrengthWorkoutWhereInput
  }

  export type PersonalRecordListRelationFilter = {
    every?: PersonalRecordWhereInput
    some?: PersonalRecordWhereInput
    none?: PersonalRecordWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type UserConsentListRelationFilter = {
    every?: UserConsentWhereInput
    some?: UserConsentWhereInput
    none?: UserConsentWhereInput
  }

  export type UserFollowListRelationFilter = {
    every?: UserFollowWhereInput
    some?: UserFollowWhereInput
    none?: UserFollowWhereInput
  }

  export type ProgressVideoListRelationFilter = {
    every?: ProgressVideoWhereInput
    some?: ProgressVideoWhereInput
    none?: ProgressVideoWhereInput
  }

  export type DataExportRequestListRelationFilter = {
    every?: DataExportRequestWhereInput
    some?: DataExportRequestWhereInput
    none?: DataExportRequestWhereInput
  }

  export type DeletionRequestListRelationFilter = {
    every?: DeletionRequestWhereInput
    some?: DeletionRequestWhereInput
    none?: DeletionRequestWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type StretchingRoutineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StretchingSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlexibilityGoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BodyMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StrengthWorkoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonalRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserConsentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgressVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataExportRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeletionRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserOnboardingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    completedAt?: SortOrder
    skipped?: SortOrder
    primaryGoal?: SortOrder
    experienceLevel?: SortOrder
    toeTouchScore?: SortOrder
    shoulderReachScore?: SortOrder
    hipFlexibilityScore?: SortOrder
    overallFlexibilityScore?: SortOrder
    flexibilityLevel?: SortOrder
    workoutDays?: SortOrder
    preferredWorkoutTime?: SortOrder
    stretchingPreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserOnboardingAvgOrderByAggregateInput = {
    toeTouchScore?: SortOrder
    shoulderReachScore?: SortOrder
    hipFlexibilityScore?: SortOrder
    overallFlexibilityScore?: SortOrder
  }

  export type UserOnboardingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    completedAt?: SortOrder
    skipped?: SortOrder
    primaryGoal?: SortOrder
    experienceLevel?: SortOrder
    toeTouchScore?: SortOrder
    shoulderReachScore?: SortOrder
    hipFlexibilityScore?: SortOrder
    overallFlexibilityScore?: SortOrder
    flexibilityLevel?: SortOrder
    workoutDays?: SortOrder
    preferredWorkoutTime?: SortOrder
    stretchingPreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserOnboardingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    completedAt?: SortOrder
    skipped?: SortOrder
    primaryGoal?: SortOrder
    experienceLevel?: SortOrder
    toeTouchScore?: SortOrder
    shoulderReachScore?: SortOrder
    hipFlexibilityScore?: SortOrder
    overallFlexibilityScore?: SortOrder
    flexibilityLevel?: SortOrder
    workoutDays?: SortOrder
    preferredWorkoutTime?: SortOrder
    stretchingPreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserOnboardingSumOrderByAggregateInput = {
    toeTouchScore?: SortOrder
    shoulderReachScore?: SortOrder
    hipFlexibilityScore?: SortOrder
    overallFlexibilityScore?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserFollowUserIdFollowingUserIdCompoundUniqueInput = {
    userId: string
    followingUserId: string
  }

  export type UserFollowCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    followingUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFollowMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    followingUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFollowMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    followingUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type RoutineStretchListRelationFilter = {
    every?: RoutineStretchWhereInput
    some?: RoutineStretchWhereInput
    none?: RoutineStretchWhereInput
  }

  export type SessionStretchListRelationFilter = {
    every?: SessionStretchWhereInput
    some?: SessionStretchWhereInput
    none?: SessionStretchWhereInput
  }

  export type RoutineStretchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionStretchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StretchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    durationSeconds?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    animationUrl?: SortOrder
    difficulty?: SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrder
    instructions?: SortOrder
    tips?: SortOrder
    commonMistakes?: SortOrder
    equipment?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
  }

  export type StretchAvgOrderByAggregateInput = {
    durationSeconds?: SortOrder
  }

  export type StretchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    durationSeconds?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    animationUrl?: SortOrder
    difficulty?: SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrder
    instructions?: SortOrder
    tips?: SortOrder
    commonMistakes?: SortOrder
    equipment?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
  }

  export type StretchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    durationSeconds?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    animationUrl?: SortOrder
    difficulty?: SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrder
    instructions?: SortOrder
    tips?: SortOrder
    commonMistakes?: SortOrder
    equipment?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
  }

  export type StretchSumOrderByAggregateInput = {
    durationSeconds?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type StretchingRoutineCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    durationSeconds?: SortOrder
    targetAreas?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    isSystem?: SortOrder
    usesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StretchingRoutineAvgOrderByAggregateInput = {
    durationSeconds?: SortOrder
    usesCount?: SortOrder
  }

  export type StretchingRoutineMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    durationSeconds?: SortOrder
    targetAreas?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    isSystem?: SortOrder
    usesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StretchingRoutineMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    durationSeconds?: SortOrder
    targetAreas?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    isSystem?: SortOrder
    usesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StretchingRoutineSumOrderByAggregateInput = {
    durationSeconds?: SortOrder
    usesCount?: SortOrder
  }

  export type StretchingRoutineRelationFilter = {
    is?: StretchingRoutineWhereInput
    isNot?: StretchingRoutineWhereInput
  }

  export type StretchRelationFilter = {
    is?: StretchWhereInput
    isNot?: StretchWhereInput
  }

  export type RoutineStretchCountOrderByAggregateInput = {
    id?: SortOrder
    routineId?: SortOrder
    stretchId?: SortOrder
    positionOrder?: SortOrder
    customDurationSeconds?: SortOrder
  }

  export type RoutineStretchAvgOrderByAggregateInput = {
    positionOrder?: SortOrder
    customDurationSeconds?: SortOrder
  }

  export type RoutineStretchMaxOrderByAggregateInput = {
    id?: SortOrder
    routineId?: SortOrder
    stretchId?: SortOrder
    positionOrder?: SortOrder
    customDurationSeconds?: SortOrder
  }

  export type RoutineStretchMinOrderByAggregateInput = {
    id?: SortOrder
    routineId?: SortOrder
    stretchId?: SortOrder
    positionOrder?: SortOrder
    customDurationSeconds?: SortOrder
  }

  export type RoutineStretchSumOrderByAggregateInput = {
    positionOrder?: SortOrder
    customDurationSeconds?: SortOrder
  }

  export type StretchingRoutineNullableRelationFilter = {
    is?: StretchingRoutineWhereInput | null
    isNot?: StretchingRoutineWhereInput | null
  }

  export type StretchingSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    routineId?: SortOrder
    routineName?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationSeconds?: SortOrder
    completed?: SortOrder
    linkedWorkoutId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type StretchingSessionAvgOrderByAggregateInput = {
    durationSeconds?: SortOrder
  }

  export type StretchingSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    routineId?: SortOrder
    routineName?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationSeconds?: SortOrder
    completed?: SortOrder
    linkedWorkoutId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type StretchingSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    routineId?: SortOrder
    routineName?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationSeconds?: SortOrder
    completed?: SortOrder
    linkedWorkoutId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type StretchingSessionSumOrderByAggregateInput = {
    durationSeconds?: SortOrder
  }

  export type StretchingSessionRelationFilter = {
    is?: StretchingSessionWhereInput
    isNot?: StretchingSessionWhereInput
  }

  export type SessionStretchCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    stretchId?: SortOrder
    heldDurationSeconds?: SortOrder
    feltTight?: SortOrder
    positionInRoutine?: SortOrder
    completedAt?: SortOrder
  }

  export type SessionStretchAvgOrderByAggregateInput = {
    heldDurationSeconds?: SortOrder
    positionInRoutine?: SortOrder
  }

  export type SessionStretchMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    stretchId?: SortOrder
    heldDurationSeconds?: SortOrder
    feltTight?: SortOrder
    positionInRoutine?: SortOrder
    completedAt?: SortOrder
  }

  export type SessionStretchMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    stretchId?: SortOrder
    heldDurationSeconds?: SortOrder
    feltTight?: SortOrder
    positionInRoutine?: SortOrder
    completedAt?: SortOrder
  }

  export type SessionStretchSumOrderByAggregateInput = {
    heldDurationSeconds?: SortOrder
    positionInRoutine?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type RomMeasurementListRelationFilter = {
    every?: RomMeasurementWhereInput
    some?: RomMeasurementWhereInput
    none?: RomMeasurementWhereInput
  }

  export type RomMeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlexibilityGoalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    description?: SortOrder
    targetArea?: SortOrder
    baselineRom?: SortOrder
    targetRom?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlexibilityGoalAvgOrderByAggregateInput = {
    baselineRom?: SortOrder
    targetRom?: SortOrder
  }

  export type FlexibilityGoalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    description?: SortOrder
    targetArea?: SortOrder
    baselineRom?: SortOrder
    targetRom?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlexibilityGoalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    description?: SortOrder
    targetArea?: SortOrder
    baselineRom?: SortOrder
    targetRom?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlexibilityGoalSumOrderByAggregateInput = {
    baselineRom?: SortOrder
    targetRom?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FlexibilityGoalRelationFilter = {
    is?: FlexibilityGoalWhereInput
    isNot?: FlexibilityGoalWhereInput
  }

  export type RomMeasurementCountOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    romDegrees?: SortOrder
    measurementDate?: SortOrder
    measurementMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type RomMeasurementAvgOrderByAggregateInput = {
    romDegrees?: SortOrder
  }

  export type RomMeasurementMaxOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    romDegrees?: SortOrder
    measurementDate?: SortOrder
    measurementMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type RomMeasurementMinOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    romDegrees?: SortOrder
    measurementDate?: SortOrder
    measurementMethod?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type RomMeasurementSumOrderByAggregateInput = {
    romDegrees?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FlexibilityGoalNullableRelationFilter = {
    is?: FlexibilityGoalWhereInput | null
    isNot?: FlexibilityGoalWhereInput | null
  }

  export type ProgressVideoCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goalId?: SortOrder
    videoUrl?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ProgressVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goalId?: SortOrder
    videoUrl?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ProgressVideoMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goalId?: SortOrder
    videoUrl?: SortOrder
    uploadedAt?: SortOrder
  }

  export type WorkoutExerciseListRelationFilter = {
    every?: WorkoutExerciseWhereInput
    some?: WorkoutExerciseWhereInput
    none?: WorkoutExerciseWhereInput
  }

  export type WorkoutExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    equipmentNeeded?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrder
    difficulty?: SortOrder
    instructions?: SortOrder
    tips?: SortOrder
    commonMistakes?: SortOrder
    isCompound?: SortOrder
    isUnilateral?: SortOrder
    forceType?: SortOrder
    mechanic?: SortOrder
    metValue?: SortOrder
    is1RMEligible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseAvgOrderByAggregateInput = {
    metValue?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    equipmentNeeded?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrder
    difficulty?: SortOrder
    instructions?: SortOrder
    tips?: SortOrder
    commonMistakes?: SortOrder
    isCompound?: SortOrder
    isUnilateral?: SortOrder
    forceType?: SortOrder
    mechanic?: SortOrder
    metValue?: SortOrder
    is1RMEligible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    equipmentNeeded?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    primaryMuscles?: SortOrder
    secondaryMuscles?: SortOrder
    difficulty?: SortOrder
    instructions?: SortOrder
    tips?: SortOrder
    commonMistakes?: SortOrder
    isCompound?: SortOrder
    isUnilateral?: SortOrder
    forceType?: SortOrder
    mechanic?: SortOrder
    metValue?: SortOrder
    is1RMEligible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseSumOrderByAggregateInput = {
    metValue?: SortOrder
  }

  export type StrengthWorkoutCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationSeconds?: SortOrder
    sessionIntensityRpe?: SortOrder
    notes?: SortOrder
    totalVolume?: SortOrder
    createdAt?: SortOrder
  }

  export type StrengthWorkoutAvgOrderByAggregateInput = {
    durationSeconds?: SortOrder
    sessionIntensityRpe?: SortOrder
    totalVolume?: SortOrder
  }

  export type StrengthWorkoutMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationSeconds?: SortOrder
    sessionIntensityRpe?: SortOrder
    notes?: SortOrder
    totalVolume?: SortOrder
    createdAt?: SortOrder
  }

  export type StrengthWorkoutMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationSeconds?: SortOrder
    sessionIntensityRpe?: SortOrder
    notes?: SortOrder
    totalVolume?: SortOrder
    createdAt?: SortOrder
  }

  export type StrengthWorkoutSumOrderByAggregateInput = {
    durationSeconds?: SortOrder
    sessionIntensityRpe?: SortOrder
    totalVolume?: SortOrder
  }

  export type StrengthWorkoutRelationFilter = {
    is?: StrengthWorkoutWhereInput
    isNot?: StrengthWorkoutWhereInput
  }

  export type ExerciseRelationFilter = {
    is?: ExerciseWhereInput
    isNot?: ExerciseWhereInput
  }

  export type WorkoutSetListRelationFilter = {
    every?: WorkoutSetWhereInput
    some?: WorkoutSetWhereInput
    none?: WorkoutSetWhereInput
  }

  export type WorkoutSetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    exerciseId?: SortOrder
    positionOrder?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkoutExerciseAvgOrderByAggregateInput = {
    positionOrder?: SortOrder
  }

  export type WorkoutExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    exerciseId?: SortOrder
    positionOrder?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkoutExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    exerciseId?: SortOrder
    positionOrder?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkoutExerciseSumOrderByAggregateInput = {
    positionOrder?: SortOrder
  }

  export type WorkoutExerciseRelationFilter = {
    is?: WorkoutExerciseWhereInput
    isNot?: WorkoutExerciseWhereInput
  }

  export type WorkoutSetCountOrderByAggregateInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    setNumber?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    setType?: SortOrder
    rpe?: SortOrder
    isPr?: SortOrder
    completed?: SortOrder
    restSeconds?: SortOrder
    durationSeconds?: SortOrder
    distanceMeters?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkoutSetAvgOrderByAggregateInput = {
    setNumber?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    rpe?: SortOrder
    restSeconds?: SortOrder
    durationSeconds?: SortOrder
    distanceMeters?: SortOrder
  }

  export type WorkoutSetMaxOrderByAggregateInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    setNumber?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    setType?: SortOrder
    rpe?: SortOrder
    isPr?: SortOrder
    completed?: SortOrder
    restSeconds?: SortOrder
    durationSeconds?: SortOrder
    distanceMeters?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkoutSetMinOrderByAggregateInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    setNumber?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    setType?: SortOrder
    rpe?: SortOrder
    isPr?: SortOrder
    completed?: SortOrder
    restSeconds?: SortOrder
    durationSeconds?: SortOrder
    distanceMeters?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkoutSetSumOrderByAggregateInput = {
    setNumber?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    rpe?: SortOrder
    restSeconds?: SortOrder
    durationSeconds?: SortOrder
    distanceMeters?: SortOrder
  }

  export type PersonalRecordUserIdExerciseIdRecordTypeCompoundUniqueInput = {
    userId: string
    exerciseId: string
    recordType: string
  }

  export type PersonalRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    recordType?: SortOrder
    value?: SortOrder
    weightUnit?: SortOrder
    achievedAt?: SortOrder
    workoutId?: SortOrder
  }

  export type PersonalRecordAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PersonalRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    recordType?: SortOrder
    value?: SortOrder
    weightUnit?: SortOrder
    achievedAt?: SortOrder
    workoutId?: SortOrder
  }

  export type PersonalRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseId?: SortOrder
    recordType?: SortOrder
    value?: SortOrder
    weightUnit?: SortOrder
    achievedAt?: SortOrder
    workoutId?: SortOrder
  }

  export type PersonalRecordSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type BodyMetricCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    bodyFatPercentage?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    hips?: SortOrder
    arms?: SortOrder
    thighs?: SortOrder
    measurementUnit?: SortOrder
    measurementDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type BodyMetricAvgOrderByAggregateInput = {
    weight?: SortOrder
    bodyFatPercentage?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    hips?: SortOrder
    arms?: SortOrder
    thighs?: SortOrder
  }

  export type BodyMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    bodyFatPercentage?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    hips?: SortOrder
    arms?: SortOrder
    thighs?: SortOrder
    measurementUnit?: SortOrder
    measurementDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type BodyMetricMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    bodyFatPercentage?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    hips?: SortOrder
    arms?: SortOrder
    thighs?: SortOrder
    measurementUnit?: SortOrder
    measurementDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type BodyMetricSumOrderByAggregateInput = {
    weight?: SortOrder
    bodyFatPercentage?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    hips?: SortOrder
    arms?: SortOrder
    thighs?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    body?: SortOrder
    actionType?: SortOrder
    actionData?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    clickedAt?: SortOrder
    deliveryStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    body?: SortOrder
    actionType?: SortOrder
    actionData?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    clickedAt?: SortOrder
    deliveryStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    body?: SortOrder
    actionType?: SortOrder
    actionData?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    clickedAt?: SortOrder
    deliveryStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationsEnabled?: SortOrder
    stretchReminders?: SortOrder
    workoutReminders?: SortOrder
    streakNotifications?: SortOrder
    goalNotifications?: SortOrder
    socialNotifications?: SortOrder
    recoverySuggestions?: SortOrder
    inactivityNudges?: SortOrder
    quietHoursEnabled?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    maxDailyNotifications?: SortOrder
    stretchReminderTime?: SortOrder
    workoutReminderTime?: SortOrder
    reminderDays?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceAvgOrderByAggregateInput = {
    maxDailyNotifications?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationsEnabled?: SortOrder
    stretchReminders?: SortOrder
    workoutReminders?: SortOrder
    streakNotifications?: SortOrder
    goalNotifications?: SortOrder
    socialNotifications?: SortOrder
    recoverySuggestions?: SortOrder
    inactivityNudges?: SortOrder
    quietHoursEnabled?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    maxDailyNotifications?: SortOrder
    stretchReminderTime?: SortOrder
    workoutReminderTime?: SortOrder
    reminderDays?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationsEnabled?: SortOrder
    stretchReminders?: SortOrder
    workoutReminders?: SortOrder
    streakNotifications?: SortOrder
    goalNotifications?: SortOrder
    socialNotifications?: SortOrder
    recoverySuggestions?: SortOrder
    inactivityNudges?: SortOrder
    quietHoursEnabled?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    maxDailyNotifications?: SortOrder
    stretchReminderTime?: SortOrder
    workoutReminderTime?: SortOrder
    reminderDays?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceSumOrderByAggregateInput = {
    maxDailyNotifications?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planType?: SortOrder
    status?: SortOrder
    pricePaid?: SortOrder
    currency?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    cancelledAt?: SortOrder
    provider?: SortOrder
    providerSubscriptionId?: SortOrder
    providerCustomerId?: SortOrder
    trialStartedAt?: SortOrder
    trialEndsAt?: SortOrder
    isTrial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    pricePaid?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planType?: SortOrder
    status?: SortOrder
    pricePaid?: SortOrder
    currency?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    cancelledAt?: SortOrder
    provider?: SortOrder
    providerSubscriptionId?: SortOrder
    providerCustomerId?: SortOrder
    trialStartedAt?: SortOrder
    trialEndsAt?: SortOrder
    isTrial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planType?: SortOrder
    status?: SortOrder
    pricePaid?: SortOrder
    currency?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    cancelledAt?: SortOrder
    provider?: SortOrder
    providerSubscriptionId?: SortOrder
    providerCustomerId?: SortOrder
    trialStartedAt?: SortOrder
    trialEndsAt?: SortOrder
    isTrial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    pricePaid?: SortOrder
  }

  export type UserConsentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    version?: SortOrder
    consented?: SortOrder
    consentedAt?: SortOrder
    withdrawnAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type UserConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    version?: SortOrder
    consented?: SortOrder
    consentedAt?: SortOrder
    withdrawnAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type UserConsentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    version?: SortOrder
    consented?: SortOrder
    consentedAt?: SortOrder
    withdrawnAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type DataExportRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
    downloadUrl?: SortOrder
    fileSizeBytes?: SortOrder
  }

  export type DataExportRequestAvgOrderByAggregateInput = {
    fileSizeBytes?: SortOrder
  }

  export type DataExportRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
    downloadUrl?: SortOrder
    fileSizeBytes?: SortOrder
  }

  export type DataExportRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    expiresAt?: SortOrder
    downloadUrl?: SortOrder
    fileSizeBytes?: SortOrder
  }

  export type DataExportRequestSumOrderByAggregateInput = {
    fileSizeBytes?: SortOrder
  }

  export type DeletionRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    requestedAt?: SortOrder
    gracePeriodEndsAt?: SortOrder
    completedAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type DeletionRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    requestedAt?: SortOrder
    gracePeriodEndsAt?: SortOrder
    completedAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type DeletionRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    requestedAt?: SortOrder
    gracePeriodEndsAt?: SortOrder
    completedAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type UserOnboardingCreateNestedOneWithoutUserInput = {
    create?: XOR<UserOnboardingCreateWithoutUserInput, UserOnboardingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserOnboardingCreateOrConnectWithoutUserInput
    connect?: UserOnboardingWhereUniqueInput
  }

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type StretchingRoutineCreateNestedManyWithoutUserInput = {
    create?: XOR<StretchingRoutineCreateWithoutUserInput, StretchingRoutineUncheckedCreateWithoutUserInput> | StretchingRoutineCreateWithoutUserInput[] | StretchingRoutineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StretchingRoutineCreateOrConnectWithoutUserInput | StretchingRoutineCreateOrConnectWithoutUserInput[]
    createMany?: StretchingRoutineCreateManyUserInputEnvelope
    connect?: StretchingRoutineWhereUniqueInput | StretchingRoutineWhereUniqueInput[]
  }

  export type StretchingSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<StretchingSessionCreateWithoutUserInput, StretchingSessionUncheckedCreateWithoutUserInput> | StretchingSessionCreateWithoutUserInput[] | StretchingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StretchingSessionCreateOrConnectWithoutUserInput | StretchingSessionCreateOrConnectWithoutUserInput[]
    createMany?: StretchingSessionCreateManyUserInputEnvelope
    connect?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
  }

  export type FlexibilityGoalCreateNestedManyWithoutUserInput = {
    create?: XOR<FlexibilityGoalCreateWithoutUserInput, FlexibilityGoalUncheckedCreateWithoutUserInput> | FlexibilityGoalCreateWithoutUserInput[] | FlexibilityGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlexibilityGoalCreateOrConnectWithoutUserInput | FlexibilityGoalCreateOrConnectWithoutUserInput[]
    createMany?: FlexibilityGoalCreateManyUserInputEnvelope
    connect?: FlexibilityGoalWhereUniqueInput | FlexibilityGoalWhereUniqueInput[]
  }

  export type BodyMetricCreateNestedManyWithoutUserInput = {
    create?: XOR<BodyMetricCreateWithoutUserInput, BodyMetricUncheckedCreateWithoutUserInput> | BodyMetricCreateWithoutUserInput[] | BodyMetricUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BodyMetricCreateOrConnectWithoutUserInput | BodyMetricCreateOrConnectWithoutUserInput[]
    createMany?: BodyMetricCreateManyUserInputEnvelope
    connect?: BodyMetricWhereUniqueInput | BodyMetricWhereUniqueInput[]
  }

  export type StrengthWorkoutCreateNestedManyWithoutUserInput = {
    create?: XOR<StrengthWorkoutCreateWithoutUserInput, StrengthWorkoutUncheckedCreateWithoutUserInput> | StrengthWorkoutCreateWithoutUserInput[] | StrengthWorkoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StrengthWorkoutCreateOrConnectWithoutUserInput | StrengthWorkoutCreateOrConnectWithoutUserInput[]
    createMany?: StrengthWorkoutCreateManyUserInputEnvelope
    connect?: StrengthWorkoutWhereUniqueInput | StrengthWorkoutWhereUniqueInput[]
  }

  export type PersonalRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<PersonalRecordCreateWithoutUserInput, PersonalRecordUncheckedCreateWithoutUserInput> | PersonalRecordCreateWithoutUserInput[] | PersonalRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutUserInput | PersonalRecordCreateOrConnectWithoutUserInput[]
    createMany?: PersonalRecordCreateManyUserInputEnvelope
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserConsentCreateNestedManyWithoutUserInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput> | UserConsentCreateWithoutUserInput[] | UserConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput | UserConsentCreateOrConnectWithoutUserInput[]
    createMany?: UserConsentCreateManyUserInputEnvelope
    connect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
  }

  export type UserFollowCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFollowCreateWithoutUserInput, UserFollowUncheckedCreateWithoutUserInput> | UserFollowCreateWithoutUserInput[] | UserFollowUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutUserInput | UserFollowCreateOrConnectWithoutUserInput[]
    createMany?: UserFollowCreateManyUserInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type UserFollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput> | UserFollowCreateWithoutFollowingInput[] | UserFollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowingInput | UserFollowCreateOrConnectWithoutFollowingInput[]
    createMany?: UserFollowCreateManyFollowingInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type ProgressVideoCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgressVideoCreateWithoutUserInput, ProgressVideoUncheckedCreateWithoutUserInput> | ProgressVideoCreateWithoutUserInput[] | ProgressVideoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressVideoCreateOrConnectWithoutUserInput | ProgressVideoCreateOrConnectWithoutUserInput[]
    createMany?: ProgressVideoCreateManyUserInputEnvelope
    connect?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
  }

  export type DataExportRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<DataExportRequestCreateWithoutUserInput, DataExportRequestUncheckedCreateWithoutUserInput> | DataExportRequestCreateWithoutUserInput[] | DataExportRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataExportRequestCreateOrConnectWithoutUserInput | DataExportRequestCreateOrConnectWithoutUserInput[]
    createMany?: DataExportRequestCreateManyUserInputEnvelope
    connect?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
  }

  export type DeletionRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<DeletionRequestCreateWithoutUserInput, DeletionRequestUncheckedCreateWithoutUserInput> | DeletionRequestCreateWithoutUserInput[] | DeletionRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeletionRequestCreateOrConnectWithoutUserInput | DeletionRequestCreateOrConnectWithoutUserInput[]
    createMany?: DeletionRequestCreateManyUserInputEnvelope
    connect?: DeletionRequestWhereUniqueInput | DeletionRequestWhereUniqueInput[]
  }

  export type UserOnboardingUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserOnboardingCreateWithoutUserInput, UserOnboardingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserOnboardingCreateOrConnectWithoutUserInput
    connect?: UserOnboardingWhereUniqueInput
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type StretchingRoutineUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StretchingRoutineCreateWithoutUserInput, StretchingRoutineUncheckedCreateWithoutUserInput> | StretchingRoutineCreateWithoutUserInput[] | StretchingRoutineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StretchingRoutineCreateOrConnectWithoutUserInput | StretchingRoutineCreateOrConnectWithoutUserInput[]
    createMany?: StretchingRoutineCreateManyUserInputEnvelope
    connect?: StretchingRoutineWhereUniqueInput | StretchingRoutineWhereUniqueInput[]
  }

  export type StretchingSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StretchingSessionCreateWithoutUserInput, StretchingSessionUncheckedCreateWithoutUserInput> | StretchingSessionCreateWithoutUserInput[] | StretchingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StretchingSessionCreateOrConnectWithoutUserInput | StretchingSessionCreateOrConnectWithoutUserInput[]
    createMany?: StretchingSessionCreateManyUserInputEnvelope
    connect?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
  }

  export type FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FlexibilityGoalCreateWithoutUserInput, FlexibilityGoalUncheckedCreateWithoutUserInput> | FlexibilityGoalCreateWithoutUserInput[] | FlexibilityGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlexibilityGoalCreateOrConnectWithoutUserInput | FlexibilityGoalCreateOrConnectWithoutUserInput[]
    createMany?: FlexibilityGoalCreateManyUserInputEnvelope
    connect?: FlexibilityGoalWhereUniqueInput | FlexibilityGoalWhereUniqueInput[]
  }

  export type BodyMetricUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BodyMetricCreateWithoutUserInput, BodyMetricUncheckedCreateWithoutUserInput> | BodyMetricCreateWithoutUserInput[] | BodyMetricUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BodyMetricCreateOrConnectWithoutUserInput | BodyMetricCreateOrConnectWithoutUserInput[]
    createMany?: BodyMetricCreateManyUserInputEnvelope
    connect?: BodyMetricWhereUniqueInput | BodyMetricWhereUniqueInput[]
  }

  export type StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StrengthWorkoutCreateWithoutUserInput, StrengthWorkoutUncheckedCreateWithoutUserInput> | StrengthWorkoutCreateWithoutUserInput[] | StrengthWorkoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StrengthWorkoutCreateOrConnectWithoutUserInput | StrengthWorkoutCreateOrConnectWithoutUserInput[]
    createMany?: StrengthWorkoutCreateManyUserInputEnvelope
    connect?: StrengthWorkoutWhereUniqueInput | StrengthWorkoutWhereUniqueInput[]
  }

  export type PersonalRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PersonalRecordCreateWithoutUserInput, PersonalRecordUncheckedCreateWithoutUserInput> | PersonalRecordCreateWithoutUserInput[] | PersonalRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutUserInput | PersonalRecordCreateOrConnectWithoutUserInput[]
    createMany?: PersonalRecordCreateManyUserInputEnvelope
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserConsentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput> | UserConsentCreateWithoutUserInput[] | UserConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput | UserConsentCreateOrConnectWithoutUserInput[]
    createMany?: UserConsentCreateManyUserInputEnvelope
    connect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
  }

  export type UserFollowUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFollowCreateWithoutUserInput, UserFollowUncheckedCreateWithoutUserInput> | UserFollowCreateWithoutUserInput[] | UserFollowUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutUserInput | UserFollowCreateOrConnectWithoutUserInput[]
    createMany?: UserFollowCreateManyUserInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type UserFollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput> | UserFollowCreateWithoutFollowingInput[] | UserFollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowingInput | UserFollowCreateOrConnectWithoutFollowingInput[]
    createMany?: UserFollowCreateManyFollowingInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type ProgressVideoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgressVideoCreateWithoutUserInput, ProgressVideoUncheckedCreateWithoutUserInput> | ProgressVideoCreateWithoutUserInput[] | ProgressVideoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressVideoCreateOrConnectWithoutUserInput | ProgressVideoCreateOrConnectWithoutUserInput[]
    createMany?: ProgressVideoCreateManyUserInputEnvelope
    connect?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
  }

  export type DataExportRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DataExportRequestCreateWithoutUserInput, DataExportRequestUncheckedCreateWithoutUserInput> | DataExportRequestCreateWithoutUserInput[] | DataExportRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataExportRequestCreateOrConnectWithoutUserInput | DataExportRequestCreateOrConnectWithoutUserInput[]
    createMany?: DataExportRequestCreateManyUserInputEnvelope
    connect?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
  }

  export type DeletionRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeletionRequestCreateWithoutUserInput, DeletionRequestUncheckedCreateWithoutUserInput> | DeletionRequestCreateWithoutUserInput[] | DeletionRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeletionRequestCreateOrConnectWithoutUserInput | DeletionRequestCreateOrConnectWithoutUserInput[]
    createMany?: DeletionRequestCreateManyUserInputEnvelope
    connect?: DeletionRequestWhereUniqueInput | DeletionRequestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserOnboardingUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserOnboardingCreateWithoutUserInput, UserOnboardingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserOnboardingCreateOrConnectWithoutUserInput
    upsert?: UserOnboardingUpsertWithoutUserInput
    disconnect?: UserOnboardingWhereInput | boolean
    delete?: UserOnboardingWhereInput | boolean
    connect?: UserOnboardingWhereUniqueInput
    update?: XOR<XOR<UserOnboardingUpdateToOneWithWhereWithoutUserInput, UserOnboardingUpdateWithoutUserInput>, UserOnboardingUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type StretchingRoutineUpdateManyWithoutUserNestedInput = {
    create?: XOR<StretchingRoutineCreateWithoutUserInput, StretchingRoutineUncheckedCreateWithoutUserInput> | StretchingRoutineCreateWithoutUserInput[] | StretchingRoutineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StretchingRoutineCreateOrConnectWithoutUserInput | StretchingRoutineCreateOrConnectWithoutUserInput[]
    upsert?: StretchingRoutineUpsertWithWhereUniqueWithoutUserInput | StretchingRoutineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StretchingRoutineCreateManyUserInputEnvelope
    set?: StretchingRoutineWhereUniqueInput | StretchingRoutineWhereUniqueInput[]
    disconnect?: StretchingRoutineWhereUniqueInput | StretchingRoutineWhereUniqueInput[]
    delete?: StretchingRoutineWhereUniqueInput | StretchingRoutineWhereUniqueInput[]
    connect?: StretchingRoutineWhereUniqueInput | StretchingRoutineWhereUniqueInput[]
    update?: StretchingRoutineUpdateWithWhereUniqueWithoutUserInput | StretchingRoutineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StretchingRoutineUpdateManyWithWhereWithoutUserInput | StretchingRoutineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StretchingRoutineScalarWhereInput | StretchingRoutineScalarWhereInput[]
  }

  export type StretchingSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<StretchingSessionCreateWithoutUserInput, StretchingSessionUncheckedCreateWithoutUserInput> | StretchingSessionCreateWithoutUserInput[] | StretchingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StretchingSessionCreateOrConnectWithoutUserInput | StretchingSessionCreateOrConnectWithoutUserInput[]
    upsert?: StretchingSessionUpsertWithWhereUniqueWithoutUserInput | StretchingSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StretchingSessionCreateManyUserInputEnvelope
    set?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    disconnect?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    delete?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    connect?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    update?: StretchingSessionUpdateWithWhereUniqueWithoutUserInput | StretchingSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StretchingSessionUpdateManyWithWhereWithoutUserInput | StretchingSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StretchingSessionScalarWhereInput | StretchingSessionScalarWhereInput[]
  }

  export type FlexibilityGoalUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlexibilityGoalCreateWithoutUserInput, FlexibilityGoalUncheckedCreateWithoutUserInput> | FlexibilityGoalCreateWithoutUserInput[] | FlexibilityGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlexibilityGoalCreateOrConnectWithoutUserInput | FlexibilityGoalCreateOrConnectWithoutUserInput[]
    upsert?: FlexibilityGoalUpsertWithWhereUniqueWithoutUserInput | FlexibilityGoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlexibilityGoalCreateManyUserInputEnvelope
    set?: FlexibilityGoalWhereUniqueInput | FlexibilityGoalWhereUniqueInput[]
    disconnect?: FlexibilityGoalWhereUniqueInput | FlexibilityGoalWhereUniqueInput[]
    delete?: FlexibilityGoalWhereUniqueInput | FlexibilityGoalWhereUniqueInput[]
    connect?: FlexibilityGoalWhereUniqueInput | FlexibilityGoalWhereUniqueInput[]
    update?: FlexibilityGoalUpdateWithWhereUniqueWithoutUserInput | FlexibilityGoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlexibilityGoalUpdateManyWithWhereWithoutUserInput | FlexibilityGoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlexibilityGoalScalarWhereInput | FlexibilityGoalScalarWhereInput[]
  }

  export type BodyMetricUpdateManyWithoutUserNestedInput = {
    create?: XOR<BodyMetricCreateWithoutUserInput, BodyMetricUncheckedCreateWithoutUserInput> | BodyMetricCreateWithoutUserInput[] | BodyMetricUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BodyMetricCreateOrConnectWithoutUserInput | BodyMetricCreateOrConnectWithoutUserInput[]
    upsert?: BodyMetricUpsertWithWhereUniqueWithoutUserInput | BodyMetricUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BodyMetricCreateManyUserInputEnvelope
    set?: BodyMetricWhereUniqueInput | BodyMetricWhereUniqueInput[]
    disconnect?: BodyMetricWhereUniqueInput | BodyMetricWhereUniqueInput[]
    delete?: BodyMetricWhereUniqueInput | BodyMetricWhereUniqueInput[]
    connect?: BodyMetricWhereUniqueInput | BodyMetricWhereUniqueInput[]
    update?: BodyMetricUpdateWithWhereUniqueWithoutUserInput | BodyMetricUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BodyMetricUpdateManyWithWhereWithoutUserInput | BodyMetricUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BodyMetricScalarWhereInput | BodyMetricScalarWhereInput[]
  }

  export type StrengthWorkoutUpdateManyWithoutUserNestedInput = {
    create?: XOR<StrengthWorkoutCreateWithoutUserInput, StrengthWorkoutUncheckedCreateWithoutUserInput> | StrengthWorkoutCreateWithoutUserInput[] | StrengthWorkoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StrengthWorkoutCreateOrConnectWithoutUserInput | StrengthWorkoutCreateOrConnectWithoutUserInput[]
    upsert?: StrengthWorkoutUpsertWithWhereUniqueWithoutUserInput | StrengthWorkoutUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StrengthWorkoutCreateManyUserInputEnvelope
    set?: StrengthWorkoutWhereUniqueInput | StrengthWorkoutWhereUniqueInput[]
    disconnect?: StrengthWorkoutWhereUniqueInput | StrengthWorkoutWhereUniqueInput[]
    delete?: StrengthWorkoutWhereUniqueInput | StrengthWorkoutWhereUniqueInput[]
    connect?: StrengthWorkoutWhereUniqueInput | StrengthWorkoutWhereUniqueInput[]
    update?: StrengthWorkoutUpdateWithWhereUniqueWithoutUserInput | StrengthWorkoutUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StrengthWorkoutUpdateManyWithWhereWithoutUserInput | StrengthWorkoutUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StrengthWorkoutScalarWhereInput | StrengthWorkoutScalarWhereInput[]
  }

  export type PersonalRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<PersonalRecordCreateWithoutUserInput, PersonalRecordUncheckedCreateWithoutUserInput> | PersonalRecordCreateWithoutUserInput[] | PersonalRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutUserInput | PersonalRecordCreateOrConnectWithoutUserInput[]
    upsert?: PersonalRecordUpsertWithWhereUniqueWithoutUserInput | PersonalRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PersonalRecordCreateManyUserInputEnvelope
    set?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    disconnect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    delete?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    update?: PersonalRecordUpdateWithWhereUniqueWithoutUserInput | PersonalRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PersonalRecordUpdateManyWithWhereWithoutUserInput | PersonalRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PersonalRecordScalarWhereInput | PersonalRecordScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserConsentUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput> | UserConsentCreateWithoutUserInput[] | UserConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput | UserConsentCreateOrConnectWithoutUserInput[]
    upsert?: UserConsentUpsertWithWhereUniqueWithoutUserInput | UserConsentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserConsentCreateManyUserInputEnvelope
    set?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    disconnect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    delete?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    connect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    update?: UserConsentUpdateWithWhereUniqueWithoutUserInput | UserConsentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserConsentUpdateManyWithWhereWithoutUserInput | UserConsentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserConsentScalarWhereInput | UserConsentScalarWhereInput[]
  }

  export type UserFollowUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFollowCreateWithoutUserInput, UserFollowUncheckedCreateWithoutUserInput> | UserFollowCreateWithoutUserInput[] | UserFollowUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutUserInput | UserFollowCreateOrConnectWithoutUserInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutUserInput | UserFollowUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFollowCreateManyUserInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutUserInput | UserFollowUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutUserInput | UserFollowUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type UserFollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput> | UserFollowCreateWithoutFollowingInput[] | UserFollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowingInput | UserFollowCreateOrConnectWithoutFollowingInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutFollowingInput | UserFollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: UserFollowCreateManyFollowingInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutFollowingInput | UserFollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutFollowingInput | UserFollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type ProgressVideoUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgressVideoCreateWithoutUserInput, ProgressVideoUncheckedCreateWithoutUserInput> | ProgressVideoCreateWithoutUserInput[] | ProgressVideoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressVideoCreateOrConnectWithoutUserInput | ProgressVideoCreateOrConnectWithoutUserInput[]
    upsert?: ProgressVideoUpsertWithWhereUniqueWithoutUserInput | ProgressVideoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgressVideoCreateManyUserInputEnvelope
    set?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    disconnect?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    delete?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    connect?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    update?: ProgressVideoUpdateWithWhereUniqueWithoutUserInput | ProgressVideoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgressVideoUpdateManyWithWhereWithoutUserInput | ProgressVideoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgressVideoScalarWhereInput | ProgressVideoScalarWhereInput[]
  }

  export type DataExportRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataExportRequestCreateWithoutUserInput, DataExportRequestUncheckedCreateWithoutUserInput> | DataExportRequestCreateWithoutUserInput[] | DataExportRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataExportRequestCreateOrConnectWithoutUserInput | DataExportRequestCreateOrConnectWithoutUserInput[]
    upsert?: DataExportRequestUpsertWithWhereUniqueWithoutUserInput | DataExportRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataExportRequestCreateManyUserInputEnvelope
    set?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    disconnect?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    delete?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    connect?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    update?: DataExportRequestUpdateWithWhereUniqueWithoutUserInput | DataExportRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataExportRequestUpdateManyWithWhereWithoutUserInput | DataExportRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataExportRequestScalarWhereInput | DataExportRequestScalarWhereInput[]
  }

  export type DeletionRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeletionRequestCreateWithoutUserInput, DeletionRequestUncheckedCreateWithoutUserInput> | DeletionRequestCreateWithoutUserInput[] | DeletionRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeletionRequestCreateOrConnectWithoutUserInput | DeletionRequestCreateOrConnectWithoutUserInput[]
    upsert?: DeletionRequestUpsertWithWhereUniqueWithoutUserInput | DeletionRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeletionRequestCreateManyUserInputEnvelope
    set?: DeletionRequestWhereUniqueInput | DeletionRequestWhereUniqueInput[]
    disconnect?: DeletionRequestWhereUniqueInput | DeletionRequestWhereUniqueInput[]
    delete?: DeletionRequestWhereUniqueInput | DeletionRequestWhereUniqueInput[]
    connect?: DeletionRequestWhereUniqueInput | DeletionRequestWhereUniqueInput[]
    update?: DeletionRequestUpdateWithWhereUniqueWithoutUserInput | DeletionRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeletionRequestUpdateManyWithWhereWithoutUserInput | DeletionRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeletionRequestScalarWhereInput | DeletionRequestScalarWhereInput[]
  }

  export type UserOnboardingUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserOnboardingCreateWithoutUserInput, UserOnboardingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserOnboardingCreateOrConnectWithoutUserInput
    upsert?: UserOnboardingUpsertWithoutUserInput
    disconnect?: UserOnboardingWhereInput | boolean
    delete?: UserOnboardingWhereInput | boolean
    connect?: UserOnboardingWhereUniqueInput
    update?: XOR<XOR<UserOnboardingUpdateToOneWithWhereWithoutUserInput, UserOnboardingUpdateWithoutUserInput>, UserOnboardingUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StretchingRoutineCreateWithoutUserInput, StretchingRoutineUncheckedCreateWithoutUserInput> | StretchingRoutineCreateWithoutUserInput[] | StretchingRoutineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StretchingRoutineCreateOrConnectWithoutUserInput | StretchingRoutineCreateOrConnectWithoutUserInput[]
    upsert?: StretchingRoutineUpsertWithWhereUniqueWithoutUserInput | StretchingRoutineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StretchingRoutineCreateManyUserInputEnvelope
    set?: StretchingRoutineWhereUniqueInput | StretchingRoutineWhereUniqueInput[]
    disconnect?: StretchingRoutineWhereUniqueInput | StretchingRoutineWhereUniqueInput[]
    delete?: StretchingRoutineWhereUniqueInput | StretchingRoutineWhereUniqueInput[]
    connect?: StretchingRoutineWhereUniqueInput | StretchingRoutineWhereUniqueInput[]
    update?: StretchingRoutineUpdateWithWhereUniqueWithoutUserInput | StretchingRoutineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StretchingRoutineUpdateManyWithWhereWithoutUserInput | StretchingRoutineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StretchingRoutineScalarWhereInput | StretchingRoutineScalarWhereInput[]
  }

  export type StretchingSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StretchingSessionCreateWithoutUserInput, StretchingSessionUncheckedCreateWithoutUserInput> | StretchingSessionCreateWithoutUserInput[] | StretchingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StretchingSessionCreateOrConnectWithoutUserInput | StretchingSessionCreateOrConnectWithoutUserInput[]
    upsert?: StretchingSessionUpsertWithWhereUniqueWithoutUserInput | StretchingSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StretchingSessionCreateManyUserInputEnvelope
    set?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    disconnect?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    delete?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    connect?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    update?: StretchingSessionUpdateWithWhereUniqueWithoutUserInput | StretchingSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StretchingSessionUpdateManyWithWhereWithoutUserInput | StretchingSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StretchingSessionScalarWhereInput | StretchingSessionScalarWhereInput[]
  }

  export type FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlexibilityGoalCreateWithoutUserInput, FlexibilityGoalUncheckedCreateWithoutUserInput> | FlexibilityGoalCreateWithoutUserInput[] | FlexibilityGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlexibilityGoalCreateOrConnectWithoutUserInput | FlexibilityGoalCreateOrConnectWithoutUserInput[]
    upsert?: FlexibilityGoalUpsertWithWhereUniqueWithoutUserInput | FlexibilityGoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlexibilityGoalCreateManyUserInputEnvelope
    set?: FlexibilityGoalWhereUniqueInput | FlexibilityGoalWhereUniqueInput[]
    disconnect?: FlexibilityGoalWhereUniqueInput | FlexibilityGoalWhereUniqueInput[]
    delete?: FlexibilityGoalWhereUniqueInput | FlexibilityGoalWhereUniqueInput[]
    connect?: FlexibilityGoalWhereUniqueInput | FlexibilityGoalWhereUniqueInput[]
    update?: FlexibilityGoalUpdateWithWhereUniqueWithoutUserInput | FlexibilityGoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlexibilityGoalUpdateManyWithWhereWithoutUserInput | FlexibilityGoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlexibilityGoalScalarWhereInput | FlexibilityGoalScalarWhereInput[]
  }

  export type BodyMetricUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BodyMetricCreateWithoutUserInput, BodyMetricUncheckedCreateWithoutUserInput> | BodyMetricCreateWithoutUserInput[] | BodyMetricUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BodyMetricCreateOrConnectWithoutUserInput | BodyMetricCreateOrConnectWithoutUserInput[]
    upsert?: BodyMetricUpsertWithWhereUniqueWithoutUserInput | BodyMetricUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BodyMetricCreateManyUserInputEnvelope
    set?: BodyMetricWhereUniqueInput | BodyMetricWhereUniqueInput[]
    disconnect?: BodyMetricWhereUniqueInput | BodyMetricWhereUniqueInput[]
    delete?: BodyMetricWhereUniqueInput | BodyMetricWhereUniqueInput[]
    connect?: BodyMetricWhereUniqueInput | BodyMetricWhereUniqueInput[]
    update?: BodyMetricUpdateWithWhereUniqueWithoutUserInput | BodyMetricUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BodyMetricUpdateManyWithWhereWithoutUserInput | BodyMetricUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BodyMetricScalarWhereInput | BodyMetricScalarWhereInput[]
  }

  export type StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StrengthWorkoutCreateWithoutUserInput, StrengthWorkoutUncheckedCreateWithoutUserInput> | StrengthWorkoutCreateWithoutUserInput[] | StrengthWorkoutUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StrengthWorkoutCreateOrConnectWithoutUserInput | StrengthWorkoutCreateOrConnectWithoutUserInput[]
    upsert?: StrengthWorkoutUpsertWithWhereUniqueWithoutUserInput | StrengthWorkoutUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StrengthWorkoutCreateManyUserInputEnvelope
    set?: StrengthWorkoutWhereUniqueInput | StrengthWorkoutWhereUniqueInput[]
    disconnect?: StrengthWorkoutWhereUniqueInput | StrengthWorkoutWhereUniqueInput[]
    delete?: StrengthWorkoutWhereUniqueInput | StrengthWorkoutWhereUniqueInput[]
    connect?: StrengthWorkoutWhereUniqueInput | StrengthWorkoutWhereUniqueInput[]
    update?: StrengthWorkoutUpdateWithWhereUniqueWithoutUserInput | StrengthWorkoutUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StrengthWorkoutUpdateManyWithWhereWithoutUserInput | StrengthWorkoutUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StrengthWorkoutScalarWhereInput | StrengthWorkoutScalarWhereInput[]
  }

  export type PersonalRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PersonalRecordCreateWithoutUserInput, PersonalRecordUncheckedCreateWithoutUserInput> | PersonalRecordCreateWithoutUserInput[] | PersonalRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutUserInput | PersonalRecordCreateOrConnectWithoutUserInput[]
    upsert?: PersonalRecordUpsertWithWhereUniqueWithoutUserInput | PersonalRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PersonalRecordCreateManyUserInputEnvelope
    set?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    disconnect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    delete?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    update?: PersonalRecordUpdateWithWhereUniqueWithoutUserInput | PersonalRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PersonalRecordUpdateManyWithWhereWithoutUserInput | PersonalRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PersonalRecordScalarWhereInput | PersonalRecordScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserConsentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput> | UserConsentCreateWithoutUserInput[] | UserConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput | UserConsentCreateOrConnectWithoutUserInput[]
    upsert?: UserConsentUpsertWithWhereUniqueWithoutUserInput | UserConsentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserConsentCreateManyUserInputEnvelope
    set?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    disconnect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    delete?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    connect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    update?: UserConsentUpdateWithWhereUniqueWithoutUserInput | UserConsentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserConsentUpdateManyWithWhereWithoutUserInput | UserConsentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserConsentScalarWhereInput | UserConsentScalarWhereInput[]
  }

  export type UserFollowUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFollowCreateWithoutUserInput, UserFollowUncheckedCreateWithoutUserInput> | UserFollowCreateWithoutUserInput[] | UserFollowUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutUserInput | UserFollowCreateOrConnectWithoutUserInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutUserInput | UserFollowUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFollowCreateManyUserInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutUserInput | UserFollowUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutUserInput | UserFollowUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type UserFollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput> | UserFollowCreateWithoutFollowingInput[] | UserFollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowingInput | UserFollowCreateOrConnectWithoutFollowingInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutFollowingInput | UserFollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: UserFollowCreateManyFollowingInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutFollowingInput | UserFollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutFollowingInput | UserFollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type ProgressVideoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgressVideoCreateWithoutUserInput, ProgressVideoUncheckedCreateWithoutUserInput> | ProgressVideoCreateWithoutUserInput[] | ProgressVideoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressVideoCreateOrConnectWithoutUserInput | ProgressVideoCreateOrConnectWithoutUserInput[]
    upsert?: ProgressVideoUpsertWithWhereUniqueWithoutUserInput | ProgressVideoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgressVideoCreateManyUserInputEnvelope
    set?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    disconnect?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    delete?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    connect?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    update?: ProgressVideoUpdateWithWhereUniqueWithoutUserInput | ProgressVideoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgressVideoUpdateManyWithWhereWithoutUserInput | ProgressVideoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgressVideoScalarWhereInput | ProgressVideoScalarWhereInput[]
  }

  export type DataExportRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataExportRequestCreateWithoutUserInput, DataExportRequestUncheckedCreateWithoutUserInput> | DataExportRequestCreateWithoutUserInput[] | DataExportRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataExportRequestCreateOrConnectWithoutUserInput | DataExportRequestCreateOrConnectWithoutUserInput[]
    upsert?: DataExportRequestUpsertWithWhereUniqueWithoutUserInput | DataExportRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataExportRequestCreateManyUserInputEnvelope
    set?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    disconnect?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    delete?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    connect?: DataExportRequestWhereUniqueInput | DataExportRequestWhereUniqueInput[]
    update?: DataExportRequestUpdateWithWhereUniqueWithoutUserInput | DataExportRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataExportRequestUpdateManyWithWhereWithoutUserInput | DataExportRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataExportRequestScalarWhereInput | DataExportRequestScalarWhereInput[]
  }

  export type DeletionRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeletionRequestCreateWithoutUserInput, DeletionRequestUncheckedCreateWithoutUserInput> | DeletionRequestCreateWithoutUserInput[] | DeletionRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeletionRequestCreateOrConnectWithoutUserInput | DeletionRequestCreateOrConnectWithoutUserInput[]
    upsert?: DeletionRequestUpsertWithWhereUniqueWithoutUserInput | DeletionRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeletionRequestCreateManyUserInputEnvelope
    set?: DeletionRequestWhereUniqueInput | DeletionRequestWhereUniqueInput[]
    disconnect?: DeletionRequestWhereUniqueInput | DeletionRequestWhereUniqueInput[]
    delete?: DeletionRequestWhereUniqueInput | DeletionRequestWhereUniqueInput[]
    connect?: DeletionRequestWhereUniqueInput | DeletionRequestWhereUniqueInput[]
    update?: DeletionRequestUpdateWithWhereUniqueWithoutUserInput | DeletionRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeletionRequestUpdateManyWithWhereWithoutUserInput | DeletionRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeletionRequestScalarWhereInput | DeletionRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOnboardingInput = {
    create?: XOR<UserCreateWithoutOnboardingInput, UserUncheckedCreateWithoutOnboardingInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutOnboardingNestedInput = {
    create?: XOR<UserCreateWithoutOnboardingInput, UserUncheckedCreateWithoutOnboardingInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingInput
    upsert?: UserUpsertWithoutOnboardingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOnboardingInput, UserUpdateWithoutOnboardingInput>, UserUncheckedUpdateWithoutOnboardingInput>
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingInput, UserUpdateWithoutFollowingInput>, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type RoutineStretchCreateNestedManyWithoutStretchInput = {
    create?: XOR<RoutineStretchCreateWithoutStretchInput, RoutineStretchUncheckedCreateWithoutStretchInput> | RoutineStretchCreateWithoutStretchInput[] | RoutineStretchUncheckedCreateWithoutStretchInput[]
    connectOrCreate?: RoutineStretchCreateOrConnectWithoutStretchInput | RoutineStretchCreateOrConnectWithoutStretchInput[]
    createMany?: RoutineStretchCreateManyStretchInputEnvelope
    connect?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
  }

  export type SessionStretchCreateNestedManyWithoutStretchInput = {
    create?: XOR<SessionStretchCreateWithoutStretchInput, SessionStretchUncheckedCreateWithoutStretchInput> | SessionStretchCreateWithoutStretchInput[] | SessionStretchUncheckedCreateWithoutStretchInput[]
    connectOrCreate?: SessionStretchCreateOrConnectWithoutStretchInput | SessionStretchCreateOrConnectWithoutStretchInput[]
    createMany?: SessionStretchCreateManyStretchInputEnvelope
    connect?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
  }

  export type RoutineStretchUncheckedCreateNestedManyWithoutStretchInput = {
    create?: XOR<RoutineStretchCreateWithoutStretchInput, RoutineStretchUncheckedCreateWithoutStretchInput> | RoutineStretchCreateWithoutStretchInput[] | RoutineStretchUncheckedCreateWithoutStretchInput[]
    connectOrCreate?: RoutineStretchCreateOrConnectWithoutStretchInput | RoutineStretchCreateOrConnectWithoutStretchInput[]
    createMany?: RoutineStretchCreateManyStretchInputEnvelope
    connect?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
  }

  export type SessionStretchUncheckedCreateNestedManyWithoutStretchInput = {
    create?: XOR<SessionStretchCreateWithoutStretchInput, SessionStretchUncheckedCreateWithoutStretchInput> | SessionStretchCreateWithoutStretchInput[] | SessionStretchUncheckedCreateWithoutStretchInput[]
    connectOrCreate?: SessionStretchCreateOrConnectWithoutStretchInput | SessionStretchCreateOrConnectWithoutStretchInput[]
    createMany?: SessionStretchCreateManyStretchInputEnvelope
    connect?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RoutineStretchUpdateManyWithoutStretchNestedInput = {
    create?: XOR<RoutineStretchCreateWithoutStretchInput, RoutineStretchUncheckedCreateWithoutStretchInput> | RoutineStretchCreateWithoutStretchInput[] | RoutineStretchUncheckedCreateWithoutStretchInput[]
    connectOrCreate?: RoutineStretchCreateOrConnectWithoutStretchInput | RoutineStretchCreateOrConnectWithoutStretchInput[]
    upsert?: RoutineStretchUpsertWithWhereUniqueWithoutStretchInput | RoutineStretchUpsertWithWhereUniqueWithoutStretchInput[]
    createMany?: RoutineStretchCreateManyStretchInputEnvelope
    set?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    disconnect?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    delete?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    connect?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    update?: RoutineStretchUpdateWithWhereUniqueWithoutStretchInput | RoutineStretchUpdateWithWhereUniqueWithoutStretchInput[]
    updateMany?: RoutineStretchUpdateManyWithWhereWithoutStretchInput | RoutineStretchUpdateManyWithWhereWithoutStretchInput[]
    deleteMany?: RoutineStretchScalarWhereInput | RoutineStretchScalarWhereInput[]
  }

  export type SessionStretchUpdateManyWithoutStretchNestedInput = {
    create?: XOR<SessionStretchCreateWithoutStretchInput, SessionStretchUncheckedCreateWithoutStretchInput> | SessionStretchCreateWithoutStretchInput[] | SessionStretchUncheckedCreateWithoutStretchInput[]
    connectOrCreate?: SessionStretchCreateOrConnectWithoutStretchInput | SessionStretchCreateOrConnectWithoutStretchInput[]
    upsert?: SessionStretchUpsertWithWhereUniqueWithoutStretchInput | SessionStretchUpsertWithWhereUniqueWithoutStretchInput[]
    createMany?: SessionStretchCreateManyStretchInputEnvelope
    set?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    disconnect?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    delete?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    connect?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    update?: SessionStretchUpdateWithWhereUniqueWithoutStretchInput | SessionStretchUpdateWithWhereUniqueWithoutStretchInput[]
    updateMany?: SessionStretchUpdateManyWithWhereWithoutStretchInput | SessionStretchUpdateManyWithWhereWithoutStretchInput[]
    deleteMany?: SessionStretchScalarWhereInput | SessionStretchScalarWhereInput[]
  }

  export type RoutineStretchUncheckedUpdateManyWithoutStretchNestedInput = {
    create?: XOR<RoutineStretchCreateWithoutStretchInput, RoutineStretchUncheckedCreateWithoutStretchInput> | RoutineStretchCreateWithoutStretchInput[] | RoutineStretchUncheckedCreateWithoutStretchInput[]
    connectOrCreate?: RoutineStretchCreateOrConnectWithoutStretchInput | RoutineStretchCreateOrConnectWithoutStretchInput[]
    upsert?: RoutineStretchUpsertWithWhereUniqueWithoutStretchInput | RoutineStretchUpsertWithWhereUniqueWithoutStretchInput[]
    createMany?: RoutineStretchCreateManyStretchInputEnvelope
    set?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    disconnect?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    delete?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    connect?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    update?: RoutineStretchUpdateWithWhereUniqueWithoutStretchInput | RoutineStretchUpdateWithWhereUniqueWithoutStretchInput[]
    updateMany?: RoutineStretchUpdateManyWithWhereWithoutStretchInput | RoutineStretchUpdateManyWithWhereWithoutStretchInput[]
    deleteMany?: RoutineStretchScalarWhereInput | RoutineStretchScalarWhereInput[]
  }

  export type SessionStretchUncheckedUpdateManyWithoutStretchNestedInput = {
    create?: XOR<SessionStretchCreateWithoutStretchInput, SessionStretchUncheckedCreateWithoutStretchInput> | SessionStretchCreateWithoutStretchInput[] | SessionStretchUncheckedCreateWithoutStretchInput[]
    connectOrCreate?: SessionStretchCreateOrConnectWithoutStretchInput | SessionStretchCreateOrConnectWithoutStretchInput[]
    upsert?: SessionStretchUpsertWithWhereUniqueWithoutStretchInput | SessionStretchUpsertWithWhereUniqueWithoutStretchInput[]
    createMany?: SessionStretchCreateManyStretchInputEnvelope
    set?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    disconnect?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    delete?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    connect?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    update?: SessionStretchUpdateWithWhereUniqueWithoutStretchInput | SessionStretchUpdateWithWhereUniqueWithoutStretchInput[]
    updateMany?: SessionStretchUpdateManyWithWhereWithoutStretchInput | SessionStretchUpdateManyWithWhereWithoutStretchInput[]
    deleteMany?: SessionStretchScalarWhereInput | SessionStretchScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStretchingRoutinesInput = {
    create?: XOR<UserCreateWithoutStretchingRoutinesInput, UserUncheckedCreateWithoutStretchingRoutinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStretchingRoutinesInput
    connect?: UserWhereUniqueInput
  }

  export type RoutineStretchCreateNestedManyWithoutRoutineInput = {
    create?: XOR<RoutineStretchCreateWithoutRoutineInput, RoutineStretchUncheckedCreateWithoutRoutineInput> | RoutineStretchCreateWithoutRoutineInput[] | RoutineStretchUncheckedCreateWithoutRoutineInput[]
    connectOrCreate?: RoutineStretchCreateOrConnectWithoutRoutineInput | RoutineStretchCreateOrConnectWithoutRoutineInput[]
    createMany?: RoutineStretchCreateManyRoutineInputEnvelope
    connect?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
  }

  export type StretchingSessionCreateNestedManyWithoutRoutineInput = {
    create?: XOR<StretchingSessionCreateWithoutRoutineInput, StretchingSessionUncheckedCreateWithoutRoutineInput> | StretchingSessionCreateWithoutRoutineInput[] | StretchingSessionUncheckedCreateWithoutRoutineInput[]
    connectOrCreate?: StretchingSessionCreateOrConnectWithoutRoutineInput | StretchingSessionCreateOrConnectWithoutRoutineInput[]
    createMany?: StretchingSessionCreateManyRoutineInputEnvelope
    connect?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
  }

  export type RoutineStretchUncheckedCreateNestedManyWithoutRoutineInput = {
    create?: XOR<RoutineStretchCreateWithoutRoutineInput, RoutineStretchUncheckedCreateWithoutRoutineInput> | RoutineStretchCreateWithoutRoutineInput[] | RoutineStretchUncheckedCreateWithoutRoutineInput[]
    connectOrCreate?: RoutineStretchCreateOrConnectWithoutRoutineInput | RoutineStretchCreateOrConnectWithoutRoutineInput[]
    createMany?: RoutineStretchCreateManyRoutineInputEnvelope
    connect?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
  }

  export type StretchingSessionUncheckedCreateNestedManyWithoutRoutineInput = {
    create?: XOR<StretchingSessionCreateWithoutRoutineInput, StretchingSessionUncheckedCreateWithoutRoutineInput> | StretchingSessionCreateWithoutRoutineInput[] | StretchingSessionUncheckedCreateWithoutRoutineInput[]
    connectOrCreate?: StretchingSessionCreateOrConnectWithoutRoutineInput | StretchingSessionCreateOrConnectWithoutRoutineInput[]
    createMany?: StretchingSessionCreateManyRoutineInputEnvelope
    connect?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutStretchingRoutinesNestedInput = {
    create?: XOR<UserCreateWithoutStretchingRoutinesInput, UserUncheckedCreateWithoutStretchingRoutinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStretchingRoutinesInput
    upsert?: UserUpsertWithoutStretchingRoutinesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStretchingRoutinesInput, UserUpdateWithoutStretchingRoutinesInput>, UserUncheckedUpdateWithoutStretchingRoutinesInput>
  }

  export type RoutineStretchUpdateManyWithoutRoutineNestedInput = {
    create?: XOR<RoutineStretchCreateWithoutRoutineInput, RoutineStretchUncheckedCreateWithoutRoutineInput> | RoutineStretchCreateWithoutRoutineInput[] | RoutineStretchUncheckedCreateWithoutRoutineInput[]
    connectOrCreate?: RoutineStretchCreateOrConnectWithoutRoutineInput | RoutineStretchCreateOrConnectWithoutRoutineInput[]
    upsert?: RoutineStretchUpsertWithWhereUniqueWithoutRoutineInput | RoutineStretchUpsertWithWhereUniqueWithoutRoutineInput[]
    createMany?: RoutineStretchCreateManyRoutineInputEnvelope
    set?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    disconnect?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    delete?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    connect?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    update?: RoutineStretchUpdateWithWhereUniqueWithoutRoutineInput | RoutineStretchUpdateWithWhereUniqueWithoutRoutineInput[]
    updateMany?: RoutineStretchUpdateManyWithWhereWithoutRoutineInput | RoutineStretchUpdateManyWithWhereWithoutRoutineInput[]
    deleteMany?: RoutineStretchScalarWhereInput | RoutineStretchScalarWhereInput[]
  }

  export type StretchingSessionUpdateManyWithoutRoutineNestedInput = {
    create?: XOR<StretchingSessionCreateWithoutRoutineInput, StretchingSessionUncheckedCreateWithoutRoutineInput> | StretchingSessionCreateWithoutRoutineInput[] | StretchingSessionUncheckedCreateWithoutRoutineInput[]
    connectOrCreate?: StretchingSessionCreateOrConnectWithoutRoutineInput | StretchingSessionCreateOrConnectWithoutRoutineInput[]
    upsert?: StretchingSessionUpsertWithWhereUniqueWithoutRoutineInput | StretchingSessionUpsertWithWhereUniqueWithoutRoutineInput[]
    createMany?: StretchingSessionCreateManyRoutineInputEnvelope
    set?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    disconnect?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    delete?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    connect?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    update?: StretchingSessionUpdateWithWhereUniqueWithoutRoutineInput | StretchingSessionUpdateWithWhereUniqueWithoutRoutineInput[]
    updateMany?: StretchingSessionUpdateManyWithWhereWithoutRoutineInput | StretchingSessionUpdateManyWithWhereWithoutRoutineInput[]
    deleteMany?: StretchingSessionScalarWhereInput | StretchingSessionScalarWhereInput[]
  }

  export type RoutineStretchUncheckedUpdateManyWithoutRoutineNestedInput = {
    create?: XOR<RoutineStretchCreateWithoutRoutineInput, RoutineStretchUncheckedCreateWithoutRoutineInput> | RoutineStretchCreateWithoutRoutineInput[] | RoutineStretchUncheckedCreateWithoutRoutineInput[]
    connectOrCreate?: RoutineStretchCreateOrConnectWithoutRoutineInput | RoutineStretchCreateOrConnectWithoutRoutineInput[]
    upsert?: RoutineStretchUpsertWithWhereUniqueWithoutRoutineInput | RoutineStretchUpsertWithWhereUniqueWithoutRoutineInput[]
    createMany?: RoutineStretchCreateManyRoutineInputEnvelope
    set?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    disconnect?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    delete?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    connect?: RoutineStretchWhereUniqueInput | RoutineStretchWhereUniqueInput[]
    update?: RoutineStretchUpdateWithWhereUniqueWithoutRoutineInput | RoutineStretchUpdateWithWhereUniqueWithoutRoutineInput[]
    updateMany?: RoutineStretchUpdateManyWithWhereWithoutRoutineInput | RoutineStretchUpdateManyWithWhereWithoutRoutineInput[]
    deleteMany?: RoutineStretchScalarWhereInput | RoutineStretchScalarWhereInput[]
  }

  export type StretchingSessionUncheckedUpdateManyWithoutRoutineNestedInput = {
    create?: XOR<StretchingSessionCreateWithoutRoutineInput, StretchingSessionUncheckedCreateWithoutRoutineInput> | StretchingSessionCreateWithoutRoutineInput[] | StretchingSessionUncheckedCreateWithoutRoutineInput[]
    connectOrCreate?: StretchingSessionCreateOrConnectWithoutRoutineInput | StretchingSessionCreateOrConnectWithoutRoutineInput[]
    upsert?: StretchingSessionUpsertWithWhereUniqueWithoutRoutineInput | StretchingSessionUpsertWithWhereUniqueWithoutRoutineInput[]
    createMany?: StretchingSessionCreateManyRoutineInputEnvelope
    set?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    disconnect?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    delete?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    connect?: StretchingSessionWhereUniqueInput | StretchingSessionWhereUniqueInput[]
    update?: StretchingSessionUpdateWithWhereUniqueWithoutRoutineInput | StretchingSessionUpdateWithWhereUniqueWithoutRoutineInput[]
    updateMany?: StretchingSessionUpdateManyWithWhereWithoutRoutineInput | StretchingSessionUpdateManyWithWhereWithoutRoutineInput[]
    deleteMany?: StretchingSessionScalarWhereInput | StretchingSessionScalarWhereInput[]
  }

  export type StretchingRoutineCreateNestedOneWithoutStretchesInput = {
    create?: XOR<StretchingRoutineCreateWithoutStretchesInput, StretchingRoutineUncheckedCreateWithoutStretchesInput>
    connectOrCreate?: StretchingRoutineCreateOrConnectWithoutStretchesInput
    connect?: StretchingRoutineWhereUniqueInput
  }

  export type StretchCreateNestedOneWithoutRoutineStretchesInput = {
    create?: XOR<StretchCreateWithoutRoutineStretchesInput, StretchUncheckedCreateWithoutRoutineStretchesInput>
    connectOrCreate?: StretchCreateOrConnectWithoutRoutineStretchesInput
    connect?: StretchWhereUniqueInput
  }

  export type StretchingRoutineUpdateOneRequiredWithoutStretchesNestedInput = {
    create?: XOR<StretchingRoutineCreateWithoutStretchesInput, StretchingRoutineUncheckedCreateWithoutStretchesInput>
    connectOrCreate?: StretchingRoutineCreateOrConnectWithoutStretchesInput
    upsert?: StretchingRoutineUpsertWithoutStretchesInput
    connect?: StretchingRoutineWhereUniqueInput
    update?: XOR<XOR<StretchingRoutineUpdateToOneWithWhereWithoutStretchesInput, StretchingRoutineUpdateWithoutStretchesInput>, StretchingRoutineUncheckedUpdateWithoutStretchesInput>
  }

  export type StretchUpdateOneRequiredWithoutRoutineStretchesNestedInput = {
    create?: XOR<StretchCreateWithoutRoutineStretchesInput, StretchUncheckedCreateWithoutRoutineStretchesInput>
    connectOrCreate?: StretchCreateOrConnectWithoutRoutineStretchesInput
    upsert?: StretchUpsertWithoutRoutineStretchesInput
    connect?: StretchWhereUniqueInput
    update?: XOR<XOR<StretchUpdateToOneWithWhereWithoutRoutineStretchesInput, StretchUpdateWithoutRoutineStretchesInput>, StretchUncheckedUpdateWithoutRoutineStretchesInput>
  }

  export type UserCreateNestedOneWithoutStretchingSessionsInput = {
    create?: XOR<UserCreateWithoutStretchingSessionsInput, UserUncheckedCreateWithoutStretchingSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStretchingSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type StretchingRoutineCreateNestedOneWithoutSessionsInput = {
    create?: XOR<StretchingRoutineCreateWithoutSessionsInput, StretchingRoutineUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: StretchingRoutineCreateOrConnectWithoutSessionsInput
    connect?: StretchingRoutineWhereUniqueInput
  }

  export type SessionStretchCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionStretchCreateWithoutSessionInput, SessionStretchUncheckedCreateWithoutSessionInput> | SessionStretchCreateWithoutSessionInput[] | SessionStretchUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionStretchCreateOrConnectWithoutSessionInput | SessionStretchCreateOrConnectWithoutSessionInput[]
    createMany?: SessionStretchCreateManySessionInputEnvelope
    connect?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
  }

  export type SessionStretchUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionStretchCreateWithoutSessionInput, SessionStretchUncheckedCreateWithoutSessionInput> | SessionStretchCreateWithoutSessionInput[] | SessionStretchUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionStretchCreateOrConnectWithoutSessionInput | SessionStretchCreateOrConnectWithoutSessionInput[]
    createMany?: SessionStretchCreateManySessionInputEnvelope
    connect?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutStretchingSessionsNestedInput = {
    create?: XOR<UserCreateWithoutStretchingSessionsInput, UserUncheckedCreateWithoutStretchingSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStretchingSessionsInput
    upsert?: UserUpsertWithoutStretchingSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStretchingSessionsInput, UserUpdateWithoutStretchingSessionsInput>, UserUncheckedUpdateWithoutStretchingSessionsInput>
  }

  export type StretchingRoutineUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<StretchingRoutineCreateWithoutSessionsInput, StretchingRoutineUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: StretchingRoutineCreateOrConnectWithoutSessionsInput
    upsert?: StretchingRoutineUpsertWithoutSessionsInput
    disconnect?: StretchingRoutineWhereInput | boolean
    delete?: StretchingRoutineWhereInput | boolean
    connect?: StretchingRoutineWhereUniqueInput
    update?: XOR<XOR<StretchingRoutineUpdateToOneWithWhereWithoutSessionsInput, StretchingRoutineUpdateWithoutSessionsInput>, StretchingRoutineUncheckedUpdateWithoutSessionsInput>
  }

  export type SessionStretchUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionStretchCreateWithoutSessionInput, SessionStretchUncheckedCreateWithoutSessionInput> | SessionStretchCreateWithoutSessionInput[] | SessionStretchUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionStretchCreateOrConnectWithoutSessionInput | SessionStretchCreateOrConnectWithoutSessionInput[]
    upsert?: SessionStretchUpsertWithWhereUniqueWithoutSessionInput | SessionStretchUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionStretchCreateManySessionInputEnvelope
    set?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    disconnect?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    delete?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    connect?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    update?: SessionStretchUpdateWithWhereUniqueWithoutSessionInput | SessionStretchUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionStretchUpdateManyWithWhereWithoutSessionInput | SessionStretchUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionStretchScalarWhereInput | SessionStretchScalarWhereInput[]
  }

  export type SessionStretchUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionStretchCreateWithoutSessionInput, SessionStretchUncheckedCreateWithoutSessionInput> | SessionStretchCreateWithoutSessionInput[] | SessionStretchUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionStretchCreateOrConnectWithoutSessionInput | SessionStretchCreateOrConnectWithoutSessionInput[]
    upsert?: SessionStretchUpsertWithWhereUniqueWithoutSessionInput | SessionStretchUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionStretchCreateManySessionInputEnvelope
    set?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    disconnect?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    delete?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    connect?: SessionStretchWhereUniqueInput | SessionStretchWhereUniqueInput[]
    update?: SessionStretchUpdateWithWhereUniqueWithoutSessionInput | SessionStretchUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionStretchUpdateManyWithWhereWithoutSessionInput | SessionStretchUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionStretchScalarWhereInput | SessionStretchScalarWhereInput[]
  }

  export type StretchingSessionCreateNestedOneWithoutStretchesInput = {
    create?: XOR<StretchingSessionCreateWithoutStretchesInput, StretchingSessionUncheckedCreateWithoutStretchesInput>
    connectOrCreate?: StretchingSessionCreateOrConnectWithoutStretchesInput
    connect?: StretchingSessionWhereUniqueInput
  }

  export type StretchCreateNestedOneWithoutSessionStretchesInput = {
    create?: XOR<StretchCreateWithoutSessionStretchesInput, StretchUncheckedCreateWithoutSessionStretchesInput>
    connectOrCreate?: StretchCreateOrConnectWithoutSessionStretchesInput
    connect?: StretchWhereUniqueInput
  }

  export type StretchingSessionUpdateOneRequiredWithoutStretchesNestedInput = {
    create?: XOR<StretchingSessionCreateWithoutStretchesInput, StretchingSessionUncheckedCreateWithoutStretchesInput>
    connectOrCreate?: StretchingSessionCreateOrConnectWithoutStretchesInput
    upsert?: StretchingSessionUpsertWithoutStretchesInput
    connect?: StretchingSessionWhereUniqueInput
    update?: XOR<XOR<StretchingSessionUpdateToOneWithWhereWithoutStretchesInput, StretchingSessionUpdateWithoutStretchesInput>, StretchingSessionUncheckedUpdateWithoutStretchesInput>
  }

  export type StretchUpdateOneRequiredWithoutSessionStretchesNestedInput = {
    create?: XOR<StretchCreateWithoutSessionStretchesInput, StretchUncheckedCreateWithoutSessionStretchesInput>
    connectOrCreate?: StretchCreateOrConnectWithoutSessionStretchesInput
    upsert?: StretchUpsertWithoutSessionStretchesInput
    connect?: StretchWhereUniqueInput
    update?: XOR<XOR<StretchUpdateToOneWithWhereWithoutSessionStretchesInput, StretchUpdateWithoutSessionStretchesInput>, StretchUncheckedUpdateWithoutSessionStretchesInput>
  }

  export type UserCreateNestedOneWithoutFlexibilityGoalsInput = {
    create?: XOR<UserCreateWithoutFlexibilityGoalsInput, UserUncheckedCreateWithoutFlexibilityGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlexibilityGoalsInput
    connect?: UserWhereUniqueInput
  }

  export type RomMeasurementCreateNestedManyWithoutGoalInput = {
    create?: XOR<RomMeasurementCreateWithoutGoalInput, RomMeasurementUncheckedCreateWithoutGoalInput> | RomMeasurementCreateWithoutGoalInput[] | RomMeasurementUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: RomMeasurementCreateOrConnectWithoutGoalInput | RomMeasurementCreateOrConnectWithoutGoalInput[]
    createMany?: RomMeasurementCreateManyGoalInputEnvelope
    connect?: RomMeasurementWhereUniqueInput | RomMeasurementWhereUniqueInput[]
  }

  export type ProgressVideoCreateNestedManyWithoutGoalInput = {
    create?: XOR<ProgressVideoCreateWithoutGoalInput, ProgressVideoUncheckedCreateWithoutGoalInput> | ProgressVideoCreateWithoutGoalInput[] | ProgressVideoUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: ProgressVideoCreateOrConnectWithoutGoalInput | ProgressVideoCreateOrConnectWithoutGoalInput[]
    createMany?: ProgressVideoCreateManyGoalInputEnvelope
    connect?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
  }

  export type RomMeasurementUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<RomMeasurementCreateWithoutGoalInput, RomMeasurementUncheckedCreateWithoutGoalInput> | RomMeasurementCreateWithoutGoalInput[] | RomMeasurementUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: RomMeasurementCreateOrConnectWithoutGoalInput | RomMeasurementCreateOrConnectWithoutGoalInput[]
    createMany?: RomMeasurementCreateManyGoalInputEnvelope
    connect?: RomMeasurementWhereUniqueInput | RomMeasurementWhereUniqueInput[]
  }

  export type ProgressVideoUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<ProgressVideoCreateWithoutGoalInput, ProgressVideoUncheckedCreateWithoutGoalInput> | ProgressVideoCreateWithoutGoalInput[] | ProgressVideoUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: ProgressVideoCreateOrConnectWithoutGoalInput | ProgressVideoCreateOrConnectWithoutGoalInput[]
    createMany?: ProgressVideoCreateManyGoalInputEnvelope
    connect?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutFlexibilityGoalsNestedInput = {
    create?: XOR<UserCreateWithoutFlexibilityGoalsInput, UserUncheckedCreateWithoutFlexibilityGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlexibilityGoalsInput
    upsert?: UserUpsertWithoutFlexibilityGoalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFlexibilityGoalsInput, UserUpdateWithoutFlexibilityGoalsInput>, UserUncheckedUpdateWithoutFlexibilityGoalsInput>
  }

  export type RomMeasurementUpdateManyWithoutGoalNestedInput = {
    create?: XOR<RomMeasurementCreateWithoutGoalInput, RomMeasurementUncheckedCreateWithoutGoalInput> | RomMeasurementCreateWithoutGoalInput[] | RomMeasurementUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: RomMeasurementCreateOrConnectWithoutGoalInput | RomMeasurementCreateOrConnectWithoutGoalInput[]
    upsert?: RomMeasurementUpsertWithWhereUniqueWithoutGoalInput | RomMeasurementUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: RomMeasurementCreateManyGoalInputEnvelope
    set?: RomMeasurementWhereUniqueInput | RomMeasurementWhereUniqueInput[]
    disconnect?: RomMeasurementWhereUniqueInput | RomMeasurementWhereUniqueInput[]
    delete?: RomMeasurementWhereUniqueInput | RomMeasurementWhereUniqueInput[]
    connect?: RomMeasurementWhereUniqueInput | RomMeasurementWhereUniqueInput[]
    update?: RomMeasurementUpdateWithWhereUniqueWithoutGoalInput | RomMeasurementUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: RomMeasurementUpdateManyWithWhereWithoutGoalInput | RomMeasurementUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: RomMeasurementScalarWhereInput | RomMeasurementScalarWhereInput[]
  }

  export type ProgressVideoUpdateManyWithoutGoalNestedInput = {
    create?: XOR<ProgressVideoCreateWithoutGoalInput, ProgressVideoUncheckedCreateWithoutGoalInput> | ProgressVideoCreateWithoutGoalInput[] | ProgressVideoUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: ProgressVideoCreateOrConnectWithoutGoalInput | ProgressVideoCreateOrConnectWithoutGoalInput[]
    upsert?: ProgressVideoUpsertWithWhereUniqueWithoutGoalInput | ProgressVideoUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: ProgressVideoCreateManyGoalInputEnvelope
    set?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    disconnect?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    delete?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    connect?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    update?: ProgressVideoUpdateWithWhereUniqueWithoutGoalInput | ProgressVideoUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: ProgressVideoUpdateManyWithWhereWithoutGoalInput | ProgressVideoUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: ProgressVideoScalarWhereInput | ProgressVideoScalarWhereInput[]
  }

  export type RomMeasurementUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<RomMeasurementCreateWithoutGoalInput, RomMeasurementUncheckedCreateWithoutGoalInput> | RomMeasurementCreateWithoutGoalInput[] | RomMeasurementUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: RomMeasurementCreateOrConnectWithoutGoalInput | RomMeasurementCreateOrConnectWithoutGoalInput[]
    upsert?: RomMeasurementUpsertWithWhereUniqueWithoutGoalInput | RomMeasurementUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: RomMeasurementCreateManyGoalInputEnvelope
    set?: RomMeasurementWhereUniqueInput | RomMeasurementWhereUniqueInput[]
    disconnect?: RomMeasurementWhereUniqueInput | RomMeasurementWhereUniqueInput[]
    delete?: RomMeasurementWhereUniqueInput | RomMeasurementWhereUniqueInput[]
    connect?: RomMeasurementWhereUniqueInput | RomMeasurementWhereUniqueInput[]
    update?: RomMeasurementUpdateWithWhereUniqueWithoutGoalInput | RomMeasurementUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: RomMeasurementUpdateManyWithWhereWithoutGoalInput | RomMeasurementUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: RomMeasurementScalarWhereInput | RomMeasurementScalarWhereInput[]
  }

  export type ProgressVideoUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<ProgressVideoCreateWithoutGoalInput, ProgressVideoUncheckedCreateWithoutGoalInput> | ProgressVideoCreateWithoutGoalInput[] | ProgressVideoUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: ProgressVideoCreateOrConnectWithoutGoalInput | ProgressVideoCreateOrConnectWithoutGoalInput[]
    upsert?: ProgressVideoUpsertWithWhereUniqueWithoutGoalInput | ProgressVideoUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: ProgressVideoCreateManyGoalInputEnvelope
    set?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    disconnect?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    delete?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    connect?: ProgressVideoWhereUniqueInput | ProgressVideoWhereUniqueInput[]
    update?: ProgressVideoUpdateWithWhereUniqueWithoutGoalInput | ProgressVideoUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: ProgressVideoUpdateManyWithWhereWithoutGoalInput | ProgressVideoUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: ProgressVideoScalarWhereInput | ProgressVideoScalarWhereInput[]
  }

  export type FlexibilityGoalCreateNestedOneWithoutMeasurementsInput = {
    create?: XOR<FlexibilityGoalCreateWithoutMeasurementsInput, FlexibilityGoalUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: FlexibilityGoalCreateOrConnectWithoutMeasurementsInput
    connect?: FlexibilityGoalWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FlexibilityGoalUpdateOneRequiredWithoutMeasurementsNestedInput = {
    create?: XOR<FlexibilityGoalCreateWithoutMeasurementsInput, FlexibilityGoalUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: FlexibilityGoalCreateOrConnectWithoutMeasurementsInput
    upsert?: FlexibilityGoalUpsertWithoutMeasurementsInput
    connect?: FlexibilityGoalWhereUniqueInput
    update?: XOR<XOR<FlexibilityGoalUpdateToOneWithWhereWithoutMeasurementsInput, FlexibilityGoalUpdateWithoutMeasurementsInput>, FlexibilityGoalUncheckedUpdateWithoutMeasurementsInput>
  }

  export type UserCreateNestedOneWithoutProgressVideosInput = {
    create?: XOR<UserCreateWithoutProgressVideosInput, UserUncheckedCreateWithoutProgressVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressVideosInput
    connect?: UserWhereUniqueInput
  }

  export type FlexibilityGoalCreateNestedOneWithoutProgressVideosInput = {
    create?: XOR<FlexibilityGoalCreateWithoutProgressVideosInput, FlexibilityGoalUncheckedCreateWithoutProgressVideosInput>
    connectOrCreate?: FlexibilityGoalCreateOrConnectWithoutProgressVideosInput
    connect?: FlexibilityGoalWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProgressVideosNestedInput = {
    create?: XOR<UserCreateWithoutProgressVideosInput, UserUncheckedCreateWithoutProgressVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressVideosInput
    upsert?: UserUpsertWithoutProgressVideosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProgressVideosInput, UserUpdateWithoutProgressVideosInput>, UserUncheckedUpdateWithoutProgressVideosInput>
  }

  export type FlexibilityGoalUpdateOneWithoutProgressVideosNestedInput = {
    create?: XOR<FlexibilityGoalCreateWithoutProgressVideosInput, FlexibilityGoalUncheckedCreateWithoutProgressVideosInput>
    connectOrCreate?: FlexibilityGoalCreateOrConnectWithoutProgressVideosInput
    upsert?: FlexibilityGoalUpsertWithoutProgressVideosInput
    disconnect?: FlexibilityGoalWhereInput | boolean
    delete?: FlexibilityGoalWhereInput | boolean
    connect?: FlexibilityGoalWhereUniqueInput
    update?: XOR<XOR<FlexibilityGoalUpdateToOneWithWhereWithoutProgressVideosInput, FlexibilityGoalUpdateWithoutProgressVideosInput>, FlexibilityGoalUncheckedUpdateWithoutProgressVideosInput>
  }

  export type WorkoutExerciseCreateNestedManyWithoutExerciseInput = {
    create?: XOR<WorkoutExerciseCreateWithoutExerciseInput, WorkoutExerciseUncheckedCreateWithoutExerciseInput> | WorkoutExerciseCreateWithoutExerciseInput[] | WorkoutExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutExerciseInput | WorkoutExerciseCreateOrConnectWithoutExerciseInput[]
    createMany?: WorkoutExerciseCreateManyExerciseInputEnvelope
    connect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
  }

  export type PersonalRecordCreateNestedManyWithoutExerciseInput = {
    create?: XOR<PersonalRecordCreateWithoutExerciseInput, PersonalRecordUncheckedCreateWithoutExerciseInput> | PersonalRecordCreateWithoutExerciseInput[] | PersonalRecordUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutExerciseInput | PersonalRecordCreateOrConnectWithoutExerciseInput[]
    createMany?: PersonalRecordCreateManyExerciseInputEnvelope
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
  }

  export type WorkoutExerciseUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<WorkoutExerciseCreateWithoutExerciseInput, WorkoutExerciseUncheckedCreateWithoutExerciseInput> | WorkoutExerciseCreateWithoutExerciseInput[] | WorkoutExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutExerciseInput | WorkoutExerciseCreateOrConnectWithoutExerciseInput[]
    createMany?: WorkoutExerciseCreateManyExerciseInputEnvelope
    connect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
  }

  export type PersonalRecordUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<PersonalRecordCreateWithoutExerciseInput, PersonalRecordUncheckedCreateWithoutExerciseInput> | PersonalRecordCreateWithoutExerciseInput[] | PersonalRecordUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutExerciseInput | PersonalRecordCreateOrConnectWithoutExerciseInput[]
    createMany?: PersonalRecordCreateManyExerciseInputEnvelope
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
  }

  export type WorkoutExerciseUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<WorkoutExerciseCreateWithoutExerciseInput, WorkoutExerciseUncheckedCreateWithoutExerciseInput> | WorkoutExerciseCreateWithoutExerciseInput[] | WorkoutExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutExerciseInput | WorkoutExerciseCreateOrConnectWithoutExerciseInput[]
    upsert?: WorkoutExerciseUpsertWithWhereUniqueWithoutExerciseInput | WorkoutExerciseUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: WorkoutExerciseCreateManyExerciseInputEnvelope
    set?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    disconnect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    delete?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    connect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    update?: WorkoutExerciseUpdateWithWhereUniqueWithoutExerciseInput | WorkoutExerciseUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: WorkoutExerciseUpdateManyWithWhereWithoutExerciseInput | WorkoutExerciseUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: WorkoutExerciseScalarWhereInput | WorkoutExerciseScalarWhereInput[]
  }

  export type PersonalRecordUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<PersonalRecordCreateWithoutExerciseInput, PersonalRecordUncheckedCreateWithoutExerciseInput> | PersonalRecordCreateWithoutExerciseInput[] | PersonalRecordUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutExerciseInput | PersonalRecordCreateOrConnectWithoutExerciseInput[]
    upsert?: PersonalRecordUpsertWithWhereUniqueWithoutExerciseInput | PersonalRecordUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: PersonalRecordCreateManyExerciseInputEnvelope
    set?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    disconnect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    delete?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    update?: PersonalRecordUpdateWithWhereUniqueWithoutExerciseInput | PersonalRecordUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: PersonalRecordUpdateManyWithWhereWithoutExerciseInput | PersonalRecordUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: PersonalRecordScalarWhereInput | PersonalRecordScalarWhereInput[]
  }

  export type WorkoutExerciseUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<WorkoutExerciseCreateWithoutExerciseInput, WorkoutExerciseUncheckedCreateWithoutExerciseInput> | WorkoutExerciseCreateWithoutExerciseInput[] | WorkoutExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutExerciseInput | WorkoutExerciseCreateOrConnectWithoutExerciseInput[]
    upsert?: WorkoutExerciseUpsertWithWhereUniqueWithoutExerciseInput | WorkoutExerciseUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: WorkoutExerciseCreateManyExerciseInputEnvelope
    set?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    disconnect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    delete?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    connect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    update?: WorkoutExerciseUpdateWithWhereUniqueWithoutExerciseInput | WorkoutExerciseUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: WorkoutExerciseUpdateManyWithWhereWithoutExerciseInput | WorkoutExerciseUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: WorkoutExerciseScalarWhereInput | WorkoutExerciseScalarWhereInput[]
  }

  export type PersonalRecordUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<PersonalRecordCreateWithoutExerciseInput, PersonalRecordUncheckedCreateWithoutExerciseInput> | PersonalRecordCreateWithoutExerciseInput[] | PersonalRecordUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: PersonalRecordCreateOrConnectWithoutExerciseInput | PersonalRecordCreateOrConnectWithoutExerciseInput[]
    upsert?: PersonalRecordUpsertWithWhereUniqueWithoutExerciseInput | PersonalRecordUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: PersonalRecordCreateManyExerciseInputEnvelope
    set?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    disconnect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    delete?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    connect?: PersonalRecordWhereUniqueInput | PersonalRecordWhereUniqueInput[]
    update?: PersonalRecordUpdateWithWhereUniqueWithoutExerciseInput | PersonalRecordUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: PersonalRecordUpdateManyWithWhereWithoutExerciseInput | PersonalRecordUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: PersonalRecordScalarWhereInput | PersonalRecordScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStrengthWorkoutsInput = {
    create?: XOR<UserCreateWithoutStrengthWorkoutsInput, UserUncheckedCreateWithoutStrengthWorkoutsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStrengthWorkoutsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkoutExerciseCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput> | WorkoutExerciseCreateWithoutWorkoutInput[] | WorkoutExerciseUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutWorkoutInput | WorkoutExerciseCreateOrConnectWithoutWorkoutInput[]
    createMany?: WorkoutExerciseCreateManyWorkoutInputEnvelope
    connect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
  }

  export type WorkoutExerciseUncheckedCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput> | WorkoutExerciseCreateWithoutWorkoutInput[] | WorkoutExerciseUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutWorkoutInput | WorkoutExerciseCreateOrConnectWithoutWorkoutInput[]
    createMany?: WorkoutExerciseCreateManyWorkoutInputEnvelope
    connect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutStrengthWorkoutsNestedInput = {
    create?: XOR<UserCreateWithoutStrengthWorkoutsInput, UserUncheckedCreateWithoutStrengthWorkoutsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStrengthWorkoutsInput
    upsert?: UserUpsertWithoutStrengthWorkoutsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStrengthWorkoutsInput, UserUpdateWithoutStrengthWorkoutsInput>, UserUncheckedUpdateWithoutStrengthWorkoutsInput>
  }

  export type WorkoutExerciseUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput> | WorkoutExerciseCreateWithoutWorkoutInput[] | WorkoutExerciseUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutWorkoutInput | WorkoutExerciseCreateOrConnectWithoutWorkoutInput[]
    upsert?: WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput | WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: WorkoutExerciseCreateManyWorkoutInputEnvelope
    set?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    disconnect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    delete?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    connect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    update?: WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput | WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput | WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: WorkoutExerciseScalarWhereInput | WorkoutExerciseScalarWhereInput[]
  }

  export type WorkoutExerciseUncheckedUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput> | WorkoutExerciseCreateWithoutWorkoutInput[] | WorkoutExerciseUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutWorkoutInput | WorkoutExerciseCreateOrConnectWithoutWorkoutInput[]
    upsert?: WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput | WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: WorkoutExerciseCreateManyWorkoutInputEnvelope
    set?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    disconnect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    delete?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    connect?: WorkoutExerciseWhereUniqueInput | WorkoutExerciseWhereUniqueInput[]
    update?: WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput | WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput | WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: WorkoutExerciseScalarWhereInput | WorkoutExerciseScalarWhereInput[]
  }

  export type StrengthWorkoutCreateNestedOneWithoutExercisesInput = {
    create?: XOR<StrengthWorkoutCreateWithoutExercisesInput, StrengthWorkoutUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: StrengthWorkoutCreateOrConnectWithoutExercisesInput
    connect?: StrengthWorkoutWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutWorkoutExercisesInput = {
    create?: XOR<ExerciseCreateWithoutWorkoutExercisesInput, ExerciseUncheckedCreateWithoutWorkoutExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutWorkoutExercisesInput
    connect?: ExerciseWhereUniqueInput
  }

  export type WorkoutSetCreateNestedManyWithoutWorkoutExerciseInput = {
    create?: XOR<WorkoutSetCreateWithoutWorkoutExerciseInput, WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput> | WorkoutSetCreateWithoutWorkoutExerciseInput[] | WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput[]
    connectOrCreate?: WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput | WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput[]
    createMany?: WorkoutSetCreateManyWorkoutExerciseInputEnvelope
    connect?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
  }

  export type WorkoutSetUncheckedCreateNestedManyWithoutWorkoutExerciseInput = {
    create?: XOR<WorkoutSetCreateWithoutWorkoutExerciseInput, WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput> | WorkoutSetCreateWithoutWorkoutExerciseInput[] | WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput[]
    connectOrCreate?: WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput | WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput[]
    createMany?: WorkoutSetCreateManyWorkoutExerciseInputEnvelope
    connect?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
  }

  export type StrengthWorkoutUpdateOneRequiredWithoutExercisesNestedInput = {
    create?: XOR<StrengthWorkoutCreateWithoutExercisesInput, StrengthWorkoutUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: StrengthWorkoutCreateOrConnectWithoutExercisesInput
    upsert?: StrengthWorkoutUpsertWithoutExercisesInput
    connect?: StrengthWorkoutWhereUniqueInput
    update?: XOR<XOR<StrengthWorkoutUpdateToOneWithWhereWithoutExercisesInput, StrengthWorkoutUpdateWithoutExercisesInput>, StrengthWorkoutUncheckedUpdateWithoutExercisesInput>
  }

  export type ExerciseUpdateOneRequiredWithoutWorkoutExercisesNestedInput = {
    create?: XOR<ExerciseCreateWithoutWorkoutExercisesInput, ExerciseUncheckedCreateWithoutWorkoutExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutWorkoutExercisesInput
    upsert?: ExerciseUpsertWithoutWorkoutExercisesInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutWorkoutExercisesInput, ExerciseUpdateWithoutWorkoutExercisesInput>, ExerciseUncheckedUpdateWithoutWorkoutExercisesInput>
  }

  export type WorkoutSetUpdateManyWithoutWorkoutExerciseNestedInput = {
    create?: XOR<WorkoutSetCreateWithoutWorkoutExerciseInput, WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput> | WorkoutSetCreateWithoutWorkoutExerciseInput[] | WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput[]
    connectOrCreate?: WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput | WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput[]
    upsert?: WorkoutSetUpsertWithWhereUniqueWithoutWorkoutExerciseInput | WorkoutSetUpsertWithWhereUniqueWithoutWorkoutExerciseInput[]
    createMany?: WorkoutSetCreateManyWorkoutExerciseInputEnvelope
    set?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    disconnect?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    delete?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    connect?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    update?: WorkoutSetUpdateWithWhereUniqueWithoutWorkoutExerciseInput | WorkoutSetUpdateWithWhereUniqueWithoutWorkoutExerciseInput[]
    updateMany?: WorkoutSetUpdateManyWithWhereWithoutWorkoutExerciseInput | WorkoutSetUpdateManyWithWhereWithoutWorkoutExerciseInput[]
    deleteMany?: WorkoutSetScalarWhereInput | WorkoutSetScalarWhereInput[]
  }

  export type WorkoutSetUncheckedUpdateManyWithoutWorkoutExerciseNestedInput = {
    create?: XOR<WorkoutSetCreateWithoutWorkoutExerciseInput, WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput> | WorkoutSetCreateWithoutWorkoutExerciseInput[] | WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput[]
    connectOrCreate?: WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput | WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput[]
    upsert?: WorkoutSetUpsertWithWhereUniqueWithoutWorkoutExerciseInput | WorkoutSetUpsertWithWhereUniqueWithoutWorkoutExerciseInput[]
    createMany?: WorkoutSetCreateManyWorkoutExerciseInputEnvelope
    set?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    disconnect?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    delete?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    connect?: WorkoutSetWhereUniqueInput | WorkoutSetWhereUniqueInput[]
    update?: WorkoutSetUpdateWithWhereUniqueWithoutWorkoutExerciseInput | WorkoutSetUpdateWithWhereUniqueWithoutWorkoutExerciseInput[]
    updateMany?: WorkoutSetUpdateManyWithWhereWithoutWorkoutExerciseInput | WorkoutSetUpdateManyWithWhereWithoutWorkoutExerciseInput[]
    deleteMany?: WorkoutSetScalarWhereInput | WorkoutSetScalarWhereInput[]
  }

  export type WorkoutExerciseCreateNestedOneWithoutSetsInput = {
    create?: XOR<WorkoutExerciseCreateWithoutSetsInput, WorkoutExerciseUncheckedCreateWithoutSetsInput>
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutSetsInput
    connect?: WorkoutExerciseWhereUniqueInput
  }

  export type WorkoutExerciseUpdateOneRequiredWithoutSetsNestedInput = {
    create?: XOR<WorkoutExerciseCreateWithoutSetsInput, WorkoutExerciseUncheckedCreateWithoutSetsInput>
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutSetsInput
    upsert?: WorkoutExerciseUpsertWithoutSetsInput
    connect?: WorkoutExerciseWhereUniqueInput
    update?: XOR<XOR<WorkoutExerciseUpdateToOneWithWhereWithoutSetsInput, WorkoutExerciseUpdateWithoutSetsInput>, WorkoutExerciseUncheckedUpdateWithoutSetsInput>
  }

  export type UserCreateNestedOneWithoutPersonalRecordsInput = {
    create?: XOR<UserCreateWithoutPersonalRecordsInput, UserUncheckedCreateWithoutPersonalRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutPersonalRecordsInput = {
    create?: XOR<ExerciseCreateWithoutPersonalRecordsInput, ExerciseUncheckedCreateWithoutPersonalRecordsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutPersonalRecordsInput
    connect?: ExerciseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPersonalRecordsNestedInput = {
    create?: XOR<UserCreateWithoutPersonalRecordsInput, UserUncheckedCreateWithoutPersonalRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalRecordsInput
    upsert?: UserUpsertWithoutPersonalRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonalRecordsInput, UserUpdateWithoutPersonalRecordsInput>, UserUncheckedUpdateWithoutPersonalRecordsInput>
  }

  export type ExerciseUpdateOneRequiredWithoutPersonalRecordsNestedInput = {
    create?: XOR<ExerciseCreateWithoutPersonalRecordsInput, ExerciseUncheckedCreateWithoutPersonalRecordsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutPersonalRecordsInput
    upsert?: ExerciseUpsertWithoutPersonalRecordsInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutPersonalRecordsInput, ExerciseUpdateWithoutPersonalRecordsInput>, ExerciseUncheckedUpdateWithoutPersonalRecordsInput>
  }

  export type UserCreateNestedOneWithoutBodyMetricsInput = {
    create?: XOR<UserCreateWithoutBodyMetricsInput, UserUncheckedCreateWithoutBodyMetricsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBodyMetricsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBodyMetricsNestedInput = {
    create?: XOR<UserCreateWithoutBodyMetricsInput, UserUncheckedCreateWithoutBodyMetricsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBodyMetricsInput
    upsert?: UserUpsertWithoutBodyMetricsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBodyMetricsInput, UserUpdateWithoutBodyMetricsInput>, UserUncheckedUpdateWithoutBodyMetricsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutNotificationPrefsInput = {
    create?: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPrefsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationPrefsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPrefsInput
    upsert?: UserUpsertWithoutNotificationPrefsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPrefsInput, UserUpdateWithoutNotificationPrefsInput>, UserUncheckedUpdateWithoutNotificationPrefsInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserCreateNestedOneWithoutConsentsInput = {
    create?: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutConsentsNestedInput = {
    create?: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsentsInput
    upsert?: UserUpsertWithoutConsentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConsentsInput, UserUpdateWithoutConsentsInput>, UserUncheckedUpdateWithoutConsentsInput>
  }

  export type UserCreateNestedOneWithoutDataExportRequestsInput = {
    create?: XOR<UserCreateWithoutDataExportRequestsInput, UserUncheckedCreateWithoutDataExportRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataExportRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDataExportRequestsNestedInput = {
    create?: XOR<UserCreateWithoutDataExportRequestsInput, UserUncheckedCreateWithoutDataExportRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataExportRequestsInput
    upsert?: UserUpsertWithoutDataExportRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDataExportRequestsInput, UserUpdateWithoutDataExportRequestsInput>, UserUncheckedUpdateWithoutDataExportRequestsInput>
  }

  export type UserCreateNestedOneWithoutDeletionRequestsInput = {
    create?: XOR<UserCreateWithoutDeletionRequestsInput, UserUncheckedCreateWithoutDeletionRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletionRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeletionRequestsNestedInput = {
    create?: XOR<UserCreateWithoutDeletionRequestsInput, UserUncheckedCreateWithoutDeletionRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletionRequestsInput
    upsert?: UserUpsertWithoutDeletionRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeletionRequestsInput, UserUpdateWithoutDeletionRequestsInput>, UserUncheckedUpdateWithoutDeletionRequestsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserOnboardingCreateWithoutUserInput = {
    id?: string
    completedAt?: Date | string | null
    skipped?: boolean
    primaryGoal?: string | null
    experienceLevel?: string | null
    toeTouchScore?: number | null
    shoulderReachScore?: number | null
    hipFlexibilityScore?: number | null
    overallFlexibilityScore?: number | null
    flexibilityLevel?: string | null
    workoutDays?: string | null
    preferredWorkoutTime?: string | null
    stretchingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserOnboardingUncheckedCreateWithoutUserInput = {
    id?: string
    completedAt?: Date | string | null
    skipped?: boolean
    primaryGoal?: string | null
    experienceLevel?: string | null
    toeTouchScore?: number | null
    shoulderReachScore?: number | null
    hipFlexibilityScore?: number | null
    overallFlexibilityScore?: number | null
    flexibilityLevel?: string | null
    workoutDays?: string | null
    preferredWorkoutTime?: string | null
    stretchingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserOnboardingCreateOrConnectWithoutUserInput = {
    where: UserOnboardingWhereUniqueInput
    create: XOR<UserOnboardingCreateWithoutUserInput, UserOnboardingUncheckedCreateWithoutUserInput>
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    id?: string
    notificationsEnabled?: boolean
    stretchReminders?: boolean
    workoutReminders?: boolean
    streakNotifications?: boolean
    goalNotifications?: boolean
    socialNotifications?: boolean
    recoverySuggestions?: boolean
    inactivityNudges?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: string
    quietHoursEnd?: string
    maxDailyNotifications?: number
    stretchReminderTime?: string
    workoutReminderTime?: string
    reminderDays?: string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    notificationsEnabled?: boolean
    stretchReminders?: boolean
    workoutReminders?: boolean
    streakNotifications?: boolean
    goalNotifications?: boolean
    socialNotifications?: boolean
    recoverySuggestions?: boolean
    inactivityNudges?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: string
    quietHoursEnd?: string
    maxDailyNotifications?: number
    stretchReminderTime?: string
    workoutReminderTime?: string
    reminderDays?: string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    planType?: string
    status?: string
    pricePaid?: number | null
    currency?: string
    startedAt?: Date | string
    expiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    provider?: string | null
    providerSubscriptionId?: string | null
    providerCustomerId?: string | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    isTrial?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    planType?: string
    status?: string
    pricePaid?: number | null
    currency?: string
    startedAt?: Date | string
    expiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    provider?: string | null
    providerSubscriptionId?: string | null
    providerCustomerId?: string | null
    trialStartedAt?: Date | string | null
    trialEndsAt?: Date | string | null
    isTrial?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type StretchingRoutineCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    difficulty?: string
    durationSeconds: number
    targetAreas?: string | null
    tags?: string | null
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stretches?: RoutineStretchCreateNestedManyWithoutRoutineInput
    sessions?: StretchingSessionCreateNestedManyWithoutRoutineInput
  }

  export type StretchingRoutineUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    difficulty?: string
    durationSeconds: number
    targetAreas?: string | null
    tags?: string | null
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stretches?: RoutineStretchUncheckedCreateNestedManyWithoutRoutineInput
    sessions?: StretchingSessionUncheckedCreateNestedManyWithoutRoutineInput
  }

  export type StretchingRoutineCreateOrConnectWithoutUserInput = {
    where: StretchingRoutineWhereUniqueInput
    create: XOR<StretchingRoutineCreateWithoutUserInput, StretchingRoutineUncheckedCreateWithoutUserInput>
  }

  export type StretchingRoutineCreateManyUserInputEnvelope = {
    data: StretchingRoutineCreateManyUserInput | StretchingRoutineCreateManyUserInput[]
  }

  export type StretchingSessionCreateWithoutUserInput = {
    id?: string
    routineName?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    completed?: boolean
    linkedWorkoutId?: string | null
    notes?: string | null
    createdAt?: Date | string
    routine?: StretchingRoutineCreateNestedOneWithoutSessionsInput
    stretches?: SessionStretchCreateNestedManyWithoutSessionInput
  }

  export type StretchingSessionUncheckedCreateWithoutUserInput = {
    id?: string
    routineId?: string | null
    routineName?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    completed?: boolean
    linkedWorkoutId?: string | null
    notes?: string | null
    createdAt?: Date | string
    stretches?: SessionStretchUncheckedCreateNestedManyWithoutSessionInput
  }

  export type StretchingSessionCreateOrConnectWithoutUserInput = {
    where: StretchingSessionWhereUniqueInput
    create: XOR<StretchingSessionCreateWithoutUserInput, StretchingSessionUncheckedCreateWithoutUserInput>
  }

  export type StretchingSessionCreateManyUserInputEnvelope = {
    data: StretchingSessionCreateManyUserInput | StretchingSessionCreateManyUserInput[]
  }

  export type FlexibilityGoalCreateWithoutUserInput = {
    id?: string
    goalType: string
    description?: string | null
    targetArea: string
    baselineRom?: number | null
    targetRom?: number | null
    targetDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    measurements?: RomMeasurementCreateNestedManyWithoutGoalInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutGoalInput
  }

  export type FlexibilityGoalUncheckedCreateWithoutUserInput = {
    id?: string
    goalType: string
    description?: string | null
    targetArea: string
    baselineRom?: number | null
    targetRom?: number | null
    targetDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    measurements?: RomMeasurementUncheckedCreateNestedManyWithoutGoalInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutGoalInput
  }

  export type FlexibilityGoalCreateOrConnectWithoutUserInput = {
    where: FlexibilityGoalWhereUniqueInput
    create: XOR<FlexibilityGoalCreateWithoutUserInput, FlexibilityGoalUncheckedCreateWithoutUserInput>
  }

  export type FlexibilityGoalCreateManyUserInputEnvelope = {
    data: FlexibilityGoalCreateManyUserInput | FlexibilityGoalCreateManyUserInput[]
  }

  export type BodyMetricCreateWithoutUserInput = {
    id?: string
    weight?: number | null
    weightUnit?: string
    bodyFatPercentage?: number | null
    chest?: number | null
    waist?: number | null
    hips?: number | null
    arms?: number | null
    thighs?: number | null
    measurementUnit?: string
    measurementDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type BodyMetricUncheckedCreateWithoutUserInput = {
    id?: string
    weight?: number | null
    weightUnit?: string
    bodyFatPercentage?: number | null
    chest?: number | null
    waist?: number | null
    hips?: number | null
    arms?: number | null
    thighs?: number | null
    measurementUnit?: string
    measurementDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type BodyMetricCreateOrConnectWithoutUserInput = {
    where: BodyMetricWhereUniqueInput
    create: XOR<BodyMetricCreateWithoutUserInput, BodyMetricUncheckedCreateWithoutUserInput>
  }

  export type BodyMetricCreateManyUserInputEnvelope = {
    data: BodyMetricCreateManyUserInput | BodyMetricCreateManyUserInput[]
  }

  export type StrengthWorkoutCreateWithoutUserInput = {
    id?: string
    name?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    sessionIntensityRpe?: number | null
    notes?: string | null
    totalVolume?: number | null
    createdAt?: Date | string
    exercises?: WorkoutExerciseCreateNestedManyWithoutWorkoutInput
  }

  export type StrengthWorkoutUncheckedCreateWithoutUserInput = {
    id?: string
    name?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    sessionIntensityRpe?: number | null
    notes?: string | null
    totalVolume?: number | null
    createdAt?: Date | string
    exercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type StrengthWorkoutCreateOrConnectWithoutUserInput = {
    where: StrengthWorkoutWhereUniqueInput
    create: XOR<StrengthWorkoutCreateWithoutUserInput, StrengthWorkoutUncheckedCreateWithoutUserInput>
  }

  export type StrengthWorkoutCreateManyUserInputEnvelope = {
    data: StrengthWorkoutCreateManyUserInput | StrengthWorkoutCreateManyUserInput[]
  }

  export type PersonalRecordCreateWithoutUserInput = {
    id?: string
    recordType: string
    value: number
    weightUnit?: string
    achievedAt?: Date | string
    workoutId?: string | null
    exercise: ExerciseCreateNestedOneWithoutPersonalRecordsInput
  }

  export type PersonalRecordUncheckedCreateWithoutUserInput = {
    id?: string
    exerciseId: string
    recordType: string
    value: number
    weightUnit?: string
    achievedAt?: Date | string
    workoutId?: string | null
  }

  export type PersonalRecordCreateOrConnectWithoutUserInput = {
    where: PersonalRecordWhereUniqueInput
    create: XOR<PersonalRecordCreateWithoutUserInput, PersonalRecordUncheckedCreateWithoutUserInput>
  }

  export type PersonalRecordCreateManyUserInputEnvelope = {
    data: PersonalRecordCreateManyUserInput | PersonalRecordCreateManyUserInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    notificationType: string
    title: string
    body?: string | null
    actionType?: string | null
    actionData?: string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    clickedAt?: Date | string | null
    deliveryStatus?: string
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    notificationType: string
    title: string
    body?: string | null
    actionType?: string | null
    actionData?: string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    clickedAt?: Date | string | null
    deliveryStatus?: string
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type UserConsentCreateWithoutUserInput = {
    id?: string
    consentType: string
    version: string
    consented: boolean
    consentedAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type UserConsentUncheckedCreateWithoutUserInput = {
    id?: string
    consentType: string
    version: string
    consented: boolean
    consentedAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type UserConsentCreateOrConnectWithoutUserInput = {
    where: UserConsentWhereUniqueInput
    create: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
  }

  export type UserConsentCreateManyUserInputEnvelope = {
    data: UserConsentCreateManyUserInput | UserConsentCreateManyUserInput[]
  }

  export type UserFollowCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    following: UserCreateNestedOneWithoutFollowersInput
  }

  export type UserFollowUncheckedCreateWithoutUserInput = {
    id?: string
    followingUserId: string
    createdAt?: Date | string
  }

  export type UserFollowCreateOrConnectWithoutUserInput = {
    where: UserFollowWhereUniqueInput
    create: XOR<UserFollowCreateWithoutUserInput, UserFollowUncheckedCreateWithoutUserInput>
  }

  export type UserFollowCreateManyUserInputEnvelope = {
    data: UserFollowCreateManyUserInput | UserFollowCreateManyUserInput[]
  }

  export type UserFollowCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFollowingInput
  }

  export type UserFollowUncheckedCreateWithoutFollowingInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserFollowCreateOrConnectWithoutFollowingInput = {
    where: UserFollowWhereUniqueInput
    create: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput>
  }

  export type UserFollowCreateManyFollowingInputEnvelope = {
    data: UserFollowCreateManyFollowingInput | UserFollowCreateManyFollowingInput[]
  }

  export type ProgressVideoCreateWithoutUserInput = {
    id?: string
    videoUrl: string
    uploadedAt?: Date | string
    goal?: FlexibilityGoalCreateNestedOneWithoutProgressVideosInput
  }

  export type ProgressVideoUncheckedCreateWithoutUserInput = {
    id?: string
    goalId?: string | null
    videoUrl: string
    uploadedAt?: Date | string
  }

  export type ProgressVideoCreateOrConnectWithoutUserInput = {
    where: ProgressVideoWhereUniqueInput
    create: XOR<ProgressVideoCreateWithoutUserInput, ProgressVideoUncheckedCreateWithoutUserInput>
  }

  export type ProgressVideoCreateManyUserInputEnvelope = {
    data: ProgressVideoCreateManyUserInput | ProgressVideoCreateManyUserInput[]
  }

  export type DataExportRequestCreateWithoutUserInput = {
    id?: string
    status?: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    downloadUrl?: string | null
    fileSizeBytes?: number | null
  }

  export type DataExportRequestUncheckedCreateWithoutUserInput = {
    id?: string
    status?: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    downloadUrl?: string | null
    fileSizeBytes?: number | null
  }

  export type DataExportRequestCreateOrConnectWithoutUserInput = {
    where: DataExportRequestWhereUniqueInput
    create: XOR<DataExportRequestCreateWithoutUserInput, DataExportRequestUncheckedCreateWithoutUserInput>
  }

  export type DataExportRequestCreateManyUserInputEnvelope = {
    data: DataExportRequestCreateManyUserInput | DataExportRequestCreateManyUserInput[]
  }

  export type DeletionRequestCreateWithoutUserInput = {
    id?: string
    status?: string
    reason?: string | null
    requestedAt?: Date | string
    gracePeriodEndsAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type DeletionRequestUncheckedCreateWithoutUserInput = {
    id?: string
    status?: string
    reason?: string | null
    requestedAt?: Date | string
    gracePeriodEndsAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type DeletionRequestCreateOrConnectWithoutUserInput = {
    where: DeletionRequestWhereUniqueInput
    create: XOR<DeletionRequestCreateWithoutUserInput, DeletionRequestUncheckedCreateWithoutUserInput>
  }

  export type DeletionRequestCreateManyUserInputEnvelope = {
    data: DeletionRequestCreateManyUserInput | DeletionRequestCreateManyUserInput[]
  }

  export type UserOnboardingUpsertWithoutUserInput = {
    update: XOR<UserOnboardingUpdateWithoutUserInput, UserOnboardingUncheckedUpdateWithoutUserInput>
    create: XOR<UserOnboardingCreateWithoutUserInput, UserOnboardingUncheckedCreateWithoutUserInput>
    where?: UserOnboardingWhereInput
  }

  export type UserOnboardingUpdateToOneWithWhereWithoutUserInput = {
    where?: UserOnboardingWhereInput
    data: XOR<UserOnboardingUpdateWithoutUserInput, UserOnboardingUncheckedUpdateWithoutUserInput>
  }

  export type UserOnboardingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    primaryGoal?: NullableStringFieldUpdateOperationsInput | string | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    toeTouchScore?: NullableIntFieldUpdateOperationsInput | number | null
    shoulderReachScore?: NullableIntFieldUpdateOperationsInput | number | null
    hipFlexibilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    overallFlexibilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    flexibilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    workoutDays?: NullableStringFieldUpdateOperationsInput | string | null
    preferredWorkoutTime?: NullableStringFieldUpdateOperationsInput | string | null
    stretchingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOnboardingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skipped?: BoolFieldUpdateOperationsInput | boolean
    primaryGoal?: NullableStringFieldUpdateOperationsInput | string | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    toeTouchScore?: NullableIntFieldUpdateOperationsInput | number | null
    shoulderReachScore?: NullableIntFieldUpdateOperationsInput | number | null
    hipFlexibilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    overallFlexibilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    flexibilityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    workoutDays?: NullableStringFieldUpdateOperationsInput | string | null
    preferredWorkoutTime?: NullableStringFieldUpdateOperationsInput | string | null
    stretchingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    where?: NotificationPreferenceWhereInput
  }

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    stretchReminders?: BoolFieldUpdateOperationsInput | boolean
    workoutReminders?: BoolFieldUpdateOperationsInput | boolean
    streakNotifications?: BoolFieldUpdateOperationsInput | boolean
    goalNotifications?: BoolFieldUpdateOperationsInput | boolean
    socialNotifications?: BoolFieldUpdateOperationsInput | boolean
    recoverySuggestions?: BoolFieldUpdateOperationsInput | boolean
    inactivityNudges?: BoolFieldUpdateOperationsInput | boolean
    quietHoursEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: StringFieldUpdateOperationsInput | string
    quietHoursEnd?: StringFieldUpdateOperationsInput | string
    maxDailyNotifications?: IntFieldUpdateOperationsInput | number
    stretchReminderTime?: StringFieldUpdateOperationsInput | string
    workoutReminderTime?: StringFieldUpdateOperationsInput | string
    reminderDays?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    stretchReminders?: BoolFieldUpdateOperationsInput | boolean
    workoutReminders?: BoolFieldUpdateOperationsInput | boolean
    streakNotifications?: BoolFieldUpdateOperationsInput | boolean
    goalNotifications?: BoolFieldUpdateOperationsInput | boolean
    socialNotifications?: BoolFieldUpdateOperationsInput | boolean
    recoverySuggestions?: BoolFieldUpdateOperationsInput | boolean
    inactivityNudges?: BoolFieldUpdateOperationsInput | boolean
    quietHoursEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: StringFieldUpdateOperationsInput | string
    quietHoursEnd?: StringFieldUpdateOperationsInput | string
    maxDailyNotifications?: IntFieldUpdateOperationsInput | number
    stretchReminderTime?: StringFieldUpdateOperationsInput | string
    workoutReminderTime?: StringFieldUpdateOperationsInput | string
    reminderDays?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpsertWithoutUserInput = {
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pricePaid?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pricePaid?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTrial?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StretchingRoutineUpsertWithWhereUniqueWithoutUserInput = {
    where: StretchingRoutineWhereUniqueInput
    update: XOR<StretchingRoutineUpdateWithoutUserInput, StretchingRoutineUncheckedUpdateWithoutUserInput>
    create: XOR<StretchingRoutineCreateWithoutUserInput, StretchingRoutineUncheckedCreateWithoutUserInput>
  }

  export type StretchingRoutineUpdateWithWhereUniqueWithoutUserInput = {
    where: StretchingRoutineWhereUniqueInput
    data: XOR<StretchingRoutineUpdateWithoutUserInput, StretchingRoutineUncheckedUpdateWithoutUserInput>
  }

  export type StretchingRoutineUpdateManyWithWhereWithoutUserInput = {
    where: StretchingRoutineScalarWhereInput
    data: XOR<StretchingRoutineUpdateManyMutationInput, StretchingRoutineUncheckedUpdateManyWithoutUserInput>
  }

  export type StretchingRoutineScalarWhereInput = {
    AND?: StretchingRoutineScalarWhereInput | StretchingRoutineScalarWhereInput[]
    OR?: StretchingRoutineScalarWhereInput[]
    NOT?: StretchingRoutineScalarWhereInput | StretchingRoutineScalarWhereInput[]
    id?: StringFilter<"StretchingRoutine"> | string
    userId?: StringNullableFilter<"StretchingRoutine"> | string | null
    name?: StringFilter<"StretchingRoutine"> | string
    description?: StringNullableFilter<"StretchingRoutine"> | string | null
    difficulty?: StringFilter<"StretchingRoutine"> | string
    durationSeconds?: IntFilter<"StretchingRoutine"> | number
    targetAreas?: StringNullableFilter<"StretchingRoutine"> | string | null
    tags?: StringNullableFilter<"StretchingRoutine"> | string | null
    isPublic?: BoolFilter<"StretchingRoutine"> | boolean
    isSystem?: BoolFilter<"StretchingRoutine"> | boolean
    usesCount?: IntFilter<"StretchingRoutine"> | number
    createdAt?: DateTimeFilter<"StretchingRoutine"> | Date | string
    updatedAt?: DateTimeFilter<"StretchingRoutine"> | Date | string
  }

  export type StretchingSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: StretchingSessionWhereUniqueInput
    update: XOR<StretchingSessionUpdateWithoutUserInput, StretchingSessionUncheckedUpdateWithoutUserInput>
    create: XOR<StretchingSessionCreateWithoutUserInput, StretchingSessionUncheckedCreateWithoutUserInput>
  }

  export type StretchingSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: StretchingSessionWhereUniqueInput
    data: XOR<StretchingSessionUpdateWithoutUserInput, StretchingSessionUncheckedUpdateWithoutUserInput>
  }

  export type StretchingSessionUpdateManyWithWhereWithoutUserInput = {
    where: StretchingSessionScalarWhereInput
    data: XOR<StretchingSessionUpdateManyMutationInput, StretchingSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type StretchingSessionScalarWhereInput = {
    AND?: StretchingSessionScalarWhereInput | StretchingSessionScalarWhereInput[]
    OR?: StretchingSessionScalarWhereInput[]
    NOT?: StretchingSessionScalarWhereInput | StretchingSessionScalarWhereInput[]
    id?: StringFilter<"StretchingSession"> | string
    userId?: StringFilter<"StretchingSession"> | string
    routineId?: StringNullableFilter<"StretchingSession"> | string | null
    routineName?: StringNullableFilter<"StretchingSession"> | string | null
    startedAt?: DateTimeFilter<"StretchingSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"StretchingSession"> | Date | string | null
    durationSeconds?: IntNullableFilter<"StretchingSession"> | number | null
    completed?: BoolFilter<"StretchingSession"> | boolean
    linkedWorkoutId?: StringNullableFilter<"StretchingSession"> | string | null
    notes?: StringNullableFilter<"StretchingSession"> | string | null
    createdAt?: DateTimeFilter<"StretchingSession"> | Date | string
  }

  export type FlexibilityGoalUpsertWithWhereUniqueWithoutUserInput = {
    where: FlexibilityGoalWhereUniqueInput
    update: XOR<FlexibilityGoalUpdateWithoutUserInput, FlexibilityGoalUncheckedUpdateWithoutUserInput>
    create: XOR<FlexibilityGoalCreateWithoutUserInput, FlexibilityGoalUncheckedCreateWithoutUserInput>
  }

  export type FlexibilityGoalUpdateWithWhereUniqueWithoutUserInput = {
    where: FlexibilityGoalWhereUniqueInput
    data: XOR<FlexibilityGoalUpdateWithoutUserInput, FlexibilityGoalUncheckedUpdateWithoutUserInput>
  }

  export type FlexibilityGoalUpdateManyWithWhereWithoutUserInput = {
    where: FlexibilityGoalScalarWhereInput
    data: XOR<FlexibilityGoalUpdateManyMutationInput, FlexibilityGoalUncheckedUpdateManyWithoutUserInput>
  }

  export type FlexibilityGoalScalarWhereInput = {
    AND?: FlexibilityGoalScalarWhereInput | FlexibilityGoalScalarWhereInput[]
    OR?: FlexibilityGoalScalarWhereInput[]
    NOT?: FlexibilityGoalScalarWhereInput | FlexibilityGoalScalarWhereInput[]
    id?: StringFilter<"FlexibilityGoal"> | string
    userId?: StringFilter<"FlexibilityGoal"> | string
    goalType?: StringFilter<"FlexibilityGoal"> | string
    description?: StringNullableFilter<"FlexibilityGoal"> | string | null
    targetArea?: StringFilter<"FlexibilityGoal"> | string
    baselineRom?: FloatNullableFilter<"FlexibilityGoal"> | number | null
    targetRom?: FloatNullableFilter<"FlexibilityGoal"> | number | null
    targetDate?: DateTimeNullableFilter<"FlexibilityGoal"> | Date | string | null
    status?: StringFilter<"FlexibilityGoal"> | string
    createdAt?: DateTimeFilter<"FlexibilityGoal"> | Date | string
    updatedAt?: DateTimeFilter<"FlexibilityGoal"> | Date | string
  }

  export type BodyMetricUpsertWithWhereUniqueWithoutUserInput = {
    where: BodyMetricWhereUniqueInput
    update: XOR<BodyMetricUpdateWithoutUserInput, BodyMetricUncheckedUpdateWithoutUserInput>
    create: XOR<BodyMetricCreateWithoutUserInput, BodyMetricUncheckedCreateWithoutUserInput>
  }

  export type BodyMetricUpdateWithWhereUniqueWithoutUserInput = {
    where: BodyMetricWhereUniqueInput
    data: XOR<BodyMetricUpdateWithoutUserInput, BodyMetricUncheckedUpdateWithoutUserInput>
  }

  export type BodyMetricUpdateManyWithWhereWithoutUserInput = {
    where: BodyMetricScalarWhereInput
    data: XOR<BodyMetricUpdateManyMutationInput, BodyMetricUncheckedUpdateManyWithoutUserInput>
  }

  export type BodyMetricScalarWhereInput = {
    AND?: BodyMetricScalarWhereInput | BodyMetricScalarWhereInput[]
    OR?: BodyMetricScalarWhereInput[]
    NOT?: BodyMetricScalarWhereInput | BodyMetricScalarWhereInput[]
    id?: StringFilter<"BodyMetric"> | string
    userId?: StringFilter<"BodyMetric"> | string
    weight?: FloatNullableFilter<"BodyMetric"> | number | null
    weightUnit?: StringFilter<"BodyMetric"> | string
    bodyFatPercentage?: FloatNullableFilter<"BodyMetric"> | number | null
    chest?: FloatNullableFilter<"BodyMetric"> | number | null
    waist?: FloatNullableFilter<"BodyMetric"> | number | null
    hips?: FloatNullableFilter<"BodyMetric"> | number | null
    arms?: FloatNullableFilter<"BodyMetric"> | number | null
    thighs?: FloatNullableFilter<"BodyMetric"> | number | null
    measurementUnit?: StringFilter<"BodyMetric"> | string
    measurementDate?: DateTimeFilter<"BodyMetric"> | Date | string
    notes?: StringNullableFilter<"BodyMetric"> | string | null
    createdAt?: DateTimeFilter<"BodyMetric"> | Date | string
  }

  export type StrengthWorkoutUpsertWithWhereUniqueWithoutUserInput = {
    where: StrengthWorkoutWhereUniqueInput
    update: XOR<StrengthWorkoutUpdateWithoutUserInput, StrengthWorkoutUncheckedUpdateWithoutUserInput>
    create: XOR<StrengthWorkoutCreateWithoutUserInput, StrengthWorkoutUncheckedCreateWithoutUserInput>
  }

  export type StrengthWorkoutUpdateWithWhereUniqueWithoutUserInput = {
    where: StrengthWorkoutWhereUniqueInput
    data: XOR<StrengthWorkoutUpdateWithoutUserInput, StrengthWorkoutUncheckedUpdateWithoutUserInput>
  }

  export type StrengthWorkoutUpdateManyWithWhereWithoutUserInput = {
    where: StrengthWorkoutScalarWhereInput
    data: XOR<StrengthWorkoutUpdateManyMutationInput, StrengthWorkoutUncheckedUpdateManyWithoutUserInput>
  }

  export type StrengthWorkoutScalarWhereInput = {
    AND?: StrengthWorkoutScalarWhereInput | StrengthWorkoutScalarWhereInput[]
    OR?: StrengthWorkoutScalarWhereInput[]
    NOT?: StrengthWorkoutScalarWhereInput | StrengthWorkoutScalarWhereInput[]
    id?: StringFilter<"StrengthWorkout"> | string
    userId?: StringFilter<"StrengthWorkout"> | string
    name?: StringNullableFilter<"StrengthWorkout"> | string | null
    startedAt?: DateTimeFilter<"StrengthWorkout"> | Date | string
    completedAt?: DateTimeNullableFilter<"StrengthWorkout"> | Date | string | null
    durationSeconds?: IntNullableFilter<"StrengthWorkout"> | number | null
    sessionIntensityRpe?: IntNullableFilter<"StrengthWorkout"> | number | null
    notes?: StringNullableFilter<"StrengthWorkout"> | string | null
    totalVolume?: FloatNullableFilter<"StrengthWorkout"> | number | null
    createdAt?: DateTimeFilter<"StrengthWorkout"> | Date | string
  }

  export type PersonalRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: PersonalRecordWhereUniqueInput
    update: XOR<PersonalRecordUpdateWithoutUserInput, PersonalRecordUncheckedUpdateWithoutUserInput>
    create: XOR<PersonalRecordCreateWithoutUserInput, PersonalRecordUncheckedCreateWithoutUserInput>
  }

  export type PersonalRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: PersonalRecordWhereUniqueInput
    data: XOR<PersonalRecordUpdateWithoutUserInput, PersonalRecordUncheckedUpdateWithoutUserInput>
  }

  export type PersonalRecordUpdateManyWithWhereWithoutUserInput = {
    where: PersonalRecordScalarWhereInput
    data: XOR<PersonalRecordUpdateManyMutationInput, PersonalRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type PersonalRecordScalarWhereInput = {
    AND?: PersonalRecordScalarWhereInput | PersonalRecordScalarWhereInput[]
    OR?: PersonalRecordScalarWhereInput[]
    NOT?: PersonalRecordScalarWhereInput | PersonalRecordScalarWhereInput[]
    id?: StringFilter<"PersonalRecord"> | string
    userId?: StringFilter<"PersonalRecord"> | string
    exerciseId?: StringFilter<"PersonalRecord"> | string
    recordType?: StringFilter<"PersonalRecord"> | string
    value?: FloatFilter<"PersonalRecord"> | number
    weightUnit?: StringFilter<"PersonalRecord"> | string
    achievedAt?: DateTimeFilter<"PersonalRecord"> | Date | string
    workoutId?: StringNullableFilter<"PersonalRecord"> | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    notificationType?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringNullableFilter<"Notification"> | string | null
    actionType?: StringNullableFilter<"Notification"> | string | null
    actionData?: StringNullableFilter<"Notification"> | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    clickedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    deliveryStatus?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserConsentUpsertWithWhereUniqueWithoutUserInput = {
    where: UserConsentWhereUniqueInput
    update: XOR<UserConsentUpdateWithoutUserInput, UserConsentUncheckedUpdateWithoutUserInput>
    create: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
  }

  export type UserConsentUpdateWithWhereUniqueWithoutUserInput = {
    where: UserConsentWhereUniqueInput
    data: XOR<UserConsentUpdateWithoutUserInput, UserConsentUncheckedUpdateWithoutUserInput>
  }

  export type UserConsentUpdateManyWithWhereWithoutUserInput = {
    where: UserConsentScalarWhereInput
    data: XOR<UserConsentUpdateManyMutationInput, UserConsentUncheckedUpdateManyWithoutUserInput>
  }

  export type UserConsentScalarWhereInput = {
    AND?: UserConsentScalarWhereInput | UserConsentScalarWhereInput[]
    OR?: UserConsentScalarWhereInput[]
    NOT?: UserConsentScalarWhereInput | UserConsentScalarWhereInput[]
    id?: StringFilter<"UserConsent"> | string
    userId?: StringFilter<"UserConsent"> | string
    consentType?: StringFilter<"UserConsent"> | string
    version?: StringFilter<"UserConsent"> | string
    consented?: BoolFilter<"UserConsent"> | boolean
    consentedAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    withdrawnAt?: DateTimeNullableFilter<"UserConsent"> | Date | string | null
    ipAddress?: StringNullableFilter<"UserConsent"> | string | null
    userAgent?: StringNullableFilter<"UserConsent"> | string | null
    createdAt?: DateTimeFilter<"UserConsent"> | Date | string
  }

  export type UserFollowUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFollowWhereUniqueInput
    update: XOR<UserFollowUpdateWithoutUserInput, UserFollowUncheckedUpdateWithoutUserInput>
    create: XOR<UserFollowCreateWithoutUserInput, UserFollowUncheckedCreateWithoutUserInput>
  }

  export type UserFollowUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFollowWhereUniqueInput
    data: XOR<UserFollowUpdateWithoutUserInput, UserFollowUncheckedUpdateWithoutUserInput>
  }

  export type UserFollowUpdateManyWithWhereWithoutUserInput = {
    where: UserFollowScalarWhereInput
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFollowScalarWhereInput = {
    AND?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
    OR?: UserFollowScalarWhereInput[]
    NOT?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
    id?: StringFilter<"UserFollow"> | string
    userId?: StringFilter<"UserFollow"> | string
    followingUserId?: StringFilter<"UserFollow"> | string
    createdAt?: DateTimeFilter<"UserFollow"> | Date | string
  }

  export type UserFollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: UserFollowWhereUniqueInput
    update: XOR<UserFollowUpdateWithoutFollowingInput, UserFollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserFollowCreateWithoutFollowingInput, UserFollowUncheckedCreateWithoutFollowingInput>
  }

  export type UserFollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: UserFollowWhereUniqueInput
    data: XOR<UserFollowUpdateWithoutFollowingInput, UserFollowUncheckedUpdateWithoutFollowingInput>
  }

  export type UserFollowUpdateManyWithWhereWithoutFollowingInput = {
    where: UserFollowScalarWhereInput
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type ProgressVideoUpsertWithWhereUniqueWithoutUserInput = {
    where: ProgressVideoWhereUniqueInput
    update: XOR<ProgressVideoUpdateWithoutUserInput, ProgressVideoUncheckedUpdateWithoutUserInput>
    create: XOR<ProgressVideoCreateWithoutUserInput, ProgressVideoUncheckedCreateWithoutUserInput>
  }

  export type ProgressVideoUpdateWithWhereUniqueWithoutUserInput = {
    where: ProgressVideoWhereUniqueInput
    data: XOR<ProgressVideoUpdateWithoutUserInput, ProgressVideoUncheckedUpdateWithoutUserInput>
  }

  export type ProgressVideoUpdateManyWithWhereWithoutUserInput = {
    where: ProgressVideoScalarWhereInput
    data: XOR<ProgressVideoUpdateManyMutationInput, ProgressVideoUncheckedUpdateManyWithoutUserInput>
  }

  export type ProgressVideoScalarWhereInput = {
    AND?: ProgressVideoScalarWhereInput | ProgressVideoScalarWhereInput[]
    OR?: ProgressVideoScalarWhereInput[]
    NOT?: ProgressVideoScalarWhereInput | ProgressVideoScalarWhereInput[]
    id?: StringFilter<"ProgressVideo"> | string
    userId?: StringFilter<"ProgressVideo"> | string
    goalId?: StringNullableFilter<"ProgressVideo"> | string | null
    videoUrl?: StringFilter<"ProgressVideo"> | string
    uploadedAt?: DateTimeFilter<"ProgressVideo"> | Date | string
  }

  export type DataExportRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: DataExportRequestWhereUniqueInput
    update: XOR<DataExportRequestUpdateWithoutUserInput, DataExportRequestUncheckedUpdateWithoutUserInput>
    create: XOR<DataExportRequestCreateWithoutUserInput, DataExportRequestUncheckedCreateWithoutUserInput>
  }

  export type DataExportRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: DataExportRequestWhereUniqueInput
    data: XOR<DataExportRequestUpdateWithoutUserInput, DataExportRequestUncheckedUpdateWithoutUserInput>
  }

  export type DataExportRequestUpdateManyWithWhereWithoutUserInput = {
    where: DataExportRequestScalarWhereInput
    data: XOR<DataExportRequestUpdateManyMutationInput, DataExportRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type DataExportRequestScalarWhereInput = {
    AND?: DataExportRequestScalarWhereInput | DataExportRequestScalarWhereInput[]
    OR?: DataExportRequestScalarWhereInput[]
    NOT?: DataExportRequestScalarWhereInput | DataExportRequestScalarWhereInput[]
    id?: StringFilter<"DataExportRequest"> | string
    userId?: StringFilter<"DataExportRequest"> | string
    status?: StringFilter<"DataExportRequest"> | string
    requestedAt?: DateTimeFilter<"DataExportRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"DataExportRequest"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"DataExportRequest"> | Date | string | null
    downloadUrl?: StringNullableFilter<"DataExportRequest"> | string | null
    fileSizeBytes?: IntNullableFilter<"DataExportRequest"> | number | null
  }

  export type DeletionRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: DeletionRequestWhereUniqueInput
    update: XOR<DeletionRequestUpdateWithoutUserInput, DeletionRequestUncheckedUpdateWithoutUserInput>
    create: XOR<DeletionRequestCreateWithoutUserInput, DeletionRequestUncheckedCreateWithoutUserInput>
  }

  export type DeletionRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: DeletionRequestWhereUniqueInput
    data: XOR<DeletionRequestUpdateWithoutUserInput, DeletionRequestUncheckedUpdateWithoutUserInput>
  }

  export type DeletionRequestUpdateManyWithWhereWithoutUserInput = {
    where: DeletionRequestScalarWhereInput
    data: XOR<DeletionRequestUpdateManyMutationInput, DeletionRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type DeletionRequestScalarWhereInput = {
    AND?: DeletionRequestScalarWhereInput | DeletionRequestScalarWhereInput[]
    OR?: DeletionRequestScalarWhereInput[]
    NOT?: DeletionRequestScalarWhereInput | DeletionRequestScalarWhereInput[]
    id?: StringFilter<"DeletionRequest"> | string
    userId?: StringFilter<"DeletionRequest"> | string
    status?: StringFilter<"DeletionRequest"> | string
    reason?: StringNullableFilter<"DeletionRequest"> | string | null
    requestedAt?: DateTimeFilter<"DeletionRequest"> | Date | string
    gracePeriodEndsAt?: DateTimeNullableFilter<"DeletionRequest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeletionRequest"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"DeletionRequest"> | Date | string | null
  }

  export type UserCreateWithoutOnboardingInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOnboardingInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOnboardingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOnboardingInput, UserUncheckedCreateWithoutOnboardingInput>
  }

  export type UserUpsertWithoutOnboardingInput = {
    update: XOR<UserUpdateWithoutOnboardingInput, UserUncheckedUpdateWithoutOnboardingInput>
    create: XOR<UserCreateWithoutOnboardingInput, UserUncheckedCreateWithoutOnboardingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOnboardingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOnboardingInput, UserUncheckedUpdateWithoutOnboardingInput>
  }

  export type UserUpdateWithoutOnboardingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOnboardingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserCreateWithoutFollowersInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoutineStretchCreateWithoutStretchInput = {
    id?: string
    positionOrder: number
    customDurationSeconds?: number | null
    routine: StretchingRoutineCreateNestedOneWithoutStretchesInput
  }

  export type RoutineStretchUncheckedCreateWithoutStretchInput = {
    id?: string
    routineId: string
    positionOrder: number
    customDurationSeconds?: number | null
  }

  export type RoutineStretchCreateOrConnectWithoutStretchInput = {
    where: RoutineStretchWhereUniqueInput
    create: XOR<RoutineStretchCreateWithoutStretchInput, RoutineStretchUncheckedCreateWithoutStretchInput>
  }

  export type RoutineStretchCreateManyStretchInputEnvelope = {
    data: RoutineStretchCreateManyStretchInput | RoutineStretchCreateManyStretchInput[]
  }

  export type SessionStretchCreateWithoutStretchInput = {
    id?: string
    heldDurationSeconds: number
    feltTight?: boolean
    positionInRoutine: number
    completedAt?: Date | string
    session: StretchingSessionCreateNestedOneWithoutStretchesInput
  }

  export type SessionStretchUncheckedCreateWithoutStretchInput = {
    id?: string
    sessionId: string
    heldDurationSeconds: number
    feltTight?: boolean
    positionInRoutine: number
    completedAt?: Date | string
  }

  export type SessionStretchCreateOrConnectWithoutStretchInput = {
    where: SessionStretchWhereUniqueInput
    create: XOR<SessionStretchCreateWithoutStretchInput, SessionStretchUncheckedCreateWithoutStretchInput>
  }

  export type SessionStretchCreateManyStretchInputEnvelope = {
    data: SessionStretchCreateManyStretchInput | SessionStretchCreateManyStretchInput[]
  }

  export type RoutineStretchUpsertWithWhereUniqueWithoutStretchInput = {
    where: RoutineStretchWhereUniqueInput
    update: XOR<RoutineStretchUpdateWithoutStretchInput, RoutineStretchUncheckedUpdateWithoutStretchInput>
    create: XOR<RoutineStretchCreateWithoutStretchInput, RoutineStretchUncheckedCreateWithoutStretchInput>
  }

  export type RoutineStretchUpdateWithWhereUniqueWithoutStretchInput = {
    where: RoutineStretchWhereUniqueInput
    data: XOR<RoutineStretchUpdateWithoutStretchInput, RoutineStretchUncheckedUpdateWithoutStretchInput>
  }

  export type RoutineStretchUpdateManyWithWhereWithoutStretchInput = {
    where: RoutineStretchScalarWhereInput
    data: XOR<RoutineStretchUpdateManyMutationInput, RoutineStretchUncheckedUpdateManyWithoutStretchInput>
  }

  export type RoutineStretchScalarWhereInput = {
    AND?: RoutineStretchScalarWhereInput | RoutineStretchScalarWhereInput[]
    OR?: RoutineStretchScalarWhereInput[]
    NOT?: RoutineStretchScalarWhereInput | RoutineStretchScalarWhereInput[]
    id?: StringFilter<"RoutineStretch"> | string
    routineId?: StringFilter<"RoutineStretch"> | string
    stretchId?: StringFilter<"RoutineStretch"> | string
    positionOrder?: IntFilter<"RoutineStretch"> | number
    customDurationSeconds?: IntNullableFilter<"RoutineStretch"> | number | null
  }

  export type SessionStretchUpsertWithWhereUniqueWithoutStretchInput = {
    where: SessionStretchWhereUniqueInput
    update: XOR<SessionStretchUpdateWithoutStretchInput, SessionStretchUncheckedUpdateWithoutStretchInput>
    create: XOR<SessionStretchCreateWithoutStretchInput, SessionStretchUncheckedCreateWithoutStretchInput>
  }

  export type SessionStretchUpdateWithWhereUniqueWithoutStretchInput = {
    where: SessionStretchWhereUniqueInput
    data: XOR<SessionStretchUpdateWithoutStretchInput, SessionStretchUncheckedUpdateWithoutStretchInput>
  }

  export type SessionStretchUpdateManyWithWhereWithoutStretchInput = {
    where: SessionStretchScalarWhereInput
    data: XOR<SessionStretchUpdateManyMutationInput, SessionStretchUncheckedUpdateManyWithoutStretchInput>
  }

  export type SessionStretchScalarWhereInput = {
    AND?: SessionStretchScalarWhereInput | SessionStretchScalarWhereInput[]
    OR?: SessionStretchScalarWhereInput[]
    NOT?: SessionStretchScalarWhereInput | SessionStretchScalarWhereInput[]
    id?: StringFilter<"SessionStretch"> | string
    sessionId?: StringFilter<"SessionStretch"> | string
    stretchId?: StringFilter<"SessionStretch"> | string
    heldDurationSeconds?: IntFilter<"SessionStretch"> | number
    feltTight?: BoolFilter<"SessionStretch"> | boolean
    positionInRoutine?: IntFilter<"SessionStretch"> | number
    completedAt?: DateTimeFilter<"SessionStretch"> | Date | string
  }

  export type UserCreateWithoutStretchingRoutinesInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStretchingRoutinesInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStretchingRoutinesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStretchingRoutinesInput, UserUncheckedCreateWithoutStretchingRoutinesInput>
  }

  export type RoutineStretchCreateWithoutRoutineInput = {
    id?: string
    positionOrder: number
    customDurationSeconds?: number | null
    stretch: StretchCreateNestedOneWithoutRoutineStretchesInput
  }

  export type RoutineStretchUncheckedCreateWithoutRoutineInput = {
    id?: string
    stretchId: string
    positionOrder: number
    customDurationSeconds?: number | null
  }

  export type RoutineStretchCreateOrConnectWithoutRoutineInput = {
    where: RoutineStretchWhereUniqueInput
    create: XOR<RoutineStretchCreateWithoutRoutineInput, RoutineStretchUncheckedCreateWithoutRoutineInput>
  }

  export type RoutineStretchCreateManyRoutineInputEnvelope = {
    data: RoutineStretchCreateManyRoutineInput | RoutineStretchCreateManyRoutineInput[]
  }

  export type StretchingSessionCreateWithoutRoutineInput = {
    id?: string
    routineName?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    completed?: boolean
    linkedWorkoutId?: string | null
    notes?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStretchingSessionsInput
    stretches?: SessionStretchCreateNestedManyWithoutSessionInput
  }

  export type StretchingSessionUncheckedCreateWithoutRoutineInput = {
    id?: string
    userId: string
    routineName?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    completed?: boolean
    linkedWorkoutId?: string | null
    notes?: string | null
    createdAt?: Date | string
    stretches?: SessionStretchUncheckedCreateNestedManyWithoutSessionInput
  }

  export type StretchingSessionCreateOrConnectWithoutRoutineInput = {
    where: StretchingSessionWhereUniqueInput
    create: XOR<StretchingSessionCreateWithoutRoutineInput, StretchingSessionUncheckedCreateWithoutRoutineInput>
  }

  export type StretchingSessionCreateManyRoutineInputEnvelope = {
    data: StretchingSessionCreateManyRoutineInput | StretchingSessionCreateManyRoutineInput[]
  }

  export type UserUpsertWithoutStretchingRoutinesInput = {
    update: XOR<UserUpdateWithoutStretchingRoutinesInput, UserUncheckedUpdateWithoutStretchingRoutinesInput>
    create: XOR<UserCreateWithoutStretchingRoutinesInput, UserUncheckedCreateWithoutStretchingRoutinesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStretchingRoutinesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStretchingRoutinesInput, UserUncheckedUpdateWithoutStretchingRoutinesInput>
  }

  export type UserUpdateWithoutStretchingRoutinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStretchingRoutinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoutineStretchUpsertWithWhereUniqueWithoutRoutineInput = {
    where: RoutineStretchWhereUniqueInput
    update: XOR<RoutineStretchUpdateWithoutRoutineInput, RoutineStretchUncheckedUpdateWithoutRoutineInput>
    create: XOR<RoutineStretchCreateWithoutRoutineInput, RoutineStretchUncheckedCreateWithoutRoutineInput>
  }

  export type RoutineStretchUpdateWithWhereUniqueWithoutRoutineInput = {
    where: RoutineStretchWhereUniqueInput
    data: XOR<RoutineStretchUpdateWithoutRoutineInput, RoutineStretchUncheckedUpdateWithoutRoutineInput>
  }

  export type RoutineStretchUpdateManyWithWhereWithoutRoutineInput = {
    where: RoutineStretchScalarWhereInput
    data: XOR<RoutineStretchUpdateManyMutationInput, RoutineStretchUncheckedUpdateManyWithoutRoutineInput>
  }

  export type StretchingSessionUpsertWithWhereUniqueWithoutRoutineInput = {
    where: StretchingSessionWhereUniqueInput
    update: XOR<StretchingSessionUpdateWithoutRoutineInput, StretchingSessionUncheckedUpdateWithoutRoutineInput>
    create: XOR<StretchingSessionCreateWithoutRoutineInput, StretchingSessionUncheckedCreateWithoutRoutineInput>
  }

  export type StretchingSessionUpdateWithWhereUniqueWithoutRoutineInput = {
    where: StretchingSessionWhereUniqueInput
    data: XOR<StretchingSessionUpdateWithoutRoutineInput, StretchingSessionUncheckedUpdateWithoutRoutineInput>
  }

  export type StretchingSessionUpdateManyWithWhereWithoutRoutineInput = {
    where: StretchingSessionScalarWhereInput
    data: XOR<StretchingSessionUpdateManyMutationInput, StretchingSessionUncheckedUpdateManyWithoutRoutineInput>
  }

  export type StretchingRoutineCreateWithoutStretchesInput = {
    id?: string
    name: string
    description?: string | null
    difficulty?: string
    durationSeconds: number
    targetAreas?: string | null
    tags?: string | null
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStretchingRoutinesInput
    sessions?: StretchingSessionCreateNestedManyWithoutRoutineInput
  }

  export type StretchingRoutineUncheckedCreateWithoutStretchesInput = {
    id?: string
    userId?: string | null
    name: string
    description?: string | null
    difficulty?: string
    durationSeconds: number
    targetAreas?: string | null
    tags?: string | null
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: StretchingSessionUncheckedCreateNestedManyWithoutRoutineInput
  }

  export type StretchingRoutineCreateOrConnectWithoutStretchesInput = {
    where: StretchingRoutineWhereUniqueInput
    create: XOR<StretchingRoutineCreateWithoutStretchesInput, StretchingRoutineUncheckedCreateWithoutStretchesInput>
  }

  export type StretchCreateWithoutRoutineStretchesInput = {
    id?: string
    name: string
    description?: string | null
    durationSeconds: number
    videoUrl?: string | null
    thumbnailUrl?: string | null
    animationUrl?: string | null
    difficulty?: string
    primaryMuscles: string
    secondaryMuscles?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    equipment?: string | null
    tags?: string | null
    createdAt?: Date | string
    sessionStretches?: SessionStretchCreateNestedManyWithoutStretchInput
  }

  export type StretchUncheckedCreateWithoutRoutineStretchesInput = {
    id?: string
    name: string
    description?: string | null
    durationSeconds: number
    videoUrl?: string | null
    thumbnailUrl?: string | null
    animationUrl?: string | null
    difficulty?: string
    primaryMuscles: string
    secondaryMuscles?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    equipment?: string | null
    tags?: string | null
    createdAt?: Date | string
    sessionStretches?: SessionStretchUncheckedCreateNestedManyWithoutStretchInput
  }

  export type StretchCreateOrConnectWithoutRoutineStretchesInput = {
    where: StretchWhereUniqueInput
    create: XOR<StretchCreateWithoutRoutineStretchesInput, StretchUncheckedCreateWithoutRoutineStretchesInput>
  }

  export type StretchingRoutineUpsertWithoutStretchesInput = {
    update: XOR<StretchingRoutineUpdateWithoutStretchesInput, StretchingRoutineUncheckedUpdateWithoutStretchesInput>
    create: XOR<StretchingRoutineCreateWithoutStretchesInput, StretchingRoutineUncheckedCreateWithoutStretchesInput>
    where?: StretchingRoutineWhereInput
  }

  export type StretchingRoutineUpdateToOneWithWhereWithoutStretchesInput = {
    where?: StretchingRoutineWhereInput
    data: XOR<StretchingRoutineUpdateWithoutStretchesInput, StretchingRoutineUncheckedUpdateWithoutStretchesInput>
  }

  export type StretchingRoutineUpdateWithoutStretchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    targetAreas?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    usesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStretchingRoutinesNestedInput
    sessions?: StretchingSessionUpdateManyWithoutRoutineNestedInput
  }

  export type StretchingRoutineUncheckedUpdateWithoutStretchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    targetAreas?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    usesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: StretchingSessionUncheckedUpdateManyWithoutRoutineNestedInput
  }

  export type StretchUpsertWithoutRoutineStretchesInput = {
    update: XOR<StretchUpdateWithoutRoutineStretchesInput, StretchUncheckedUpdateWithoutRoutineStretchesInput>
    create: XOR<StretchCreateWithoutRoutineStretchesInput, StretchUncheckedCreateWithoutRoutineStretchesInput>
    where?: StretchWhereInput
  }

  export type StretchUpdateToOneWithWhereWithoutRoutineStretchesInput = {
    where?: StretchWhereInput
    data: XOR<StretchUpdateWithoutRoutineStretchesInput, StretchUncheckedUpdateWithoutRoutineStretchesInput>
  }

  export type StretchUpdateWithoutRoutineStretchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionStretches?: SessionStretchUpdateManyWithoutStretchNestedInput
  }

  export type StretchUncheckedUpdateWithoutRoutineStretchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionStretches?: SessionStretchUncheckedUpdateManyWithoutStretchNestedInput
  }

  export type UserCreateWithoutStretchingSessionsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStretchingSessionsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStretchingSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStretchingSessionsInput, UserUncheckedCreateWithoutStretchingSessionsInput>
  }

  export type StretchingRoutineCreateWithoutSessionsInput = {
    id?: string
    name: string
    description?: string | null
    difficulty?: string
    durationSeconds: number
    targetAreas?: string | null
    tags?: string | null
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStretchingRoutinesInput
    stretches?: RoutineStretchCreateNestedManyWithoutRoutineInput
  }

  export type StretchingRoutineUncheckedCreateWithoutSessionsInput = {
    id?: string
    userId?: string | null
    name: string
    description?: string | null
    difficulty?: string
    durationSeconds: number
    targetAreas?: string | null
    tags?: string | null
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stretches?: RoutineStretchUncheckedCreateNestedManyWithoutRoutineInput
  }

  export type StretchingRoutineCreateOrConnectWithoutSessionsInput = {
    where: StretchingRoutineWhereUniqueInput
    create: XOR<StretchingRoutineCreateWithoutSessionsInput, StretchingRoutineUncheckedCreateWithoutSessionsInput>
  }

  export type SessionStretchCreateWithoutSessionInput = {
    id?: string
    heldDurationSeconds: number
    feltTight?: boolean
    positionInRoutine: number
    completedAt?: Date | string
    stretch: StretchCreateNestedOneWithoutSessionStretchesInput
  }

  export type SessionStretchUncheckedCreateWithoutSessionInput = {
    id?: string
    stretchId: string
    heldDurationSeconds: number
    feltTight?: boolean
    positionInRoutine: number
    completedAt?: Date | string
  }

  export type SessionStretchCreateOrConnectWithoutSessionInput = {
    where: SessionStretchWhereUniqueInput
    create: XOR<SessionStretchCreateWithoutSessionInput, SessionStretchUncheckedCreateWithoutSessionInput>
  }

  export type SessionStretchCreateManySessionInputEnvelope = {
    data: SessionStretchCreateManySessionInput | SessionStretchCreateManySessionInput[]
  }

  export type UserUpsertWithoutStretchingSessionsInput = {
    update: XOR<UserUpdateWithoutStretchingSessionsInput, UserUncheckedUpdateWithoutStretchingSessionsInput>
    create: XOR<UserCreateWithoutStretchingSessionsInput, UserUncheckedCreateWithoutStretchingSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStretchingSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStretchingSessionsInput, UserUncheckedUpdateWithoutStretchingSessionsInput>
  }

  export type UserUpdateWithoutStretchingSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStretchingSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StretchingRoutineUpsertWithoutSessionsInput = {
    update: XOR<StretchingRoutineUpdateWithoutSessionsInput, StretchingRoutineUncheckedUpdateWithoutSessionsInput>
    create: XOR<StretchingRoutineCreateWithoutSessionsInput, StretchingRoutineUncheckedCreateWithoutSessionsInput>
    where?: StretchingRoutineWhereInput
  }

  export type StretchingRoutineUpdateToOneWithWhereWithoutSessionsInput = {
    where?: StretchingRoutineWhereInput
    data: XOR<StretchingRoutineUpdateWithoutSessionsInput, StretchingRoutineUncheckedUpdateWithoutSessionsInput>
  }

  export type StretchingRoutineUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    targetAreas?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    usesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStretchingRoutinesNestedInput
    stretches?: RoutineStretchUpdateManyWithoutRoutineNestedInput
  }

  export type StretchingRoutineUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    targetAreas?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    usesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stretches?: RoutineStretchUncheckedUpdateManyWithoutRoutineNestedInput
  }

  export type SessionStretchUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionStretchWhereUniqueInput
    update: XOR<SessionStretchUpdateWithoutSessionInput, SessionStretchUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionStretchCreateWithoutSessionInput, SessionStretchUncheckedCreateWithoutSessionInput>
  }

  export type SessionStretchUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionStretchWhereUniqueInput
    data: XOR<SessionStretchUpdateWithoutSessionInput, SessionStretchUncheckedUpdateWithoutSessionInput>
  }

  export type SessionStretchUpdateManyWithWhereWithoutSessionInput = {
    where: SessionStretchScalarWhereInput
    data: XOR<SessionStretchUpdateManyMutationInput, SessionStretchUncheckedUpdateManyWithoutSessionInput>
  }

  export type StretchingSessionCreateWithoutStretchesInput = {
    id?: string
    routineName?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    completed?: boolean
    linkedWorkoutId?: string | null
    notes?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStretchingSessionsInput
    routine?: StretchingRoutineCreateNestedOneWithoutSessionsInput
  }

  export type StretchingSessionUncheckedCreateWithoutStretchesInput = {
    id?: string
    userId: string
    routineId?: string | null
    routineName?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    completed?: boolean
    linkedWorkoutId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type StretchingSessionCreateOrConnectWithoutStretchesInput = {
    where: StretchingSessionWhereUniqueInput
    create: XOR<StretchingSessionCreateWithoutStretchesInput, StretchingSessionUncheckedCreateWithoutStretchesInput>
  }

  export type StretchCreateWithoutSessionStretchesInput = {
    id?: string
    name: string
    description?: string | null
    durationSeconds: number
    videoUrl?: string | null
    thumbnailUrl?: string | null
    animationUrl?: string | null
    difficulty?: string
    primaryMuscles: string
    secondaryMuscles?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    equipment?: string | null
    tags?: string | null
    createdAt?: Date | string
    routineStretches?: RoutineStretchCreateNestedManyWithoutStretchInput
  }

  export type StretchUncheckedCreateWithoutSessionStretchesInput = {
    id?: string
    name: string
    description?: string | null
    durationSeconds: number
    videoUrl?: string | null
    thumbnailUrl?: string | null
    animationUrl?: string | null
    difficulty?: string
    primaryMuscles: string
    secondaryMuscles?: string | null
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    equipment?: string | null
    tags?: string | null
    createdAt?: Date | string
    routineStretches?: RoutineStretchUncheckedCreateNestedManyWithoutStretchInput
  }

  export type StretchCreateOrConnectWithoutSessionStretchesInput = {
    where: StretchWhereUniqueInput
    create: XOR<StretchCreateWithoutSessionStretchesInput, StretchUncheckedCreateWithoutSessionStretchesInput>
  }

  export type StretchingSessionUpsertWithoutStretchesInput = {
    update: XOR<StretchingSessionUpdateWithoutStretchesInput, StretchingSessionUncheckedUpdateWithoutStretchesInput>
    create: XOR<StretchingSessionCreateWithoutStretchesInput, StretchingSessionUncheckedCreateWithoutStretchesInput>
    where?: StretchingSessionWhereInput
  }

  export type StretchingSessionUpdateToOneWithWhereWithoutStretchesInput = {
    where?: StretchingSessionWhereInput
    data: XOR<StretchingSessionUpdateWithoutStretchesInput, StretchingSessionUncheckedUpdateWithoutStretchesInput>
  }

  export type StretchingSessionUpdateWithoutStretchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineName?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    linkedWorkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStretchingSessionsNestedInput
    routine?: StretchingRoutineUpdateOneWithoutSessionsNestedInput
  }

  export type StretchingSessionUncheckedUpdateWithoutStretchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    routineId?: NullableStringFieldUpdateOperationsInput | string | null
    routineName?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    linkedWorkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StretchUpsertWithoutSessionStretchesInput = {
    update: XOR<StretchUpdateWithoutSessionStretchesInput, StretchUncheckedUpdateWithoutSessionStretchesInput>
    create: XOR<StretchCreateWithoutSessionStretchesInput, StretchUncheckedCreateWithoutSessionStretchesInput>
    where?: StretchWhereInput
  }

  export type StretchUpdateToOneWithWhereWithoutSessionStretchesInput = {
    where?: StretchWhereInput
    data: XOR<StretchUpdateWithoutSessionStretchesInput, StretchUncheckedUpdateWithoutSessionStretchesInput>
  }

  export type StretchUpdateWithoutSessionStretchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routineStretches?: RoutineStretchUpdateManyWithoutStretchNestedInput
  }

  export type StretchUncheckedUpdateWithoutSessionStretchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    animationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routineStretches?: RoutineStretchUncheckedUpdateManyWithoutStretchNestedInput
  }

  export type UserCreateWithoutFlexibilityGoalsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFlexibilityGoalsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFlexibilityGoalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFlexibilityGoalsInput, UserUncheckedCreateWithoutFlexibilityGoalsInput>
  }

  export type RomMeasurementCreateWithoutGoalInput = {
    id?: string
    romDegrees: number
    measurementDate?: Date | string
    measurementMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type RomMeasurementUncheckedCreateWithoutGoalInput = {
    id?: string
    romDegrees: number
    measurementDate?: Date | string
    measurementMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type RomMeasurementCreateOrConnectWithoutGoalInput = {
    where: RomMeasurementWhereUniqueInput
    create: XOR<RomMeasurementCreateWithoutGoalInput, RomMeasurementUncheckedCreateWithoutGoalInput>
  }

  export type RomMeasurementCreateManyGoalInputEnvelope = {
    data: RomMeasurementCreateManyGoalInput | RomMeasurementCreateManyGoalInput[]
  }

  export type ProgressVideoCreateWithoutGoalInput = {
    id?: string
    videoUrl: string
    uploadedAt?: Date | string
    user: UserCreateNestedOneWithoutProgressVideosInput
  }

  export type ProgressVideoUncheckedCreateWithoutGoalInput = {
    id?: string
    userId: string
    videoUrl: string
    uploadedAt?: Date | string
  }

  export type ProgressVideoCreateOrConnectWithoutGoalInput = {
    where: ProgressVideoWhereUniqueInput
    create: XOR<ProgressVideoCreateWithoutGoalInput, ProgressVideoUncheckedCreateWithoutGoalInput>
  }

  export type ProgressVideoCreateManyGoalInputEnvelope = {
    data: ProgressVideoCreateManyGoalInput | ProgressVideoCreateManyGoalInput[]
  }

  export type UserUpsertWithoutFlexibilityGoalsInput = {
    update: XOR<UserUpdateWithoutFlexibilityGoalsInput, UserUncheckedUpdateWithoutFlexibilityGoalsInput>
    create: XOR<UserCreateWithoutFlexibilityGoalsInput, UserUncheckedCreateWithoutFlexibilityGoalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFlexibilityGoalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFlexibilityGoalsInput, UserUncheckedUpdateWithoutFlexibilityGoalsInput>
  }

  export type UserUpdateWithoutFlexibilityGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFlexibilityGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RomMeasurementUpsertWithWhereUniqueWithoutGoalInput = {
    where: RomMeasurementWhereUniqueInput
    update: XOR<RomMeasurementUpdateWithoutGoalInput, RomMeasurementUncheckedUpdateWithoutGoalInput>
    create: XOR<RomMeasurementCreateWithoutGoalInput, RomMeasurementUncheckedCreateWithoutGoalInput>
  }

  export type RomMeasurementUpdateWithWhereUniqueWithoutGoalInput = {
    where: RomMeasurementWhereUniqueInput
    data: XOR<RomMeasurementUpdateWithoutGoalInput, RomMeasurementUncheckedUpdateWithoutGoalInput>
  }

  export type RomMeasurementUpdateManyWithWhereWithoutGoalInput = {
    where: RomMeasurementScalarWhereInput
    data: XOR<RomMeasurementUpdateManyMutationInput, RomMeasurementUncheckedUpdateManyWithoutGoalInput>
  }

  export type RomMeasurementScalarWhereInput = {
    AND?: RomMeasurementScalarWhereInput | RomMeasurementScalarWhereInput[]
    OR?: RomMeasurementScalarWhereInput[]
    NOT?: RomMeasurementScalarWhereInput | RomMeasurementScalarWhereInput[]
    id?: StringFilter<"RomMeasurement"> | string
    goalId?: StringFilter<"RomMeasurement"> | string
    romDegrees?: FloatFilter<"RomMeasurement"> | number
    measurementDate?: DateTimeFilter<"RomMeasurement"> | Date | string
    measurementMethod?: StringNullableFilter<"RomMeasurement"> | string | null
    notes?: StringNullableFilter<"RomMeasurement"> | string | null
    createdAt?: DateTimeFilter<"RomMeasurement"> | Date | string
  }

  export type ProgressVideoUpsertWithWhereUniqueWithoutGoalInput = {
    where: ProgressVideoWhereUniqueInput
    update: XOR<ProgressVideoUpdateWithoutGoalInput, ProgressVideoUncheckedUpdateWithoutGoalInput>
    create: XOR<ProgressVideoCreateWithoutGoalInput, ProgressVideoUncheckedCreateWithoutGoalInput>
  }

  export type ProgressVideoUpdateWithWhereUniqueWithoutGoalInput = {
    where: ProgressVideoWhereUniqueInput
    data: XOR<ProgressVideoUpdateWithoutGoalInput, ProgressVideoUncheckedUpdateWithoutGoalInput>
  }

  export type ProgressVideoUpdateManyWithWhereWithoutGoalInput = {
    where: ProgressVideoScalarWhereInput
    data: XOR<ProgressVideoUpdateManyMutationInput, ProgressVideoUncheckedUpdateManyWithoutGoalInput>
  }

  export type FlexibilityGoalCreateWithoutMeasurementsInput = {
    id?: string
    goalType: string
    description?: string | null
    targetArea: string
    baselineRom?: number | null
    targetRom?: number | null
    targetDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFlexibilityGoalsInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutGoalInput
  }

  export type FlexibilityGoalUncheckedCreateWithoutMeasurementsInput = {
    id?: string
    userId: string
    goalType: string
    description?: string | null
    targetArea: string
    baselineRom?: number | null
    targetRom?: number | null
    targetDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutGoalInput
  }

  export type FlexibilityGoalCreateOrConnectWithoutMeasurementsInput = {
    where: FlexibilityGoalWhereUniqueInput
    create: XOR<FlexibilityGoalCreateWithoutMeasurementsInput, FlexibilityGoalUncheckedCreateWithoutMeasurementsInput>
  }

  export type FlexibilityGoalUpsertWithoutMeasurementsInput = {
    update: XOR<FlexibilityGoalUpdateWithoutMeasurementsInput, FlexibilityGoalUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<FlexibilityGoalCreateWithoutMeasurementsInput, FlexibilityGoalUncheckedCreateWithoutMeasurementsInput>
    where?: FlexibilityGoalWhereInput
  }

  export type FlexibilityGoalUpdateToOneWithWhereWithoutMeasurementsInput = {
    where?: FlexibilityGoalWhereInput
    data: XOR<FlexibilityGoalUpdateWithoutMeasurementsInput, FlexibilityGoalUncheckedUpdateWithoutMeasurementsInput>
  }

  export type FlexibilityGoalUpdateWithoutMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetArea?: StringFieldUpdateOperationsInput | string
    baselineRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFlexibilityGoalsNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutGoalNestedInput
  }

  export type FlexibilityGoalUncheckedUpdateWithoutMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetArea?: StringFieldUpdateOperationsInput | string
    baselineRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type UserCreateWithoutProgressVideosInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProgressVideosInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProgressVideosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProgressVideosInput, UserUncheckedCreateWithoutProgressVideosInput>
  }

  export type FlexibilityGoalCreateWithoutProgressVideosInput = {
    id?: string
    goalType: string
    description?: string | null
    targetArea: string
    baselineRom?: number | null
    targetRom?: number | null
    targetDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFlexibilityGoalsInput
    measurements?: RomMeasurementCreateNestedManyWithoutGoalInput
  }

  export type FlexibilityGoalUncheckedCreateWithoutProgressVideosInput = {
    id?: string
    userId: string
    goalType: string
    description?: string | null
    targetArea: string
    baselineRom?: number | null
    targetRom?: number | null
    targetDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    measurements?: RomMeasurementUncheckedCreateNestedManyWithoutGoalInput
  }

  export type FlexibilityGoalCreateOrConnectWithoutProgressVideosInput = {
    where: FlexibilityGoalWhereUniqueInput
    create: XOR<FlexibilityGoalCreateWithoutProgressVideosInput, FlexibilityGoalUncheckedCreateWithoutProgressVideosInput>
  }

  export type UserUpsertWithoutProgressVideosInput = {
    update: XOR<UserUpdateWithoutProgressVideosInput, UserUncheckedUpdateWithoutProgressVideosInput>
    create: XOR<UserCreateWithoutProgressVideosInput, UserUncheckedCreateWithoutProgressVideosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProgressVideosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProgressVideosInput, UserUncheckedUpdateWithoutProgressVideosInput>
  }

  export type UserUpdateWithoutProgressVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProgressVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FlexibilityGoalUpsertWithoutProgressVideosInput = {
    update: XOR<FlexibilityGoalUpdateWithoutProgressVideosInput, FlexibilityGoalUncheckedUpdateWithoutProgressVideosInput>
    create: XOR<FlexibilityGoalCreateWithoutProgressVideosInput, FlexibilityGoalUncheckedCreateWithoutProgressVideosInput>
    where?: FlexibilityGoalWhereInput
  }

  export type FlexibilityGoalUpdateToOneWithWhereWithoutProgressVideosInput = {
    where?: FlexibilityGoalWhereInput
    data: XOR<FlexibilityGoalUpdateWithoutProgressVideosInput, FlexibilityGoalUncheckedUpdateWithoutProgressVideosInput>
  }

  export type FlexibilityGoalUpdateWithoutProgressVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetArea?: StringFieldUpdateOperationsInput | string
    baselineRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFlexibilityGoalsNestedInput
    measurements?: RomMeasurementUpdateManyWithoutGoalNestedInput
  }

  export type FlexibilityGoalUncheckedUpdateWithoutProgressVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetArea?: StringFieldUpdateOperationsInput | string
    baselineRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measurements?: RomMeasurementUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type WorkoutExerciseCreateWithoutExerciseInput = {
    id?: string
    positionOrder: number
    notes?: string | null
    createdAt?: Date | string
    workout: StrengthWorkoutCreateNestedOneWithoutExercisesInput
    sets?: WorkoutSetCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUncheckedCreateWithoutExerciseInput = {
    id?: string
    workoutId: string
    positionOrder: number
    notes?: string | null
    createdAt?: Date | string
    sets?: WorkoutSetUncheckedCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseCreateOrConnectWithoutExerciseInput = {
    where: WorkoutExerciseWhereUniqueInput
    create: XOR<WorkoutExerciseCreateWithoutExerciseInput, WorkoutExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type WorkoutExerciseCreateManyExerciseInputEnvelope = {
    data: WorkoutExerciseCreateManyExerciseInput | WorkoutExerciseCreateManyExerciseInput[]
  }

  export type PersonalRecordCreateWithoutExerciseInput = {
    id?: string
    recordType: string
    value: number
    weightUnit?: string
    achievedAt?: Date | string
    workoutId?: string | null
    user: UserCreateNestedOneWithoutPersonalRecordsInput
  }

  export type PersonalRecordUncheckedCreateWithoutExerciseInput = {
    id?: string
    userId: string
    recordType: string
    value: number
    weightUnit?: string
    achievedAt?: Date | string
    workoutId?: string | null
  }

  export type PersonalRecordCreateOrConnectWithoutExerciseInput = {
    where: PersonalRecordWhereUniqueInput
    create: XOR<PersonalRecordCreateWithoutExerciseInput, PersonalRecordUncheckedCreateWithoutExerciseInput>
  }

  export type PersonalRecordCreateManyExerciseInputEnvelope = {
    data: PersonalRecordCreateManyExerciseInput | PersonalRecordCreateManyExerciseInput[]
  }

  export type WorkoutExerciseUpsertWithWhereUniqueWithoutExerciseInput = {
    where: WorkoutExerciseWhereUniqueInput
    update: XOR<WorkoutExerciseUpdateWithoutExerciseInput, WorkoutExerciseUncheckedUpdateWithoutExerciseInput>
    create: XOR<WorkoutExerciseCreateWithoutExerciseInput, WorkoutExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type WorkoutExerciseUpdateWithWhereUniqueWithoutExerciseInput = {
    where: WorkoutExerciseWhereUniqueInput
    data: XOR<WorkoutExerciseUpdateWithoutExerciseInput, WorkoutExerciseUncheckedUpdateWithoutExerciseInput>
  }

  export type WorkoutExerciseUpdateManyWithWhereWithoutExerciseInput = {
    where: WorkoutExerciseScalarWhereInput
    data: XOR<WorkoutExerciseUpdateManyMutationInput, WorkoutExerciseUncheckedUpdateManyWithoutExerciseInput>
  }

  export type WorkoutExerciseScalarWhereInput = {
    AND?: WorkoutExerciseScalarWhereInput | WorkoutExerciseScalarWhereInput[]
    OR?: WorkoutExerciseScalarWhereInput[]
    NOT?: WorkoutExerciseScalarWhereInput | WorkoutExerciseScalarWhereInput[]
    id?: StringFilter<"WorkoutExercise"> | string
    workoutId?: StringFilter<"WorkoutExercise"> | string
    exerciseId?: StringFilter<"WorkoutExercise"> | string
    positionOrder?: IntFilter<"WorkoutExercise"> | number
    notes?: StringNullableFilter<"WorkoutExercise"> | string | null
    createdAt?: DateTimeFilter<"WorkoutExercise"> | Date | string
  }

  export type PersonalRecordUpsertWithWhereUniqueWithoutExerciseInput = {
    where: PersonalRecordWhereUniqueInput
    update: XOR<PersonalRecordUpdateWithoutExerciseInput, PersonalRecordUncheckedUpdateWithoutExerciseInput>
    create: XOR<PersonalRecordCreateWithoutExerciseInput, PersonalRecordUncheckedCreateWithoutExerciseInput>
  }

  export type PersonalRecordUpdateWithWhereUniqueWithoutExerciseInput = {
    where: PersonalRecordWhereUniqueInput
    data: XOR<PersonalRecordUpdateWithoutExerciseInput, PersonalRecordUncheckedUpdateWithoutExerciseInput>
  }

  export type PersonalRecordUpdateManyWithWhereWithoutExerciseInput = {
    where: PersonalRecordScalarWhereInput
    data: XOR<PersonalRecordUpdateManyMutationInput, PersonalRecordUncheckedUpdateManyWithoutExerciseInput>
  }

  export type UserCreateWithoutStrengthWorkoutsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStrengthWorkoutsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStrengthWorkoutsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStrengthWorkoutsInput, UserUncheckedCreateWithoutStrengthWorkoutsInput>
  }

  export type WorkoutExerciseCreateWithoutWorkoutInput = {
    id?: string
    positionOrder: number
    notes?: string | null
    createdAt?: Date | string
    exercise: ExerciseCreateNestedOneWithoutWorkoutExercisesInput
    sets?: WorkoutSetCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUncheckedCreateWithoutWorkoutInput = {
    id?: string
    exerciseId: string
    positionOrder: number
    notes?: string | null
    createdAt?: Date | string
    sets?: WorkoutSetUncheckedCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseCreateOrConnectWithoutWorkoutInput = {
    where: WorkoutExerciseWhereUniqueInput
    create: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutExerciseCreateManyWorkoutInputEnvelope = {
    data: WorkoutExerciseCreateManyWorkoutInput | WorkoutExerciseCreateManyWorkoutInput[]
  }

  export type UserUpsertWithoutStrengthWorkoutsInput = {
    update: XOR<UserUpdateWithoutStrengthWorkoutsInput, UserUncheckedUpdateWithoutStrengthWorkoutsInput>
    create: XOR<UserCreateWithoutStrengthWorkoutsInput, UserUncheckedCreateWithoutStrengthWorkoutsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStrengthWorkoutsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStrengthWorkoutsInput, UserUncheckedUpdateWithoutStrengthWorkoutsInput>
  }

  export type UserUpdateWithoutStrengthWorkoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStrengthWorkoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutExerciseWhereUniqueInput
    update: XOR<WorkoutExerciseUpdateWithoutWorkoutInput, WorkoutExerciseUncheckedUpdateWithoutWorkoutInput>
    create: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutExerciseWhereUniqueInput
    data: XOR<WorkoutExerciseUpdateWithoutWorkoutInput, WorkoutExerciseUncheckedUpdateWithoutWorkoutInput>
  }

  export type WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput = {
    where: WorkoutExerciseScalarWhereInput
    data: XOR<WorkoutExerciseUpdateManyMutationInput, WorkoutExerciseUncheckedUpdateManyWithoutWorkoutInput>
  }

  export type StrengthWorkoutCreateWithoutExercisesInput = {
    id?: string
    name?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    sessionIntensityRpe?: number | null
    notes?: string | null
    totalVolume?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStrengthWorkoutsInput
  }

  export type StrengthWorkoutUncheckedCreateWithoutExercisesInput = {
    id?: string
    userId: string
    name?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    sessionIntensityRpe?: number | null
    notes?: string | null
    totalVolume?: number | null
    createdAt?: Date | string
  }

  export type StrengthWorkoutCreateOrConnectWithoutExercisesInput = {
    where: StrengthWorkoutWhereUniqueInput
    create: XOR<StrengthWorkoutCreateWithoutExercisesInput, StrengthWorkoutUncheckedCreateWithoutExercisesInput>
  }

  export type ExerciseCreateWithoutWorkoutExercisesInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    equipmentNeeded?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    primaryMuscles: string
    secondaryMuscles?: string | null
    difficulty?: string
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    isCompound?: boolean
    isUnilateral?: boolean
    forceType?: string | null
    mechanic?: string | null
    metValue?: number | null
    is1RMEligible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personalRecords?: PersonalRecordCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutWorkoutExercisesInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    equipmentNeeded?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    primaryMuscles: string
    secondaryMuscles?: string | null
    difficulty?: string
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    isCompound?: boolean
    isUnilateral?: boolean
    forceType?: string | null
    mechanic?: string | null
    metValue?: number | null
    is1RMEligible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutWorkoutExercisesInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutWorkoutExercisesInput, ExerciseUncheckedCreateWithoutWorkoutExercisesInput>
  }

  export type WorkoutSetCreateWithoutWorkoutExerciseInput = {
    id?: string
    setNumber: number
    reps?: number | null
    weight?: number | null
    weightUnit?: string
    setType?: string
    rpe?: number | null
    isPr?: boolean
    completed?: boolean
    restSeconds?: number | null
    durationSeconds?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
  }

  export type WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput = {
    id?: string
    setNumber: number
    reps?: number | null
    weight?: number | null
    weightUnit?: string
    setType?: string
    rpe?: number | null
    isPr?: boolean
    completed?: boolean
    restSeconds?: number | null
    durationSeconds?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
  }

  export type WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput = {
    where: WorkoutSetWhereUniqueInput
    create: XOR<WorkoutSetCreateWithoutWorkoutExerciseInput, WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput>
  }

  export type WorkoutSetCreateManyWorkoutExerciseInputEnvelope = {
    data: WorkoutSetCreateManyWorkoutExerciseInput | WorkoutSetCreateManyWorkoutExerciseInput[]
  }

  export type StrengthWorkoutUpsertWithoutExercisesInput = {
    update: XOR<StrengthWorkoutUpdateWithoutExercisesInput, StrengthWorkoutUncheckedUpdateWithoutExercisesInput>
    create: XOR<StrengthWorkoutCreateWithoutExercisesInput, StrengthWorkoutUncheckedCreateWithoutExercisesInput>
    where?: StrengthWorkoutWhereInput
  }

  export type StrengthWorkoutUpdateToOneWithWhereWithoutExercisesInput = {
    where?: StrengthWorkoutWhereInput
    data: XOR<StrengthWorkoutUpdateWithoutExercisesInput, StrengthWorkoutUncheckedUpdateWithoutExercisesInput>
  }

  export type StrengthWorkoutUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    sessionIntensityRpe?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStrengthWorkoutsNestedInput
  }

  export type StrengthWorkoutUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    sessionIntensityRpe?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUpsertWithoutWorkoutExercisesInput = {
    update: XOR<ExerciseUpdateWithoutWorkoutExercisesInput, ExerciseUncheckedUpdateWithoutWorkoutExercisesInput>
    create: XOR<ExerciseCreateWithoutWorkoutExercisesInput, ExerciseUncheckedCreateWithoutWorkoutExercisesInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutWorkoutExercisesInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutWorkoutExercisesInput, ExerciseUncheckedUpdateWithoutWorkoutExercisesInput>
  }

  export type ExerciseUpdateWithoutWorkoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    equipmentNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompound?: BoolFieldUpdateOperationsInput | boolean
    isUnilateral?: BoolFieldUpdateOperationsInput | boolean
    forceType?: NullableStringFieldUpdateOperationsInput | string | null
    mechanic?: NullableStringFieldUpdateOperationsInput | string | null
    metValue?: NullableFloatFieldUpdateOperationsInput | number | null
    is1RMEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalRecords?: PersonalRecordUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutWorkoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    equipmentNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompound?: BoolFieldUpdateOperationsInput | boolean
    isUnilateral?: BoolFieldUpdateOperationsInput | boolean
    forceType?: NullableStringFieldUpdateOperationsInput | string | null
    mechanic?: NullableStringFieldUpdateOperationsInput | string | null
    metValue?: NullableFloatFieldUpdateOperationsInput | number | null
    is1RMEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type WorkoutSetUpsertWithWhereUniqueWithoutWorkoutExerciseInput = {
    where: WorkoutSetWhereUniqueInput
    update: XOR<WorkoutSetUpdateWithoutWorkoutExerciseInput, WorkoutSetUncheckedUpdateWithoutWorkoutExerciseInput>
    create: XOR<WorkoutSetCreateWithoutWorkoutExerciseInput, WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput>
  }

  export type WorkoutSetUpdateWithWhereUniqueWithoutWorkoutExerciseInput = {
    where: WorkoutSetWhereUniqueInput
    data: XOR<WorkoutSetUpdateWithoutWorkoutExerciseInput, WorkoutSetUncheckedUpdateWithoutWorkoutExerciseInput>
  }

  export type WorkoutSetUpdateManyWithWhereWithoutWorkoutExerciseInput = {
    where: WorkoutSetScalarWhereInput
    data: XOR<WorkoutSetUpdateManyMutationInput, WorkoutSetUncheckedUpdateManyWithoutWorkoutExerciseInput>
  }

  export type WorkoutSetScalarWhereInput = {
    AND?: WorkoutSetScalarWhereInput | WorkoutSetScalarWhereInput[]
    OR?: WorkoutSetScalarWhereInput[]
    NOT?: WorkoutSetScalarWhereInput | WorkoutSetScalarWhereInput[]
    id?: StringFilter<"WorkoutSet"> | string
    workoutExerciseId?: StringFilter<"WorkoutSet"> | string
    setNumber?: IntFilter<"WorkoutSet"> | number
    reps?: IntNullableFilter<"WorkoutSet"> | number | null
    weight?: FloatNullableFilter<"WorkoutSet"> | number | null
    weightUnit?: StringFilter<"WorkoutSet"> | string
    setType?: StringFilter<"WorkoutSet"> | string
    rpe?: IntNullableFilter<"WorkoutSet"> | number | null
    isPr?: BoolFilter<"WorkoutSet"> | boolean
    completed?: BoolFilter<"WorkoutSet"> | boolean
    restSeconds?: IntNullableFilter<"WorkoutSet"> | number | null
    durationSeconds?: IntNullableFilter<"WorkoutSet"> | number | null
    distanceMeters?: FloatNullableFilter<"WorkoutSet"> | number | null
    createdAt?: DateTimeFilter<"WorkoutSet"> | Date | string
  }

  export type WorkoutExerciseCreateWithoutSetsInput = {
    id?: string
    positionOrder: number
    notes?: string | null
    createdAt?: Date | string
    workout: StrengthWorkoutCreateNestedOneWithoutExercisesInput
    exercise: ExerciseCreateNestedOneWithoutWorkoutExercisesInput
  }

  export type WorkoutExerciseUncheckedCreateWithoutSetsInput = {
    id?: string
    workoutId: string
    exerciseId: string
    positionOrder: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type WorkoutExerciseCreateOrConnectWithoutSetsInput = {
    where: WorkoutExerciseWhereUniqueInput
    create: XOR<WorkoutExerciseCreateWithoutSetsInput, WorkoutExerciseUncheckedCreateWithoutSetsInput>
  }

  export type WorkoutExerciseUpsertWithoutSetsInput = {
    update: XOR<WorkoutExerciseUpdateWithoutSetsInput, WorkoutExerciseUncheckedUpdateWithoutSetsInput>
    create: XOR<WorkoutExerciseCreateWithoutSetsInput, WorkoutExerciseUncheckedCreateWithoutSetsInput>
    where?: WorkoutExerciseWhereInput
  }

  export type WorkoutExerciseUpdateToOneWithWhereWithoutSetsInput = {
    where?: WorkoutExerciseWhereInput
    data: XOR<WorkoutExerciseUpdateWithoutSetsInput, WorkoutExerciseUncheckedUpdateWithoutSetsInput>
  }

  export type WorkoutExerciseUpdateWithoutSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workout?: StrengthWorkoutUpdateOneRequiredWithoutExercisesNestedInput
    exercise?: ExerciseUpdateOneRequiredWithoutWorkoutExercisesNestedInput
  }

  export type WorkoutExerciseUncheckedUpdateWithoutSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutPersonalRecordsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPersonalRecordsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPersonalRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonalRecordsInput, UserUncheckedCreateWithoutPersonalRecordsInput>
  }

  export type ExerciseCreateWithoutPersonalRecordsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    equipmentNeeded?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    primaryMuscles: string
    secondaryMuscles?: string | null
    difficulty?: string
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    isCompound?: boolean
    isUnilateral?: boolean
    forceType?: string | null
    mechanic?: string | null
    metValue?: number | null
    is1RMEligible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workoutExercises?: WorkoutExerciseCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutPersonalRecordsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    equipmentNeeded?: string | null
    videoUrl?: string | null
    thumbnailUrl?: string | null
    primaryMuscles: string
    secondaryMuscles?: string | null
    difficulty?: string
    instructions?: string | null
    tips?: string | null
    commonMistakes?: string | null
    isCompound?: boolean
    isUnilateral?: boolean
    forceType?: string | null
    mechanic?: string | null
    metValue?: number | null
    is1RMEligible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workoutExercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutPersonalRecordsInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutPersonalRecordsInput, ExerciseUncheckedCreateWithoutPersonalRecordsInput>
  }

  export type UserUpsertWithoutPersonalRecordsInput = {
    update: XOR<UserUpdateWithoutPersonalRecordsInput, UserUncheckedUpdateWithoutPersonalRecordsInput>
    create: XOR<UserCreateWithoutPersonalRecordsInput, UserUncheckedCreateWithoutPersonalRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersonalRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersonalRecordsInput, UserUncheckedUpdateWithoutPersonalRecordsInput>
  }

  export type UserUpdateWithoutPersonalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExerciseUpsertWithoutPersonalRecordsInput = {
    update: XOR<ExerciseUpdateWithoutPersonalRecordsInput, ExerciseUncheckedUpdateWithoutPersonalRecordsInput>
    create: XOR<ExerciseCreateWithoutPersonalRecordsInput, ExerciseUncheckedCreateWithoutPersonalRecordsInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutPersonalRecordsInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutPersonalRecordsInput, ExerciseUncheckedUpdateWithoutPersonalRecordsInput>
  }

  export type ExerciseUpdateWithoutPersonalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    equipmentNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompound?: BoolFieldUpdateOperationsInput | boolean
    isUnilateral?: BoolFieldUpdateOperationsInput | boolean
    forceType?: NullableStringFieldUpdateOperationsInput | string | null
    mechanic?: NullableStringFieldUpdateOperationsInput | string | null
    metValue?: NullableFloatFieldUpdateOperationsInput | number | null
    is1RMEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutExercises?: WorkoutExerciseUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutPersonalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    equipmentNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryMuscles?: StringFieldUpdateOperationsInput | string
    secondaryMuscles?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    commonMistakes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompound?: BoolFieldUpdateOperationsInput | boolean
    isUnilateral?: BoolFieldUpdateOperationsInput | boolean
    forceType?: NullableStringFieldUpdateOperationsInput | string | null
    mechanic?: NullableStringFieldUpdateOperationsInput | string | null
    metValue?: NullableFloatFieldUpdateOperationsInput | number | null
    is1RMEligible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutExercises?: WorkoutExerciseUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type UserCreateWithoutBodyMetricsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBodyMetricsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBodyMetricsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBodyMetricsInput, UserUncheckedCreateWithoutBodyMetricsInput>
  }

  export type UserUpsertWithoutBodyMetricsInput = {
    update: XOR<UserUpdateWithoutBodyMetricsInput, UserUncheckedUpdateWithoutBodyMetricsInput>
    create: XOR<UserCreateWithoutBodyMetricsInput, UserUncheckedCreateWithoutBodyMetricsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBodyMetricsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBodyMetricsInput, UserUncheckedUpdateWithoutBodyMetricsInput>
  }

  export type UserUpdateWithoutBodyMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBodyMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationPrefsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationPrefsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationPrefsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
  }

  export type UserUpsertWithoutNotificationPrefsInput = {
    update: XOR<UserUpdateWithoutNotificationPrefsInput, UserUncheckedUpdateWithoutNotificationPrefsInput>
    create: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPrefsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPrefsInput, UserUncheckedUpdateWithoutNotificationPrefsInput>
  }

  export type UserUpdateWithoutNotificationPrefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPrefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutConsentsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConsentsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConsentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
  }

  export type UserUpsertWithoutConsentsInput = {
    update: XOR<UserUpdateWithoutConsentsInput, UserUncheckedUpdateWithoutConsentsInput>
    create: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConsentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConsentsInput, UserUncheckedUpdateWithoutConsentsInput>
  }

  export type UserUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDataExportRequestsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDataExportRequestsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    deletionRequests?: DeletionRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDataExportRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDataExportRequestsInput, UserUncheckedCreateWithoutDataExportRequestsInput>
  }

  export type UserUpsertWithoutDataExportRequestsInput = {
    update: XOR<UserUpdateWithoutDataExportRequestsInput, UserUncheckedUpdateWithoutDataExportRequestsInput>
    create: XOR<UserCreateWithoutDataExportRequestsInput, UserUncheckedCreateWithoutDataExportRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDataExportRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDataExportRequestsInput, UserUncheckedUpdateWithoutDataExportRequestsInput>
  }

  export type UserUpdateWithoutDataExportRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDataExportRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    deletionRequests?: DeletionRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDeletionRequestsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedOneWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    following?: UserFollowCreateNestedManyWithoutUserInput
    followers?: UserFollowCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeletionRequestsInput = {
    id?: string
    email: string
    username?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    onboarding?: UserOnboardingUncheckedCreateNestedOneWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    stretchingRoutines?: StretchingRoutineUncheckedCreateNestedManyWithoutUserInput
    stretchingSessions?: StretchingSessionUncheckedCreateNestedManyWithoutUserInput
    flexibilityGoals?: FlexibilityGoalUncheckedCreateNestedManyWithoutUserInput
    bodyMetrics?: BodyMetricUncheckedCreateNestedManyWithoutUserInput
    strengthWorkouts?: StrengthWorkoutUncheckedCreateNestedManyWithoutUserInput
    personalRecords?: PersonalRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    following?: UserFollowUncheckedCreateNestedManyWithoutUserInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutFollowingInput
    progressVideos?: ProgressVideoUncheckedCreateNestedManyWithoutUserInput
    dataExportRequests?: DataExportRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeletionRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeletionRequestsInput, UserUncheckedCreateWithoutDeletionRequestsInput>
  }

  export type UserUpsertWithoutDeletionRequestsInput = {
    update: XOR<UserUpdateWithoutDeletionRequestsInput, UserUncheckedUpdateWithoutDeletionRequestsInput>
    create: XOR<UserCreateWithoutDeletionRequestsInput, UserUncheckedCreateWithoutDeletionRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeletionRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeletionRequestsInput, UserUncheckedUpdateWithoutDeletionRequestsInput>
  }

  export type UserUpdateWithoutDeletionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    following?: UserFollowUpdateManyWithoutUserNestedInput
    followers?: UserFollowUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeletionRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboarding?: UserOnboardingUncheckedUpdateOneWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    stretchingRoutines?: StretchingRoutineUncheckedUpdateManyWithoutUserNestedInput
    stretchingSessions?: StretchingSessionUncheckedUpdateManyWithoutUserNestedInput
    flexibilityGoals?: FlexibilityGoalUncheckedUpdateManyWithoutUserNestedInput
    bodyMetrics?: BodyMetricUncheckedUpdateManyWithoutUserNestedInput
    strengthWorkouts?: StrengthWorkoutUncheckedUpdateManyWithoutUserNestedInput
    personalRecords?: PersonalRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    following?: UserFollowUncheckedUpdateManyWithoutUserNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutFollowingNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutUserNestedInput
    dataExportRequests?: DataExportRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StretchingRoutineCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    difficulty?: string
    durationSeconds: number
    targetAreas?: string | null
    tags?: string | null
    isPublic?: boolean
    isSystem?: boolean
    usesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StretchingSessionCreateManyUserInput = {
    id?: string
    routineId?: string | null
    routineName?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    completed?: boolean
    linkedWorkoutId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FlexibilityGoalCreateManyUserInput = {
    id?: string
    goalType: string
    description?: string | null
    targetArea: string
    baselineRom?: number | null
    targetRom?: number | null
    targetDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BodyMetricCreateManyUserInput = {
    id?: string
    weight?: number | null
    weightUnit?: string
    bodyFatPercentage?: number | null
    chest?: number | null
    waist?: number | null
    hips?: number | null
    arms?: number | null
    thighs?: number | null
    measurementUnit?: string
    measurementDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type StrengthWorkoutCreateManyUserInput = {
    id?: string
    name?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    sessionIntensityRpe?: number | null
    notes?: string | null
    totalVolume?: number | null
    createdAt?: Date | string
  }

  export type PersonalRecordCreateManyUserInput = {
    id?: string
    exerciseId: string
    recordType: string
    value: number
    weightUnit?: string
    achievedAt?: Date | string
    workoutId?: string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    notificationType: string
    title: string
    body?: string | null
    actionType?: string | null
    actionData?: string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    clickedAt?: Date | string | null
    deliveryStatus?: string
    createdAt?: Date | string
  }

  export type UserConsentCreateManyUserInput = {
    id?: string
    consentType: string
    version: string
    consented: boolean
    consentedAt?: Date | string | null
    withdrawnAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type UserFollowCreateManyUserInput = {
    id?: string
    followingUserId: string
    createdAt?: Date | string
  }

  export type UserFollowCreateManyFollowingInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ProgressVideoCreateManyUserInput = {
    id?: string
    goalId?: string | null
    videoUrl: string
    uploadedAt?: Date | string
  }

  export type DataExportRequestCreateManyUserInput = {
    id?: string
    status?: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    expiresAt?: Date | string | null
    downloadUrl?: string | null
    fileSizeBytes?: number | null
  }

  export type DeletionRequestCreateManyUserInput = {
    id?: string
    status?: string
    reason?: string | null
    requestedAt?: Date | string
    gracePeriodEndsAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type StretchingRoutineUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    targetAreas?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    usesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stretches?: RoutineStretchUpdateManyWithoutRoutineNestedInput
    sessions?: StretchingSessionUpdateManyWithoutRoutineNestedInput
  }

  export type StretchingRoutineUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    targetAreas?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    usesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stretches?: RoutineStretchUncheckedUpdateManyWithoutRoutineNestedInput
    sessions?: StretchingSessionUncheckedUpdateManyWithoutRoutineNestedInput
  }

  export type StretchingRoutineUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    durationSeconds?: IntFieldUpdateOperationsInput | number
    targetAreas?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    usesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StretchingSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineName?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    linkedWorkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routine?: StretchingRoutineUpdateOneWithoutSessionsNestedInput
    stretches?: SessionStretchUpdateManyWithoutSessionNestedInput
  }

  export type StretchingSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineId?: NullableStringFieldUpdateOperationsInput | string | null
    routineName?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    linkedWorkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stretches?: SessionStretchUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type StretchingSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineId?: NullableStringFieldUpdateOperationsInput | string | null
    routineName?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    linkedWorkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlexibilityGoalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetArea?: StringFieldUpdateOperationsInput | string
    baselineRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measurements?: RomMeasurementUpdateManyWithoutGoalNestedInput
    progressVideos?: ProgressVideoUpdateManyWithoutGoalNestedInput
  }

  export type FlexibilityGoalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetArea?: StringFieldUpdateOperationsInput | string
    baselineRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measurements?: RomMeasurementUncheckedUpdateManyWithoutGoalNestedInput
    progressVideos?: ProgressVideoUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type FlexibilityGoalUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetArea?: StringFieldUpdateOperationsInput | string
    baselineRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetRom?: NullableFloatFieldUpdateOperationsInput | number | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BodyMetricUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    bodyFatPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    chest?: NullableFloatFieldUpdateOperationsInput | number | null
    waist?: NullableFloatFieldUpdateOperationsInput | number | null
    hips?: NullableFloatFieldUpdateOperationsInput | number | null
    arms?: NullableFloatFieldUpdateOperationsInput | number | null
    thighs?: NullableFloatFieldUpdateOperationsInput | number | null
    measurementUnit?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BodyMetricUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    bodyFatPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    chest?: NullableFloatFieldUpdateOperationsInput | number | null
    waist?: NullableFloatFieldUpdateOperationsInput | number | null
    hips?: NullableFloatFieldUpdateOperationsInput | number | null
    arms?: NullableFloatFieldUpdateOperationsInput | number | null
    thighs?: NullableFloatFieldUpdateOperationsInput | number | null
    measurementUnit?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BodyMetricUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    bodyFatPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    chest?: NullableFloatFieldUpdateOperationsInput | number | null
    waist?: NullableFloatFieldUpdateOperationsInput | number | null
    hips?: NullableFloatFieldUpdateOperationsInput | number | null
    arms?: NullableFloatFieldUpdateOperationsInput | number | null
    thighs?: NullableFloatFieldUpdateOperationsInput | number | null
    measurementUnit?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrengthWorkoutUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    sessionIntensityRpe?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: WorkoutExerciseUpdateManyWithoutWorkoutNestedInput
  }

  export type StrengthWorkoutUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    sessionIntensityRpe?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: WorkoutExerciseUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type StrengthWorkoutUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    sessionIntensityRpe?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalVolume?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    weightUnit?: StringFieldUpdateOperationsInput | string
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
    exercise?: ExerciseUpdateOneRequiredWithoutPersonalRecordsNestedInput
  }

  export type PersonalRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    weightUnit?: StringFieldUpdateOperationsInput | string
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    weightUnit?: StringFieldUpdateOperationsInput | string
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionData?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionData?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionData?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    consented?: BoolFieldUpdateOperationsInput | boolean
    consentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    consented?: BoolFieldUpdateOperationsInput | boolean
    consentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    consentType?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    consented?: BoolFieldUpdateOperationsInput | boolean
    consentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withdrawnAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type UserFollowUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type UserFollowUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUncheckedUpdateManyWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressVideoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: FlexibilityGoalUpdateOneWithoutProgressVideosNestedInput
  }

  export type ProgressVideoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressVideoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataExportRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DataExportRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DataExportRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileSizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeletionRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gracePeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeletionRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gracePeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeletionRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gracePeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoutineStretchCreateManyStretchInput = {
    id?: string
    routineId: string
    positionOrder: number
    customDurationSeconds?: number | null
  }

  export type SessionStretchCreateManyStretchInput = {
    id?: string
    sessionId: string
    heldDurationSeconds: number
    feltTight?: boolean
    positionInRoutine: number
    completedAt?: Date | string
  }

  export type RoutineStretchUpdateWithoutStretchInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    customDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    routine?: StretchingRoutineUpdateOneRequiredWithoutStretchesNestedInput
  }

  export type RoutineStretchUncheckedUpdateWithoutStretchInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    customDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoutineStretchUncheckedUpdateManyWithoutStretchInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    customDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionStretchUpdateWithoutStretchInput = {
    id?: StringFieldUpdateOperationsInput | string
    heldDurationSeconds?: IntFieldUpdateOperationsInput | number
    feltTight?: BoolFieldUpdateOperationsInput | boolean
    positionInRoutine?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StretchingSessionUpdateOneRequiredWithoutStretchesNestedInput
  }

  export type SessionStretchUncheckedUpdateWithoutStretchInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    heldDurationSeconds?: IntFieldUpdateOperationsInput | number
    feltTight?: BoolFieldUpdateOperationsInput | boolean
    positionInRoutine?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionStretchUncheckedUpdateManyWithoutStretchInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    heldDurationSeconds?: IntFieldUpdateOperationsInput | number
    feltTight?: BoolFieldUpdateOperationsInput | boolean
    positionInRoutine?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutineStretchCreateManyRoutineInput = {
    id?: string
    stretchId: string
    positionOrder: number
    customDurationSeconds?: number | null
  }

  export type StretchingSessionCreateManyRoutineInput = {
    id?: string
    userId: string
    routineName?: string | null
    startedAt: Date | string
    completedAt?: Date | string | null
    durationSeconds?: number | null
    completed?: boolean
    linkedWorkoutId?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type RoutineStretchUpdateWithoutRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    customDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    stretch?: StretchUpdateOneRequiredWithoutRoutineStretchesNestedInput
  }

  export type RoutineStretchUncheckedUpdateWithoutRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    stretchId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    customDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoutineStretchUncheckedUpdateManyWithoutRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    stretchId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    customDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StretchingSessionUpdateWithoutRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    routineName?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    linkedWorkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStretchingSessionsNestedInput
    stretches?: SessionStretchUpdateManyWithoutSessionNestedInput
  }

  export type StretchingSessionUncheckedUpdateWithoutRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    routineName?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    linkedWorkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stretches?: SessionStretchUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type StretchingSessionUncheckedUpdateManyWithoutRoutineInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    routineName?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    linkedWorkoutId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionStretchCreateManySessionInput = {
    id?: string
    stretchId: string
    heldDurationSeconds: number
    feltTight?: boolean
    positionInRoutine: number
    completedAt?: Date | string
  }

  export type SessionStretchUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    heldDurationSeconds?: IntFieldUpdateOperationsInput | number
    feltTight?: BoolFieldUpdateOperationsInput | boolean
    positionInRoutine?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stretch?: StretchUpdateOneRequiredWithoutSessionStretchesNestedInput
  }

  export type SessionStretchUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stretchId?: StringFieldUpdateOperationsInput | string
    heldDurationSeconds?: IntFieldUpdateOperationsInput | number
    feltTight?: BoolFieldUpdateOperationsInput | boolean
    positionInRoutine?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionStretchUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stretchId?: StringFieldUpdateOperationsInput | string
    heldDurationSeconds?: IntFieldUpdateOperationsInput | number
    feltTight?: BoolFieldUpdateOperationsInput | boolean
    positionInRoutine?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RomMeasurementCreateManyGoalInput = {
    id?: string
    romDegrees: number
    measurementDate?: Date | string
    measurementMethod?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProgressVideoCreateManyGoalInput = {
    id?: string
    userId: string
    videoUrl: string
    uploadedAt?: Date | string
  }

  export type RomMeasurementUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    romDegrees?: FloatFieldUpdateOperationsInput | number
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RomMeasurementUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    romDegrees?: FloatFieldUpdateOperationsInput | number
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RomMeasurementUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    romDegrees?: FloatFieldUpdateOperationsInput | number
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    measurementMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressVideoUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProgressVideosNestedInput
  }

  export type ProgressVideoUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressVideoUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutExerciseCreateManyExerciseInput = {
    id?: string
    workoutId: string
    positionOrder: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type PersonalRecordCreateManyExerciseInput = {
    id?: string
    userId: string
    recordType: string
    value: number
    weightUnit?: string
    achievedAt?: Date | string
    workoutId?: string | null
  }

  export type WorkoutExerciseUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workout?: StrengthWorkoutUpdateOneRequiredWithoutExercisesNestedInput
    sets?: WorkoutSetUpdateManyWithoutWorkoutExerciseNestedInput
  }

  export type WorkoutExerciseUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sets?: WorkoutSetUncheckedUpdateManyWithoutWorkoutExerciseNestedInput
  }

  export type WorkoutExerciseUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    workoutId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalRecordUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    weightUnit?: StringFieldUpdateOperationsInput | string
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPersonalRecordsNestedInput
  }

  export type PersonalRecordUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    weightUnit?: StringFieldUpdateOperationsInput | string
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalRecordUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    weightUnit?: StringFieldUpdateOperationsInput | string
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutExerciseCreateManyWorkoutInput = {
    id?: string
    exerciseId: string
    positionOrder: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type WorkoutExerciseUpdateWithoutWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercise?: ExerciseUpdateOneRequiredWithoutWorkoutExercisesNestedInput
    sets?: WorkoutSetUpdateManyWithoutWorkoutExerciseNestedInput
  }

  export type WorkoutExerciseUncheckedUpdateWithoutWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sets?: WorkoutSetUncheckedUpdateManyWithoutWorkoutExerciseNestedInput
  }

  export type WorkoutExerciseUncheckedUpdateManyWithoutWorkoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    positionOrder?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetCreateManyWorkoutExerciseInput = {
    id?: string
    setNumber: number
    reps?: number | null
    weight?: number | null
    weightUnit?: string
    setType?: string
    rpe?: number | null
    isPr?: boolean
    completed?: boolean
    restSeconds?: number | null
    durationSeconds?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
  }

  export type WorkoutSetUpdateWithoutWorkoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    setType?: StringFieldUpdateOperationsInput | string
    rpe?: NullableIntFieldUpdateOperationsInput | number | null
    isPr?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetUncheckedUpdateWithoutWorkoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    setType?: StringFieldUpdateOperationsInput | string
    rpe?: NullableIntFieldUpdateOperationsInput | number | null
    isPr?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSetUncheckedUpdateManyWithoutWorkoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    reps?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: StringFieldUpdateOperationsInput | string
    setType?: StringFieldUpdateOperationsInput | string
    rpe?: NullableIntFieldUpdateOperationsInput | number | null
    isPr?: BoolFieldUpdateOperationsInput | boolean
    completed?: BoolFieldUpdateOperationsInput | boolean
    restSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StretchCountOutputTypeDefaultArgs instead
     */
    export type StretchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StretchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StretchingRoutineCountOutputTypeDefaultArgs instead
     */
    export type StretchingRoutineCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StretchingRoutineCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StretchingSessionCountOutputTypeDefaultArgs instead
     */
    export type StretchingSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StretchingSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlexibilityGoalCountOutputTypeDefaultArgs instead
     */
    export type FlexibilityGoalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlexibilityGoalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseCountOutputTypeDefaultArgs instead
     */
    export type ExerciseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StrengthWorkoutCountOutputTypeDefaultArgs instead
     */
    export type StrengthWorkoutCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StrengthWorkoutCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkoutExerciseCountOutputTypeDefaultArgs instead
     */
    export type WorkoutExerciseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkoutExerciseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserOnboardingDefaultArgs instead
     */
    export type UserOnboardingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserOnboardingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserFollowDefaultArgs instead
     */
    export type UserFollowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserFollowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StretchDefaultArgs instead
     */
    export type StretchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StretchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StretchingRoutineDefaultArgs instead
     */
    export type StretchingRoutineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StretchingRoutineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoutineStretchDefaultArgs instead
     */
    export type RoutineStretchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoutineStretchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StretchingSessionDefaultArgs instead
     */
    export type StretchingSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StretchingSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionStretchDefaultArgs instead
     */
    export type SessionStretchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionStretchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlexibilityGoalDefaultArgs instead
     */
    export type FlexibilityGoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlexibilityGoalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RomMeasurementDefaultArgs instead
     */
    export type RomMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RomMeasurementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgressVideoDefaultArgs instead
     */
    export type ProgressVideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgressVideoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseDefaultArgs instead
     */
    export type ExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StrengthWorkoutDefaultArgs instead
     */
    export type StrengthWorkoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StrengthWorkoutDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkoutExerciseDefaultArgs instead
     */
    export type WorkoutExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkoutExerciseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkoutSetDefaultArgs instead
     */
    export type WorkoutSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkoutSetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonalRecordDefaultArgs instead
     */
    export type PersonalRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonalRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BodyMetricDefaultArgs instead
     */
    export type BodyMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BodyMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationPreferenceDefaultArgs instead
     */
    export type NotificationPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationPreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserConsentDefaultArgs instead
     */
    export type UserConsentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserConsentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DataExportRequestDefaultArgs instead
     */
    export type DataExportRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataExportRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeletionRequestDefaultArgs instead
     */
    export type DeletionRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeletionRequestDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}